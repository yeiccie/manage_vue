import './main.css';
import { defineComponent as ae, onMounted as oe, onUnmounted as le, ref as I, reactive as ce, watch as J, computed as A, openBlock as re, createBlock as de, Teleport as ue, createElementVNode as o, normalizeClass as x, normalizeStyle as w, unref as f, withModifiers as $, toDisplayString as G } from "vue";
const he = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAELklEQVRYR+2YW2wUZRTH//9vtlCoF9IoIklT3PqgPGi326hoetuaGEhIr9SgCYkkgt2WGOQVCca+GavWdr0GjD4YhG3RB3hply1LQA1tEQIxEXapGI2pEkys9LIzx2ylYWfY6e5sF0oi+7hzzvl+3/9855xvhrjNf7zN+XAHcL4Z+n8o6JWTeYt++W25S596AIZy6TB+n3yo+Nchlk8vmIIVowdXU9c3Q1gDSilBlQwjgBAYFGDvdF58/4milqvZwDpOcXWsb5Uh8hmBqkwXFMhlCN8aX5LXNbRy/T+Z+iXsHAFWRXs3QGQPyLucLDJrK5DgUXdTsxPfjAEro8E3Ce50EtxsKxPTwCPH3U2jTmJkBJgWTnAMxDeGMEoa0xQ+LJQnCD4HYFkCyAC3RdwN3U7gMkpxRTTYrMD91sCJIgCxV5R6O1Jcfy7VwonqLoj9/CqB2kF341qncGkBvRe+ureAWpRgoalCBecMFzcdK24YymZRJz5zprgq1tsJwXYL3CVZGvdGHmwZc7JQtra2gE+f712ep2QUYP714DJhaJrXLqXZQszlZwtYdSHoB9ljVk/ePVrSZFL0ZkAlxzQBVseCT8WhZhRThtFB8plk9Zi/qCi8cv0fNxvKFrDy4oF11NXXIFy2EII4iBcG3Y03VLZT8OqRd5aFPduvOEpxRayvXolxAKB2g6NgEhobBlc1HHYKY7WvHf5wtVAPgegIlbbZ9seUZ7AyFnwewi9pGoUyDmhrB931kfnC1ZwOeKlLP8GZJi6QLSFP2yep4toXSbT3ZQAfX3O6omt8Nhd9r/aHQAUMOQywYBZo5uZD2ThQ2rbPCjlnH6yI9rUryE5DU75ctJaake46Be4DuDjF8dFBNA94/AdtiySVxIlpMlTS8td801o70vMigM9huTda2lhcKHVHPO2HZv/P6LIwX7hk/+qzPSvUJGMkrg8AQYTkroRdXMlE+HH/twsG6BsOdJHYZlaO/lBZ6weOiiSXqs3Gqj0TeAxx+T75DIpgwjC0onD51pQD4JaluPrkR/cpFT9DcoVp84LOgTL/DjtBbglgou+puHwB8lEznPxJw1XSX77VtgizBvQNBw4RMqB7xt4Lc3c8lQKJaQHoO4R8ydz0/7MWoCXk8c85MrMC9J3qaafw/WtQlwXST+F3BnAeYB4obgJ1BJIuG+YtiKAjVOZ/Pd1ZdwzoG+4uBtSPpjaRbhXLcwF3hzytb2TilgVgT5BkYybBrTYC+Rvg5nRpdTRJrIs8+VPXPQXj2i4ItxC4O2NQQUQnN4U9rRcz9nH64p4ceM2lziX5Y4s3KHCdUHwE77ecMkMEp6BwhIa2Z6DslZRvfulgHafYLuCas58WLp2aLCFUga70qxOFU6dPFL2W1feYeaU43Y5z/TxnCuYabMEuC043ckdBp4pZ7f8FE5psOI1g6fwAAAAASUVORK5CYII=", fe = ["width", "height"], ve = ["width", "height"], ge = ["width", "height"], pe = /* @__PURE__ */ o("div", { class: "loading-gif_" }, [
  /* @__PURE__ */ o("span"),
  /* @__PURE__ */ o("span"),
  /* @__PURE__ */ o("span"),
  /* @__PURE__ */ o("span"),
  /* @__PURE__ */ o("span")
], -1), me = [
  pe
], we = { class: "auth-control_" }, Xe = { class: "range-text" }, ye = /* @__PURE__ */ o("div", null, null, -1), xe = /* @__PURE__ */ o("div", null, null, -1), Se = /* @__PURE__ */ o("div", null, null, -1), Te = [
  ye,
  xe,
  Se
], Me = /* @__PURE__ */ ae({
  __name: "App",
  props: {
    type: { type: String, default: "modal" },
    // 模式 modal,inside
    canvasWidth: { type: Number, default: 310 },
    // 主canvas的宽
    canvasHeight: { type: Number, default: 160 },
    // 主canvas的高
    show: { type: Boolean, default: !1 },
    // 是否出现，由父级控制
    puzzleScale: { type: Number, default: 1 },
    // 拼图块的大小缩放比例
    sliderSize: { type: Number, default: 50 },
    // 滑块的大小
    range: { type: Number, default: 10 },
    // 允许的偏差值
    zIndex: { type: Number, default: 999 },
    // 层级
    imgs: {
      type: Array,
      default: null
    },
    successText: {
      type: String,
      default: "验证通过！"
    },
    failText: {
      type: String,
      default: "验证失败，请重试"
    },
    sliderText: {
      type: String,
      default: "拖动滑块完成拼图"
    },
    className: {
      type: String,
      default: ""
    }
  },
  emits: ["success", "fail", "close", "reset"],
  setup(c, { expose: V, emit: M }) {
    const a = c;
    oe(() => {
      document.addEventListener("mousemove", B, !1), document.addEventListener("mouseup", C, !1), document.addEventListener("touchmove", B, { passive: !1 }), document.addEventListener("touchend", C, !1), e.isInside = a.type === "inside", a.show && (!e.isInside && document.body.classList.add("vue-puzzle-overflow"), T());
    }), le(() => {
      e.timer1 && clearTimeout(e.timer1), document.removeEventListener("mousemove", B, !1), document.removeEventListener("mouseup", C, !1), document.removeEventListener("touchmove", B, !1), document.removeEventListener("touchend", C, !1);
    });
    const H = I(), R = I(), L = I(), k = I(), e = ce({
      isInside: !1,
      mouseDown: !1,
      startWidth: 50,
      startX: 0,
      newX: 0,
      pinX: 0,
      pinY: 0,
      loading: !1,
      isCanSlide: !1,
      error: !1,
      infoBoxShow: !1,
      infoText: "",
      infoBoxFail: !1,
      timer1: void 0,
      closeDown: !1,
      isSuccess: !1,
      imgIndex: -1,
      isSubmting: !1
    });
    J(
      () => a.show,
      (n) => {
        n ? (!e.isInside && document.body.classList.add("vue-puzzle-overflow"), T()) : (e.isSubmting = !1, e.isSuccess = !1, e.infoBoxShow = !1, document.body.classList.remove("vue-puzzle-overflow"));
      }
    ), J(() => a.type, (n) => {
      n === "inside" ? (e.isInside = !0, document.body.classList.remove("vue-puzzle-overflow")) : e.isInside = !1;
    });
    const S = A(() => {
      const n = e.startWidth + e.newX - e.startX;
      return n < h.value ? h.value : n > a.canvasWidth ? a.canvasWidth : n;
    }), d = A(() => Math.round(Math.max(Math.min(a.puzzleScale, 2), 0.2) * 52.5 + 6)), h = A(() => Math.max(
      Math.min(Math.round(a.sliderSize), Math.round(a.canvasWidth * 0.5)),
      10
    )), q = A(() => a.zIndex !== 999 ? `z-index:${a.zIndex}` : ""), j = () => {
      !e.mouseDown && !e.isSubmting && (e.timer1 && clearTimeout(e.timer1), M("close"));
    }, P = () => {
      e.isInside || (e.closeDown = !0);
    }, F = () => {
      e.closeDown && j(), e.closeDown = !1;
    }, O = (n) => {
      var i;
      e.isCanSlide && (e.mouseDown = !0, e.startWidth = ((i = H.value) == null ? void 0 : i.clientWidth) || 0, e.newX = n.clientX !== void 0 ? n.clientX : n.changedTouches[0].clientX, e.startX = n.clientX !== void 0 ? n.clientX : n.changedTouches[0].clientX);
    }, B = (n) => {
      e.mouseDown && (n.preventDefault(), e.newX = n.clientX !== void 0 ? n.clientX : n.changedTouches[0].clientX);
    }, C = () => {
      e.mouseDown && (e.mouseDown = !1, ee());
    }, E = (n = !1) => {
      var Z;
      if (e.loading && !n)
        return;
      e.loading = !0, e.isCanSlide = !1;
      const i = R.value, r = L.value, u = k.value, s = i == null ? void 0 : i.getContext("2d", { willReadFrequently: !0 }), t = r == null ? void 0 : r.getContext("2d"), v = u == null ? void 0 : u.getContext("2d");
      if (!s || !t || !v) {
        console.error("not found ctx / ctx2 / ctx3");
        return;
      }
      const ne = navigator.userAgent.indexOf("Firefox") >= 0 && navigator.userAgent.indexOf("Windows") >= 0, p = document.createElement("img");
      if (s.fillStyle = "rgba(255,255,255,1)", v.fillStyle = "rgba(255,255,255,1)", s.clearRect(0, 0, a.canvasWidth, a.canvasHeight), t.clearRect(0, 0, a.canvasWidth, a.canvasHeight), e.pinX = l(
        d.value + 20,
        a.canvasWidth - d.value - 10
      ), e.pinY = l(20, a.canvasHeight - d.value - 10), p.crossOrigin = "anonymous", p.onload = () => {
        const [g, z, W, D] = K(p), Q = Math.random(), U = Math.random(), N = Math.random(), se = Math.random(), Y = Q < 0.33 ? -1 : Q < 0.66 ? 0 : 1, X = U < 0.33 ? -1 : U < 0.66 ? 0 : 1, y = N < 0.33 ? -1 : N < 0.66 ? 0 : 1;
        let m = se < 0.6 ? 1 : 0;
        Y === X && X === y && y === m && m === 0 && (m = 1), s.save(), b(s, Y, X, y, m), s.closePath(), ne ? (s.clip(), s.save(), s.shadowOffsetX = 0, s.shadowOffsetY = 0, s.shadowColor = "#000", s.shadowBlur = 3, s.fill(), s.restore()) : (s.shadowOffsetX = 0, s.shadowOffsetY = 0, s.shadowColor = "#000", s.shadowBlur = 3, s.fill(), s.clip()), s.drawImage(p, g, z, W, D), v.fillRect(0, 0, a.canvasWidth, a.canvasHeight), v.drawImage(p, g, z, W, D), s.globalCompositeOperation = "source-atop", b(s, Y, X, y, m), s.arc(
          e.pinX + Math.ceil(d.value / 2),
          e.pinY + Math.ceil(d.value / 2),
          d.value * 1.2,
          0,
          Math.PI * 2,
          !0
        ), s.closePath(), s.shadowColor = "rgba(255, 255, 255, .8)", s.shadowOffsetX = -1, s.shadowOffsetY = -1, s.shadowBlur = Math.min(Math.ceil(8 * a.puzzleScale), 12), s.fillStyle = "#ffffaa", s.fill();
        const ie = s.getImageData(
          e.pinX - 3,
          // 为了阴影 是从-3px开始截取，判定的时候要+3px
          e.pinY - 20,
          e.pinX + d.value + 5,
          e.pinY + d.value + 5
        );
        t.putImageData(ie, 0, e.pinY - 20), s.restore(), s.clearRect(0, 0, a.canvasWidth, a.canvasHeight), s.save(), b(s, Y, X, y, m), s.globalAlpha = 0.8, s.fillStyle = "#ffffff", s.fill(), s.restore(), s.save(), s.globalCompositeOperation = "source-atop", b(s, Y, X, y, m), s.arc(
          e.pinX + Math.ceil(d.value / 2),
          e.pinY + Math.ceil(d.value / 2),
          d.value * 1.2,
          0,
          Math.PI * 2,
          !0
        ), s.shadowColor = "#000", s.shadowOffsetX = 2, s.shadowOffsetY = 2, s.shadowBlur = 16, s.fill(), s.restore(), s.save(), s.globalCompositeOperation = "destination-over", s.drawImage(p, g, z, W, D), s.restore(), e.loading = !1, e.isCanSlide = !0;
      }, p.onerror = () => {
        E(!0);
      }, !n && ((Z = a.imgs) != null && Z.length)) {
        let g = l(0, a.imgs.length - 1);
        g === e.imgIndex && (g === a.imgs.length - 1 ? g = 0 : g++), e.imgIndex = g, p.src = a.imgs[g];
      } else
        p.src = _();
    }, l = (n, i) => Math.ceil(Math.random() * (i - n) + n), K = (n) => {
      const i = n.width / n.height, r = a.canvasWidth / a.canvasHeight;
      let u = 0, s = 0, t = 0, v = 0;
      return i > r ? (v = a.canvasHeight, t = i * v, s = 0, u = (a.canvasWidth - t) / 2) : (t = a.canvasWidth, v = t / i, u = 0, s = (a.canvasHeight - v) / 2), [u, s, t, v];
    }, b = (n, i, r, u, s) => {
      const t = Math.ceil(15 * a.puzzleScale);
      n.beginPath(), n.moveTo(e.pinX, e.pinY), n.lineTo(e.pinX + t, e.pinY), n.arcTo(
        e.pinX + t,
        e.pinY + i * t / 2,
        e.pinX + t + t / 2,
        e.pinY + i * t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + t + t,
        e.pinY + i * t / 2,
        e.pinX + t + t,
        e.pinY,
        t / 2
      ), n.lineTo(e.pinX + t + t + t, e.pinY), n.lineTo(e.pinX + t + t + t, e.pinY + t), n.arcTo(
        e.pinX + t + t + t + r * t / 2,
        e.pinY + t,
        e.pinX + t + t + t + r * t / 2,
        e.pinY + t + t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + t + t + t + r * t / 2,
        e.pinY + t + t,
        e.pinX + t + t + t,
        e.pinY + t + t,
        t / 2
      ), n.lineTo(e.pinX + t + t + t, e.pinY + t + t + t), n.lineTo(e.pinX + t + t, e.pinY + t + t + t), n.arcTo(
        e.pinX + t + t,
        e.pinY + t + t + t + u * t / 2,
        e.pinX + t + t / 2,
        e.pinY + t + t + t + u * t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + t,
        e.pinY + t + t + t + u * t / 2,
        e.pinX + t,
        e.pinY + t + t + t,
        t / 2
      ), n.lineTo(e.pinX, e.pinY + t + t + t), n.lineTo(e.pinX, e.pinY + t + t), n.arcTo(
        e.pinX + s * t / 2,
        e.pinY + t + t,
        e.pinX + s * t / 2,
        e.pinY + t + t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + s * t / 2,
        e.pinY + t,
        e.pinX,
        e.pinY + t,
        t / 2
      ), n.lineTo(e.pinX, e.pinY);
    }, _ = () => {
      const n = document.createElement("canvas"), i = n.getContext("2d");
      if (!i)
        return console.error("not found ctx"), "";
      n.width = a.canvasWidth, n.height = a.canvasHeight, i.fillStyle = `rgb(${l(100, 255)},${l(
        100,
        255
      )},${l(100, 255)})`, i.fillRect(0, 0, a.canvasWidth, a.canvasHeight);
      for (let r = 0; r < 12; r++)
        if (i.fillStyle = `rgb(${l(100, 255)},${l(
          100,
          255
        )},${l(100, 255)})`, i.strokeStyle = `rgb(${l(100, 255)},${l(
          100,
          255
        )},${l(100, 255)})`, l(0, 2) > 1)
          i.save(), i.rotate(l(-90, 90) * Math.PI / 180), i.fillRect(
            l(-20, n.width - 20),
            l(-20, n.height - 20),
            l(10, n.width / 2 + 10),
            l(10, n.height / 2 + 10)
          ), i.restore();
        else {
          i.beginPath();
          const u = l(-Math.PI, Math.PI);
          i.arc(
            l(0, n.width),
            l(0, n.height),
            l(10, n.height / 2 + 10),
            u,
            u + Math.PI * 1.5
          ), i.closePath(), i.fill();
        }
      return n.toDataURL("image/png");
    }, ee = () => {
      e.isSubmting = !0;
      const n = S.value - h.value - (d.value - h.value) * ((S.value - h.value) / (a.canvasWidth - h.value)), i = e.pinX - 3 - n;
      Math.abs(i) < a.range ? (e.infoText = a.successText, e.infoBoxFail = !1, e.infoBoxShow = !0, e.isCanSlide = !1, e.isSuccess = !0, e.timer1 && clearTimeout(e.timer1), e.timer1 = setTimeout(() => {
        e.isSubmting = !1, M("success", i, { deviation: i, offsetX: n, pinX: e.pinX - 3 });
      }, 800)) : (e.infoText = a.failText, e.infoBoxFail = !0, e.infoBoxShow = !0, e.isCanSlide = !1, M("fail", i, { deviation: i, offsetX: n, pinX: e.pinX - 3 }), e.timer1 && clearTimeout(e.timer1), e.timer1 = setTimeout(() => {
        e.isSubmting = !1, T();
      }, 800));
    }, te = () => {
      e.infoBoxFail = !1, e.infoBoxShow = !1, e.isCanSlide = !1, e.isSuccess = !1, e.startWidth = h.value, e.startX = 0, e.newX = 0;
    }, T = (n) => {
      e.isSubmting || (te(), E(), n && M("reset"));
    };
    return V({ reset: T }), (n, i) => (re(), de(ue, {
      to: "body",
      disabled: e.isInside
    }, [
      o("div", {
        class: x(["vue-puzzle-vcode", { inside_: e.isInside, show_: c.show }, c.className]),
        style: w(f(q)),
        onMousedown: P,
        onMouseup: F,
        onTouchstartPassive: P,
        onTouchend: F
      }, [
        o("div", {
          class: "vue-auth-box_",
          onMousedown: i[3] || (i[3] = $(() => {
          }, ["stop"])),
          onTouchstart: i[4] || (i[4] = $(() => {
          }, ["stop"]))
        }, [
          o("div", {
            class: "auth-body_",
            style: w(`width:${c.canvasWidth}px;height: ${c.canvasHeight}px`)
          }, [
            o("canvas", {
              ref_key: "canvas1",
              ref: R,
              class: "auth-canvas1_",
              width: c.canvasWidth,
              height: c.canvasHeight
            }, null, 8, fe),
            o("canvas", {
              ref_key: "canvas3",
              ref: k,
              class: x(["auth-canvas3_", { show: e.isSuccess }]),
              width: c.canvasWidth,
              height: c.canvasHeight
            }, null, 10, ve),
            o("canvas", {
              ref_key: "canvas2",
              ref: L,
              class: "auth-canvas2_",
              width: f(d),
              height: c.canvasHeight,
              style: w(`width:${f(d)}px;height:${c.canvasHeight}px;transform:translateX(${f(S) - f(h) - (f(d) - f(h)) * ((f(S) - f(h)) / (c.canvasWidth - f(h)))}px)`)
            }, null, 12, ge),
            o("div", {
              class: x(["loading-box_", { hide_: !e.loading }])
            }, me, 2),
            o("div", {
              class: x([
                "info-box_",
                { show: e.infoBoxShow },
                { fail: e.infoBoxFail }
              ])
            }, G(e.infoText), 3),
            o("div", {
              class: x(["flash_", { show: e.isSuccess }]),
              style: w(`transform: translateX(${e.isSuccess ? `${c.canvasWidth + c.canvasHeight * 0.578}px` : `-${c.canvasHeight * 0.578}px`}) skew(-30deg, 0);`)
            }, null, 6),
            o("img", {
              class: "reset_",
              onClick: i[0] || (i[0] = (r) => T(!0)),
              src: he
            })
          ], 4),
          o("div", we, [
            o("div", {
              class: "range-box",
              style: w(`height:${f(h)}px;width:${c.canvasWidth}px`)
            }, [
              o("div", Xe, G(c.sliderText), 1),
              o("div", {
                class: "range-slider",
                ref_key: "rangeSlider",
                ref: H,
                style: w(`width:${f(S)}px`)
              }, [
                o("div", {
                  class: x(["range-btn", { isDown: e.mouseDown }]),
                  style: w(`width:${f(h)}px`),
                  onMousedown: i[1] || (i[1] = (r) => O(r)),
                  onTouchstart: i[2] || (i[2] = (r) => O(r))
                }, Te, 38)
              ], 4)
            ], 4)
          ])
        ], 32)
      ], 38)
    ], 8, ["disabled"]));
  }
});
export {
  Me as default
};
