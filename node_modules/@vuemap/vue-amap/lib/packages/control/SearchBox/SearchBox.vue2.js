'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
require('../../../mixins/index.js');
require('../../../utils/index.js');
var props = require('./props.js');
var guid = require('../../../utils/guid.js');
var useRegister = require('../../../mixins/useRegister.js');

const _hoisted_1 = { class: "el-vue-search-box-container" };
const _hoisted_2 = ["id", "placeholder"];
var script = /* @__PURE__ */ vue.defineComponent({
  ...{
    name: "ElAmapSearchBox",
    inheritAttrs: false
  },
  __name: "SearchBox",
  props: props.propsTypes,
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const saveInputId = vue.ref(guid.default());
    const saveVisible = vue.ref(true);
    let $amapComponent;
    let preInput;
    const { $$getInstance } = useRegister.useRegister((options, parentComponent) => {
      if (options.inputId) {
        saveInputId.value = options.inputId;
        delete options.inputId;
      }
      if (options.visible) {
        saveVisible.value = options.visible;
      }
      options.input = saveInputId.value;
      if (options.outputId) {
        options.output = options.outputId;
        delete options.outputId;
      }
      let _inputTimer;
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.AutoComplete"], () => {
          const debounce = props.debounce;
          preInput = AMap.Autocomplete.prototype.onInPut;
          AMap.Autocomplete.prototype.onInPut = function() {
            clearTimeout(_inputTimer);
            _inputTimer = setTimeout(() => {
              this.output && this.autoSearch();
            }, debounce);
          };
          $amapComponent = new AMap.AutoComplete(options);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      watchRedirectFn: {
        __visible(flag) {
          saveVisible.value = flag;
        },
        __citylimit(flag) {
          $amapComponent.setCityLimit(flag);
        }
      },
      destroyComponent() {
        if (preInput && AMap.Autocomplete) {
          AMap.Autocomplete.prototype.onInPut = preInput;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
        "div",
        _hoisted_1,
        [
          !_ctx.inputCustom ? (vue.openBlock(), vue.createElementBlock("input", {
            key: 0,
            id: saveInputId.value,
            type: "text",
            placeholder: _ctx.placeholder
          }, null, 8, _hoisted_2)) : vue.createCommentVNode("v-if", true)
        ],
        512
        /* NEED_PATCH */
      )), [
        [vue.vShow, _ctx.visible && !_ctx.inputCustom]
      ]);
    };
  }
});

exports.default = script;
//# sourceMappingURL=SearchBox.vue2.js.map
