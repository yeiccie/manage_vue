/*! @vuemap/vue-amap v2.1.12 */

import { defineComponent, isProxy, toRaw, unref, getCurrentInstance, inject, onMounted, onBeforeUnmount, onBeforeUpdate, onUpdated, nextTick, watch, provide, ref, openBlock, createElementBlock, createElementVNode, renderSlot, withDirectives, createCommentVNode, vShow, onUnmounted, createBlock, Teleport, useSlots, useAttrs } from 'vue';

const makeInstaller = (components = []) => {
  const apps = [];
  const install = (app) => {
    if (apps.includes(app))
      return;
    apps.push(app);
    components.forEach((c) => app.use(c));
  };
  return {
    install
  };
};

function guid() {
  const s = [];
  const hexDigits = "0123456789abcdef";
  for (let i = 0; i < 36; i++) {
    s[i] = hexDigits.charAt(Math.floor(Math.random() * 16));
  }
  s[8] = s[13] = s[18] = s[23] = "-";
  return s.join("");
}

function isMapInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.Map;
}
function isOverlayGroupInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.OverlayGroup;
}
function isIndoorMapInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.IndoorMap;
}
function isLabelsLayerInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.LabelsLayer;
}
function isVectorLayerInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.VectorLayer;
}
function convertEventToLowerCase(functionName) {
  if (!functionName || functionName.length < 4) {
    return functionName;
  }
  const func = functionName.substring(3, functionName.length);
  const firstLetter = functionName[2].toLowerCase();
  return firstLetter + func;
}
const eventReg = /^on[A-Z]+/;
function loadScript(url, callback) {
  if (!url) {
    throw new Error("\u8BF7\u4F20\u5165url");
  }
  const script = document.createElement("script");
  script.type = "text/javascript";
  script.async = true;
  script.defer = true;
  script.src = url;
  document.body.appendChild(script);
  if (callback) {
    script.addEventListener("load", () => {
      callback();
    });
  }
}
function convertLnglat(lnglat) {
  if (Array.isArray(lnglat)) {
    return lnglat.map(convertLnglat);
  }
  return lnglat.toArray();
}
function upperCamelCase(prop) {
  if (!prop) {
    return prop;
  }
  return prop.charAt(0).toUpperCase() + prop.slice(1);
}

function bindInstanceEvent(instance, eventName, handler) {
  if (!instance || !instance.on) {
    return;
  }
  instance.on(eventName, handler);
}
function removeInstanceEvent(instance, eventName, handler) {
  if (!instance || !instance.off) {
    return;
  }
  instance.off(eventName, handler);
}

function toPixel(arr) {
  return new AMap.Pixel(arr[0], arr[1]);
}
function toSize(arr) {
  return new AMap.Size(arr[0], arr[1]);
}
function pixelTo(pixel) {
  if (Array.isArray(pixel))
    return pixel;
  return [pixel.getX(), pixel.getY()];
}
function toLngLat(arr) {
  return new AMap.LngLat(arr[0], arr[1]);
}
function lngLatTo(lngLat) {
  if (!lngLat)
    return;
  if (Array.isArray(lngLat))
    return lngLat.slice();
  return [lngLat.getLng(), lngLat.getLat()];
}
function toBounds(arrs) {
  return new AMap.Bounds(toLngLat(arrs[0]), toLngLat(arrs[1]));
}

const pi$1 = 3.141592653589793;
const a = 6378245;
const ee$2 = 0.006693421622965943;
const x_pi = pi$1 * 3e3 / 180;
function lonLatToTileNumbers(lon_deg, lat_deg, zoom) {
  const lat_rad = pi$1 / 180 * lat_deg;
  const n = Math.pow(2, zoom);
  const xtile = Math.floor((lon_deg + 180) / 360 * n);
  const ytile = Math.floor((1 - Math.asinh(Math.tan(lat_rad)) / pi$1) / 2 * n);
  return [xtile, ytile];
}
function tileNumbersToLonLat(xtile, ytile, zoom) {
  const n = Math.pow(2, zoom);
  const lon_deg = xtile / n * 360 - 180;
  const lat_rad = Math.atan(Math.sinh(pi$1 * (1 - 2 * ytile / n)));
  const lat_deg = lat_rad * 180 / pi$1;
  return [lon_deg, lat_deg];
}
function bd09_To_gps84(lng, lat) {
  const gcj02 = bd09_To_gcj02(lng, lat);
  const map84 = gcj02_To_gps84(gcj02.lng, gcj02.lat);
  return map84;
}
function gps84_To_bd09(lng, lat) {
  const gcj02 = gps84_To_gcj02(lng, lat);
  const bd09 = gcj02_To_bd09(gcj02.lng, gcj02.lat);
  return bd09;
}
function gps84_To_gcj02(lng, lat) {
  let dLat = transformLat(lng - 105, lat - 35);
  let dLng = transformLng(lng - 105, lat - 35);
  const radLat = lat / 180 * pi$1;
  let magic = Math.sin(radLat);
  magic = 1 - ee$2 * magic * magic;
  const sqrtMagic = Math.sqrt(magic);
  dLat = dLat * 180 / (a * (1 - ee$2) / (magic * sqrtMagic) * pi$1);
  dLng = dLng * 180 / (a / sqrtMagic * Math.cos(radLat) * pi$1);
  const mgLat = lat + dLat;
  const mgLng = lng + dLng;
  const newCoord = {
    lng: mgLng,
    lat: mgLat
  };
  return newCoord;
}
function gcj02_To_gps84(lng, lat) {
  const coord = transform(lng, lat);
  const lontitude = lng * 2 - coord.lng;
  const latitude = lat * 2 - coord.lat;
  const newCoord = {
    lng: lontitude,
    lat: latitude
  };
  return newCoord;
}
function gcj02_To_bd09(x, y) {
  const z = Math.sqrt(x * x + y * y) + 2e-5 * Math.sin(y * x_pi);
  const theta = Math.atan2(y, x) + 3e-6 * Math.cos(x * x_pi);
  const bd_lng = z * Math.cos(theta) + 65e-4;
  const bd_lat = z * Math.sin(theta) + 6e-3;
  const newCoord = {
    lng: bd_lng,
    lat: bd_lat
  };
  return newCoord;
}
function bd09_To_gcj02(bd_lng, bd_lat) {
  const x = bd_lng - 65e-4;
  const y = bd_lat - 6e-3;
  const z = Math.sqrt(x * x + y * y) - 2e-5 * Math.sin(y * x_pi);
  const theta = Math.atan2(y, x) - 3e-6 * Math.cos(x * x_pi);
  const gg_lng = z * Math.cos(theta);
  const gg_lat = z * Math.sin(theta);
  const newCoord = {
    lng: gg_lng,
    lat: gg_lat
  };
  return newCoord;
}
function transform(lng, lat) {
  let dLat = transformLat(lng - 105, lat - 35);
  let dLng = transformLng(lng - 105, lat - 35);
  const radLat = lat / 180 * pi$1;
  let magic = Math.sin(radLat);
  magic = 1 - ee$2 * magic * magic;
  const sqrtMagic = Math.sqrt(magic);
  dLat = dLat * 180 / (a * (1 - ee$2) / (magic * sqrtMagic) * pi$1);
  dLng = dLng * 180 / (a / sqrtMagic * Math.cos(radLat) * pi$1);
  const mgLat = lat + dLat;
  const mgLng = lng + dLng;
  const newCoord = {
    lng: mgLng,
    lat: mgLat
  };
  return newCoord;
}
function transformLat(x, y) {
  let ret = -100 + 2 * x + 3 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
  ret += (20 * Math.sin(6 * x * pi$1) + 20 * Math.sin(2 * x * pi$1)) * 2 / 3;
  ret += (20 * Math.sin(y * pi$1) + 40 * Math.sin(y / 3 * pi$1)) * 2 / 3;
  ret += (160 * Math.sin(y / 12 * pi$1) + 320 * Math.sin(y * pi$1 / 30)) * 2 / 3;
  return ret;
}
function transformLng(x, y) {
  let ret = 300 + x + 2 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
  ret += (20 * Math.sin(6 * x * pi$1) + 20 * Math.sin(2 * x * pi$1)) * 2 / 3;
  ret += (20 * Math.sin(x * pi$1) + 40 * Math.sin(x / 3 * pi$1)) * 2 / 3;
  ret += (150 * Math.sin(x / 12 * pi$1) + 300 * Math.sin(x / 30 * pi$1)) * 2 / 3;
  return ret;
}

const commonProps = {
  visible: {
    type: Boolean,
    default: true
  },
  zIndex: {
    type: Number
  },
  reEventWhenUpdate: {
    type: Boolean,
    default: false
  },
  extraOptions: {
    type: Object
  }
};
const buildProps = (props) => {
  return Object.assign({}, commonProps, props);
};

var registerComponent = defineComponent({
  inject: {
    parentInstance: {
      default: null
    }
  },
  inheritAttrs: false,
  props: {
    visible: {
      type: Boolean,
      default: true
    },
    // 是否显示，默认 true
    zIndex: {
      type: Number
    },
    reEventWhenUpdate: {
      type: Boolean,
      default: false
    },
    // 是否在组件更新时重新注册事件，主要用于数组更新时，绑定了事件但事件的对象不会更新问题
    extraOptions: {
      type: Object
    }
    // 额外扩展属性
  },
  emits: ["init"],
  data() {
    return {
      needInitComponents: [],
      unwatchFns: [],
      propsRedirect: {},
      converters: {},
      isDestroy: false,
      cacheEvents: {},
      isMounted: false
    };
  },
  created() {
    this.$amapComponent = null;
    this.$parentComponent = null;
  },
  mounted() {
    if (this.parentInstance) {
      if (this.parentInstance.$amapComponent) {
        this.register();
      } else {
        this.parentInstance.addChildComponent(this.register);
      }
    }
  },
  beforeUnmount() {
    if (!this.$amapComponent)
      return;
    this.unregisterEvents();
    this.unwatchFns.forEach((item) => item());
    this.unwatchFns = [];
    this.destroyComponent();
    this.isDestroy = true;
  },
  beforeUpdate() {
    if (this.reEventWhenUpdate && this.isMounted && this.$amapComponent) {
      this.unregisterEvents();
    }
  },
  updated() {
    if (this.reEventWhenUpdate && this.isMounted && this.$amapComponent) {
      this.registerEvents();
    }
  },
  methods: {
    getHandlerFun(prop) {
      if (this[`__${prop}`]) {
        return this[`__${prop}`];
      }
      if (!this.$amapComponent) {
        return null;
      }
      return this.$amapComponent[`set${upperCamelCase(prop)}`];
    },
    convertProps() {
      const props = {};
      const { $props, propsRedirect } = this;
      if (this.extraOptions) {
        Object.assign(props, this.extraOptions);
      }
      const result = Object.keys($props).reduce((res, _key) => {
        let key = _key;
        const propsValue = this.convertSignalProp(key, $props[key]);
        if (propsValue === void 0)
          return res;
        if (propsRedirect && propsRedirect[_key])
          key = propsRedirect[key];
        props[key] = propsValue;
        return res;
      }, props);
      Object.keys(result).forEach((key) => {
        result[key] = this.convertProxyToRaw(result[key]);
      });
      return result;
    },
    convertProxyToRaw(value) {
      if (isProxy(value)) {
        return toRaw(value);
      }
      return unref(value);
    },
    convertSignalProp(key, sourceData) {
      if (this.converters && this.converters[key]) {
        return this.converters[key].call(this, sourceData);
      }
      return sourceData;
    },
    registerEvents() {
      const $props = this.$attrs;
      Object.keys($props).forEach((key) => {
        if (eventReg.test(key)) {
          const eventKey = convertEventToLowerCase(key);
          bindInstanceEvent(this.$amapComponent, eventKey, $props[key]);
          this.cacheEvents[eventKey] = $props[key];
        }
      });
    },
    unregisterEvents() {
      Object.keys(this.cacheEvents).forEach((eventKey) => {
        removeInstanceEvent(this.$amapComponent, eventKey, this.cacheEvents[eventKey]);
        delete this.cacheEvents[eventKey];
      });
    },
    setPropWatchers() {
      const { propsRedirect, $props } = this;
      Object.keys($props).forEach((prop) => {
        let handleProp = prop;
        if (propsRedirect && propsRedirect[prop])
          handleProp = propsRedirect[prop];
        const handleFun = this.getHandlerFun(handleProp);
        if (!handleFun)
          return;
        const watchOptions = {
          deep: false
        };
        const propValueType = Object.prototype.toString.call($props[prop]);
        if (propValueType === "[object Object]" || propValueType === "[object Array]") {
          watchOptions.deep = true;
        }
        const unwatch = this.$watch(prop, (nv) => {
          handleFun.call(this.$amapComponent, this.convertProxyToRaw(this.convertSignalProp(prop, nv)));
        }, watchOptions);
        this.unwatchFns.push(unwatch);
      });
    },
    // some prop can not init by initial created methods
    initProps() {
      const props = ["editable", "visible", "zooms"];
      props.forEach((propStr) => {
        if (this[propStr] !== void 0) {
          const handleFun = this.getHandlerFun(propStr);
          handleFun && handleFun.call(this.$amapComponent, this.convertProxyToRaw(this.convertSignalProp(propStr, this[propStr])));
        }
      });
    },
    lazyRegister() {
      const $parent = this.parentInstance;
      if ($parent && $parent.addChildComponent) {
        $parent.addChildComponent(this);
      }
    },
    addChildComponent(component) {
      this.needInitComponents.push(component);
    },
    createChildren() {
      while (this.needInitComponents.length > 0) {
        this.needInitComponents[0]();
        this.needInitComponents.splice(0, 1);
      }
    },
    register() {
      if (this.parentInstance && !this.$parentComponent) {
        this.$parentComponent = this.parentInstance.$amapComponent;
      }
      const res = this["__initComponent"] && this["__initComponent"](this.convertProps());
      if (res && res.then)
        res.then((instance) => this.registerRest(instance));
      else
        this.registerRest(res);
    },
    registerRest(instance) {
      if (!this.$amapComponent && instance)
        this.$amapComponent = instance;
      this.registerEvents();
      this.initProps();
      this.setPropWatchers();
      this.$emit("init", this.$amapComponent, this);
      this.$nextTick(() => {
        this.createChildren();
      });
      this.isMounted = true;
    },
    // helper method
    $$getInstance() {
      return this.$amapComponent;
    },
    destroyComponent() {
      this.$amapComponent.setMap && this.$amapComponent.setMap(null);
      this.$amapComponent.close && this.$amapComponent.close();
      this.$amapComponent.editor && this.$amapComponent.editor.close();
    },
    __visible(flag) {
      if (!!this.$amapComponent && !!this.$amapComponent.show && !!this.$amapComponent.hide) {
        flag === false ? this.$amapComponent.hide() : this.$amapComponent.show();
      }
    },
    __zIndex(value) {
      if (this.$amapComponent && this.$amapComponent.setzIndex) {
        this.$amapComponent.setzIndex(value);
      }
    }
  }
});

const provideKey = "parentInstance";
const useRegister = (_init, params) => {
  let componentInstance = getCurrentInstance();
  let { props, attrs } = componentInstance;
  let parentInstance = inject(provideKey, void 0);
  const emits = params.emits;
  let isMounted = false;
  let $amapComponent;
  onMounted(() => {
    if (parentInstance) {
      if (parentInstance.$amapComponent) {
        register();
      } else {
        parentInstance.addChildComponent(register);
      }
    } else if (params.isRoot) {
      register();
    }
  });
  onBeforeUnmount(() => {
    if (!$amapComponent) {
      return;
    }
    unregisterEvents();
    stopWatchers();
    if (params.destroyComponent) {
      params.destroyComponent();
    } else {
      destroyComponent();
    }
    if (params.provideData) {
      params.provideData.isDestroy = true;
    }
    parentInstance = void 0;
    props = void 0;
    attrs = void 0;
    componentInstance = void 0;
    $amapComponent = void 0;
  });
  onBeforeUpdate(() => {
    if (props.reEventWhenUpdate && isMounted && $amapComponent) {
      unregisterEvents();
    }
  });
  onUpdated(() => {
    if (props.reEventWhenUpdate && isMounted && $amapComponent) {
      registerEvents();
    }
  });
  const register = () => {
    const options = convertProps();
    _init(options, parentInstance == null ? void 0 : parentInstance.$amapComponent).then((mapInstance) => {
      $amapComponent = mapInstance;
      registerEvents();
      initProps();
      setPropWatchers();
      Object.assign(componentInstance.ctx, componentInstance.exposed);
      emits("init", $amapComponent, componentInstance.ctx);
      nextTick(() => {
        createChildren();
      }).then();
      isMounted = true;
    });
  };
  const initProps = () => {
    const propsList = ["editable", "visible", "zooms"];
    propsList.forEach((propStr) => {
      if (props[propStr] !== void 0) {
        const handleFun = getHandlerFun(propStr);
        handleFun && handleFun.call($amapComponent, convertProxyToRaw(convertSignalProp(propStr, props[propStr])));
      }
    });
  };
  const propsRedirect = params.propsRedirect || {};
  const convertProps = () => {
    const propsCache = {};
    if (props.extraOptions) {
      Object.assign(propsCache, props.extraOptions);
    }
    Object.keys(props).forEach((_key) => {
      let key = _key;
      const propsValue = convertSignalProp(key, props[key]);
      if (propsValue !== void 0) {
        if (propsRedirect && propsRedirect[_key]) {
          key = propsRedirect[key];
        }
        propsCache[key] = propsValue;
      }
    });
    return propsCache;
  };
  const converters = params.converts || {};
  const convertSignalProp = (key, sourceData) => {
    if (converters && converters[key]) {
      return converters[key].call(void 0, sourceData);
    }
    return sourceData;
  };
  const convertProxyToRaw = (value) => {
    if (isProxy(value)) {
      return toRaw(value);
    }
    return unref(value);
  };
  let unwatchFns = [];
  let watchRedirectFn = Object.assign({
    __visible: (flag) => {
      if (!!$amapComponent && !!$amapComponent["show"] && !!$amapComponent["hide"]) {
        !flag ? $amapComponent["hide"]() : $amapComponent["show"]();
      }
    },
    __zIndex(value) {
      if ($amapComponent && $amapComponent["setzIndex"]) {
        $amapComponent["setzIndex"](value);
      }
    }
  }, params.watchRedirectFn || {});
  const setPropWatchers = () => {
    Object.keys(props).forEach((prop) => {
      let handleProp = prop;
      if (propsRedirect && propsRedirect[prop])
        handleProp = propsRedirect[prop];
      const handleFun = getHandlerFun(handleProp);
      if (!handleFun)
        return;
      const watchOptions = {
        deep: false
      };
      const propValueType = Object.prototype.toString.call(props[prop]);
      if (propValueType === "[object Object]" || propValueType === "[object Array]") {
        watchOptions.deep = true;
      }
      const unwatch = watch(() => props[prop], (nv) => {
        handleFun.call($amapComponent, convertProxyToRaw(convertSignalProp(prop, nv)));
      }, watchOptions);
      unwatchFns.push(unwatch);
    });
  };
  const stopWatchers = () => {
    unwatchFns.forEach((fn) => fn());
    unwatchFns = [];
    watchRedirectFn = void 0;
  };
  const getHandlerFun = (prop) => {
    if (watchRedirectFn[`__${prop}`]) {
      return watchRedirectFn[`__${prop}`];
    }
    if (!$amapComponent) {
      return null;
    }
    return $amapComponent[`set${upperCamelCase(prop)}`];
  };
  const cacheEvents = {};
  const registerEvents = () => {
    Object.keys(attrs).forEach((key) => {
      if (eventReg.test(key)) {
        const eventKey = convertEventToLowerCase(key);
        bindInstanceEvent($amapComponent, eventKey, attrs[key]);
        cacheEvents[eventKey] = attrs[key];
      }
    });
  };
  const unregisterEvents = () => {
    Object.keys(cacheEvents).forEach((eventKey) => {
      removeInstanceEvent($amapComponent, eventKey, cacheEvents[eventKey]);
      delete cacheEvents[eventKey];
    });
  };
  const createChildren = () => {
    const needInitComponents = params.needInitComponents || [];
    while (needInitComponents.length > 0) {
      needInitComponents[0]();
      needInitComponents.splice(0, 1);
    }
  };
  const destroyComponent = () => {
    if (!$amapComponent) {
      return;
    }
    $amapComponent.setMap && $amapComponent.setMap(null);
    $amapComponent.close && $amapComponent.close();
    $amapComponent.editor && $amapComponent.editor.close();
  };
  function $$getInstance() {
    return $amapComponent;
  }
  return {
    $$getInstance,
    parentInstance,
    isMounted
  };
};

var d,e=d||(d={});e.notload="notload";e.loading="loading";e.loaded="loaded";e.failed="failed";let g={key:"",AMap:{version:"1.4.15",plugins:[]},AMapUI:{version:"1.1",plugins:[]},Loca:{version:"1.3.2"}},m={AMap:d.notload,AMapUI:d.notload,Loca:d.notload},n={AMap:[],AMapUI:[],Loca:[]},p=[];function q$1(a){"function"==typeof a&&(m.AMap===d.loaded?a(window.AMap):p.push(a));}function r(a){let h=[];a.AMapUI&&h.push(t(a.AMapUI));a.Loca&&h.push(u$1(a.Loca));return Promise.all(h)}
function t(a){return new Promise((h,b)=>{let f=[];if(a.plugins)for(var c=0;c<a.plugins.length;c+=1)-1==g.AMapUI.plugins.indexOf(a.plugins[c])&&f.push(a.plugins[c]);if(m.AMapUI===d.failed)b("\u524d\u6b21\u8bf7\u6c42 AMapUI \u5931\u8d25");else if(m.AMapUI===d.notload){m.AMapUI=d.loading;g.AMapUI.version=a.version||g.AMapUI.version;c=g.AMapUI.version;let k=document.body||document.head,l=document.createElement("script");l.type="text/javascript";l.src=`https://webapi.amap.com/ui/${c}/main.js`;l.onerror=
()=>{m.AMapUI=d.failed;b("\u8bf7\u6c42 AMapUI \u5931\u8d25");};l.onload=()=>{m.AMapUI=d.loaded;if(f.length)window.AMapUI.loadUI(f,function(){for(let a=0,b=f.length;a<b;a++){let b=f[a].split("/").slice(-1)[0];window.AMapUI[b]=arguments[a];}for(h();n.AMapUI.length;)n.AMapUI.splice(0,1)[0]();});else for(h();n.AMapUI.length;)n.AMapUI.splice(0,1)[0]();};k.appendChild(l);}else m.AMapUI===d.loaded?a.version&&a.version!==g.AMapUI.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c AMapUI \u6df7\u7528"):f.length?
window.AMapUI.loadUI(f,function(){for(let a=0,b=f.length;a<b;a++){let b=f[a].split("/").slice(-1)[0];window.AMapUI[b]=arguments[a];}h();}):h():a.version&&a.version!==g.AMapUI.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c AMapUI \u6df7\u7528"):n.AMapUI.push(a=>{a?b(a):f.length?window.AMapUI.loadUI(f,function(){for(let a=0,b=f.length;a<b;a++){let b=f[a].split("/").slice(-1)[0];window.AMapUI[b]=arguments[a];}h();}):h();});})}
function u$1(a){return new Promise((h,b)=>{if(m.Loca===d.failed)b("\u524d\u6b21\u8bf7\u6c42 Loca \u5931\u8d25");else if(m.Loca===d.notload){m.Loca=d.loading;g.Loca.version=a.version||g.Loca.version;let l=g.Loca.version;var f=g.AMap.version.startsWith("2"),c=l.startsWith("2");if(f&&!c||!f&&c)b("JSAPI \u4e0e Loca \u7248\u672c\u4e0d\u5bf9\u5e94\uff01\uff01");else {f=g.key;c=document.body||document.head;var k=document.createElement("script");k.type="text/javascript";k.src=`https://webapi.amap.com/loca?v=${l}&key=${f}`;
k.onerror=()=>{m.Loca=d.failed;b("\u8bf7\u6c42 AMapUI \u5931\u8d25");};k.onload=()=>{m.Loca=d.loaded;for(h();n.Loca.length;)n.Loca.splice(0,1)[0]();};c.appendChild(k);}}else m.Loca===d.loaded?a.version&&a.version!==g.Loca.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c Loca \u6df7\u7528"):h():a.version&&a.version!==g.Loca.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c Loca \u6df7\u7528"):n.Loca.push(a=>{a?b(a):b();});})}
var AMapLoader = {load:function(a){if("undefined"===typeof window)throw Error("AMap JSAPI can only be used in Browser.");return new Promise((h,b)=>{if(m.AMap==d.failed)b("");else if(m.AMap==d.notload){let {key:l,version:k,plugins:v}=a;if(l){window.AMap&&"lbs.amap.com"!==location.host&&b("\u7981\u6b62\u591a\u79cdAPI\u52a0\u8f7d\u65b9\u5f0f\u6df7\u7528");g.key=l;g.AMap.version=k||g.AMap.version;g.AMap.plugins=v||g.AMap.plugins;m.AMap=d.loading;var f=document.body||document.head;window.___onAPILoaded=function(c){delete window.___onAPILoaded;
if(c)m.AMap=d.failed,b(c);else for(m.AMap=d.loaded,r(a).then(()=>{h(window.AMap);}).catch(b);p.length;)p.splice(0,1)[0]();};var c=document.createElement("script");c.type="text/javascript";c.src="https://webapi.amap.com/maps?callback=___onAPILoaded&v="+g.AMap.version+"&key="+l+"&plugin="+g.AMap.plugins.join(",");c.onerror=a=>{m.AMap=d.failed;b(a);};f.appendChild(c);}else b("\u8bf7\u586b\u5199key");}else if(m.AMap==d.loaded)if(a.key&&a.key!==g.key)b("\u591a\u4e2a\u4e0d\u4e00\u81f4\u7684 key");else if(a.version&&
a.version!==g.AMap.version)b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c JSAPI \u6df7\u7528");else {f=[];if(a.plugins)for(c=0;c<a.plugins.length;c+=1)-1==g.AMap.plugins.indexOf(a.plugins[c])&&f.push(a.plugins[c]);f.length?window.AMap.plugin(f,()=>{r(a).then(()=>{h(window.AMap);}).catch(b);}):r(a).then(()=>{h(window.AMap);}).catch(b);}else if(a.key&&a.key!==g.key)b("\u591a\u4e2a\u4e0d\u4e00\u81f4\u7684 key");else if(a.version&&a.version!==g.AMap.version)b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c JSAPI \u6df7\u7528");
else {var k=[];if(a.plugins)for(c=0;c<a.plugins.length;c+=1)-1==g.AMap.plugins.indexOf(a.plugins[c])&&k.push(a.plugins[c]);q$1(()=>{k.length?window.AMap.plugin(k,()=>{r(a).then(()=>{h(window.AMap);}).catch(b);}):r(a).then(()=>{h(window.AMap);}).catch(b);});}})},reset:function(){delete window.AMap;delete window.AMapUI;delete window.Loca;g={key:"",AMap:{version:"1.4.15",plugins:[]},AMapUI:{version:"1.1",plugins:[]},Loca:{version:"1.3.2"}};m={AMap:d.notload,AMapUI:d.notload,Loca:d.notload};n={AMap:[],AMapUI:[],
Loca:[]};}};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$a.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$9.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$8 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$1;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$5.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$1.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

const DEFAULT_AMP_CONFIG = {
  "key": "",
  // 申请好的Web端开发者Key，首次调用 load 时必填
  "version": "2.0",
  // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15
  "plugins": [],
  // 需要使用的的插件列表，如比例尺'AMap.Scale'等
  // 'Loca': { // 是否加载 Loca， 缺省不加载
  //   'version': '2.0.0' // Loca 版本，缺省 1.3.2
  // },
  serviceHost: "",
  securityJsCode: ""
};
function AMapAPILoader(config = {}) {
  config = merge({}, DEFAULT_AMP_CONFIG, config);
  if (config.serviceHost) {
    window._AMapSecurityConfig = {
      serviceHost: config.serviceHost
    };
  } else if (config.securityJsCode) {
    window._AMapSecurityConfig = {
      securityJsCode: config.securityJsCode
    };
  }
  return AMapLoader.load(config);
}
const resetJsApi = AMapLoader.reset;

let lazyAMapApiLoaderInstance = null;
const initAMapApiLoader = (config) => {
  if (lazyAMapApiLoaderInstance)
    return;
  if (!lazyAMapApiLoaderInstance) {
    if (config.offline) {
      lazyAMapApiLoaderInstance = new Promise((resolve) => {
        console.log("@vuemap/vue-amap\u79BB\u7EBF\u90E8\u7F72");
        resolve(window.AMap);
      });
    } else {
      lazyAMapApiLoaderInstance = AMapAPILoader(config);
    }
  }
  lazyAMapApiLoaderInstance.then();
};

const propsType$2 = buildProps({
  vid: {
    type: String
  },
  // 地图ID
  center: {
    type: Array
  },
  // 初始中心经纬度
  zoom: {
    type: Number
  },
  // 地图显示的缩放级别，可以设置为浮点数；若center与level未赋值，地图初始化默认显示用户所在城市范围。
  rotation: {
    type: Number
  },
  // 地图顺时针旋转角度，取值范围 [0-360] ，默认值：0
  pitch: {
    type: Number
  },
  // 俯仰角度，默认 0，最大值根据地图当前 zoom 级别不断增大，2D地图下无效 。
  viewMode: {
    type: String
  },
  // 地图视图模式, 默认为‘2D’，可选’3D’，选择‘3D’会显示 3D 地图效果。
  features: {
    type: Array
  },
  // 设置地图上显示的元素种类, 支持'bg'（地图背景）、'point'（POI点）、'road'（道路）、'building'（建筑物），默认值：['bg','point','road','building']
  layers: {
    type: Array
  },
  // 地图图层数组，数组可以是图层 中的一个或多个，默认为普通二维地图。 当叠加多个 图层 时，普通二维地图需通过实例化一个TileLayer类实现。 如果你希望创建一个默认底图图层，使用 AMap.createDefaultLayer()
  zooms: {
    type: Array
  },
  // 图显示的缩放级别范围, 默认为 [2, 20] ，取值范围 [2 ~ 30]
  resizeEnable: {
    type: Boolean,
    default: true
  },
  // 是否监控地图容器尺寸变化，默认值为false。此属性可被 setStatus/getStatus 方法控制
  dragEnable: {
    type: Boolean,
    default: true
  },
  // 地图是否可通过鼠标拖拽平移, 默认为 true。此属性可被 setStatus/getStatus 方法控制
  zoomEnable: {
    type: Boolean,
    default: true
  },
  // 地图是否可缩放，默认值为 true。此属性可被 setStatus/getStatus 方法控制
  jogEnable: {
    type: Boolean,
    default: true
  },
  // 地图是否使用缓动效果，默认值为true。此属性可被setStatus/getStatus 方法控制
  pitchEnable: {
    type: Boolean,
    default: true
  },
  // 是否允许设置俯仰角度, 3D 视图下为 true, 2D 视图下无效。。此属性可被setStatus/getStatus 方法控制
  rotateEnable: {
    type: Boolean,
    default: true
  },
  // 地图是否可旋转, 图默认为true。此属性可被setStatus/getStatus 方法控制
  animateEnable: {
    type: Boolean,
    default: true
  },
  // 地图平移过程中是否使用动画（如调用panBy、panTo、setCenter、setZoomAndCenter等函数, 将对地图产生平移操作, 是否使用动画平移的效果）, 默认为true, 即使用动画
  keyboardEnable: {
    type: Boolean,
    default: true
  },
  // 地图是否可通过键盘控制, 默认为true, 方向键控制地图平移，"+"和"-"可以控制地图的缩放, Ctrl+“→”顺时针旋转，Ctrl+“←”逆时针旋转。此属性可被setStatus/getStatus 方法控制
  doubleClickZoom: {
    type: Boolean,
    default: true
  },
  // 地图是否可通过双击鼠标放大地图, 默认为true。此属性可被setStatus/getStatus 方法控制
  scrollWheel: {
    type: Boolean,
    default: true
  },
  // 地图是否可通过鼠标滚轮缩放浏览，默认为true。此属性可被setStatus/getStatus 方法控制
  touchZoom: {
    type: Boolean,
    default: true
  },
  // 地图在移动终端上是否可通过多点触控缩放浏览地图，默认为true。关闭手势缩放地图，请设置为false。
  touchZoomCenter: {
    type: Number
  },
  // 可缺省，当touchZoomCenter=1的时候，手机端双指缩放的以地图中心为中心，否则默认以双指中间点为中心。默认：1
  showLabel: {
    type: Boolean,
    default: true
  },
  // 是否展示地图文字和 POI 信息。默认 true
  defaultCursor: {
    type: String
  },
  // 地图默认鼠标样式。参数 defaultCursor 应符合 CSS 的 cursor 属性规范。
  isHotspot: {
    type: Boolean
  },
  // 是否开启地图热点和标注的 hover 效果。PC端默认是true, 移动端默认是 false。
  mapStyle: {
    type: String
  },
  // 设置地图的显示样式，目前支持两种地图样式： 第一种：自定义地图样式，如 "amap://styles/d6bf8c1d69cea9f5c696185ad4ac4c86" 可前往地图自定义平台定制自己的个性地图样式； 第二种：官方样式模版,如"amap://styles/grey"。 其他模版样式及自定义地图的使用说明见开发指南
  wallColor: {
    type: [String, Array]
  },
  // 地图楼块的侧面颜色
  roofColor: {
    type: [String, Array]
  },
  // 地图楼块的顶面颜色
  showBuildingBlock: {
    type: Boolean,
    default: true
  },
  // 是否展示地图 3D 楼块，默认 true
  showIndoorMap: {
    type: Boolean,
    default: false
  },
  // 是否自动展示室内地图，默认是 false
  skyColor: {
    type: [String, Array]
  },
  // 天空颜色，3D 模式下带有俯仰角时会显示
  labelRejectMask: {
    type: Boolean,
    default: false
  },
  // 文字是否拒绝掩模图层进行掩模
  mask: {
    type: Array
  },
  // 为 Map 实例指定掩模的路径，各图层将只显示路径范围内图像，3D视图下有效。 格式为一个经纬度的一维、二维或三维数组。
  WebGLParams: {
    type: Object
  },
  // 额外配置的WebGL参数 eg: preserveDrawingBuffer
  terrain: {
    type: Boolean,
    default: false
  }
  //是否开启地形，默认不开启
});

const _hoisted_1$3 = { class: "el-vue-amap-container" };
const _hoisted_2$1 = ["id"];
var script$K = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmap",
    inheritAttrs: false
  },
  __name: "amap",
  props: propsType$2,
  emits: ["init", "update:zoom", "update:center", "update:rotation", "update:pitch"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const needInitComponents = [];
    const provideData = {
      $amapComponent: void 0,
      addChildComponent(cb) {
        needInitComponents.push(cb);
      },
      isDestroy: false
    };
    provide(provideKey, provideData);
    const props = __props;
    const emits = __emit;
    const mapDomId = ref(props.vid || guid());
    let $amapComponent;
    const { $$getInstance } = useRegister((options) => {
      return new Promise((resolve, reject) => {
        if (!lazyAMapApiLoaderInstance) {
          reject(new Error("\u8BF7\u521D\u59CB\u5316initAMapApiLoader"));
          return;
        }
        lazyAMapApiLoaderInstance.then(() => {
          nextTick(() => {
            $amapComponent = new AMap.Map(mapDomId.value, options);
            provideData.$amapComponent = $amapComponent;
            bindModelEvents();
            resolve($amapComponent);
          });
        }).catch((e) => {
          reject(e);
        });
      });
    }, {
      isRoot: true,
      emits,
      needInitComponents,
      provideData,
      watchRedirectFn: {
        __dragEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ dragEnable: flag });
          }
        },
        __zoomEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ zoomEnable: flag });
          }
        },
        __jogEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ jogEnable: flag });
          }
        },
        __keyboardEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ keyboardEnable: flag });
          }
        },
        __doubleClickZoom(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ doubleClickZoom: flag });
          }
        },
        __scrollWheel(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ scrollWheel: flag });
          }
        },
        __rotateEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ rotateEnable: flag });
          }
        },
        __pitchEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ pitchEnable: flag });
          }
        },
        __resizeEnable(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ resizeEnable: flag });
          }
        },
        __showIndoorMap(flag) {
          if ($amapComponent) {
            $amapComponent.setStatus({ showIndoorMap: flag });
          }
        }
      }
    });
    const bindModelEvents = () => {
      $amapComponent.on("zoomchange", () => {
        emits("update:zoom", $amapComponent.getZoom());
      });
      $amapComponent.on("rotateend", () => {
        emits("update:rotation", $amapComponent.getRotation());
      });
      $amapComponent.on("dragging", () => {
        emits("update:center", getCenter());
      });
      $amapComponent.on("dragend", () => {
        emits("update:pitch", $amapComponent.getPitch());
      });
      $amapComponent.on("touchmove", () => {
        emits("update:center", getCenter());
      });
    };
    const getCenter = () => {
      const center = $amapComponent.getCenter();
      return [center.lng, center.lat];
    };
    onBeforeUnmount(() => {
      if ($amapComponent) {
        $amapComponent.clearEvents();
        $amapComponent.destroy();
        $amapComponent = null;
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createElementVNode("div", {
          id: mapDomId.value,
          class: "el-vue-amap"
        }, null, 8, _hoisted_2$1),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

script$K.__file = "src/vue-amap/packages/amap/amap.vue";

script$K.install = (app) => {
  app.component(script$K.name, script$K);
  return app;
};
const ElAmap = script$K;

var script$J = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapControlControlBar",
    inheritAttrs: false
  },
  __name: "ControlBar",
  props: buildProps({
    // 控件停靠位置 { top: 5; left: 5; right: 5; bottom: 5 } 或者 'LT': 左上角, 'RT': 右上角, 'LB': 左下角, 'RB': 右下角
    position: {
      type: [String, Object]
    },
    // 相对于地图容器左上角的偏移量，正数代表向右下偏移。默认为AMap.Pixel(10,10)
    offset: {
      type: Array
    },
    // 是否显示倾斜、旋转按钮。默认为 true
    showControlButton: {
      type: Boolean,
      default: true
    }
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.ControlBar"], () => {
          $amapComponent = new AMap.ControlBar(options);
          parentComponent.addControl($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeControl($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$J.__file = "src/vue-amap/packages/control/ControlBar/ControlBar.vue";

script$J.install = (app) => {
  app.component(script$J.name, script$J);
  return app;
};
const ElAmapControlControlBar = script$J;

const propsTypes$a = buildProps({
  autoMove: {
    type: Boolean,
    default: true
  },
  // 是否随主图视口变化移动
  showRectangle: {
    type: Boolean,
    default: true
  },
  // 是否显示视口矩形
  showButton: {
    type: Boolean,
    default: true
  },
  // 是否显示打开关闭的按钮
  isOpen: {
    type: Boolean,
    default: true
  },
  // 默认是否展开
  mapStyle: {
    type: String
  },
  // 缩略图要显示的地图自定义样式，如'amap://styles/dark'
  layers: {
    type: Array
  },
  // 缩略图要显示的图层类型，默认为普通矢量地图
  width: {
    type: String
  },
  // 缩略图的宽度，同CSS，如'200px'
  height: {
    type: String
  },
  // 缩略图的高度，同CSS，如'200px'
  offset: {
    type: Array
  },
  // 缩略图距离地图右下角的像素距离，如 [2,2]
  borderStyle: {
    type: String
  },
  // 缩略图的边框样式，同CSS，如"double solid solid double"
  borderColor: {
    type: String
  },
  // 缩略图的边框颜色，同CSS，如'silver'
  borderRadius: {
    type: String
  },
  // 缩略图的边框角度，同CSS，如'5px'
  borderWidth: {
    type: String
  },
  // 缩略图的边框宽度，同CSS，如'2px'
  buttonSize: {
    type: String
  }
  // 箭头按钮的像素尺寸，同CSS，如'12px'
});

var script$I = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapControlHawkEye",
    inheritAttrs: false
  },
  __name: "HawkEye",
  props: propsTypes$a,
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.HawkEye"], () => {
          $amapComponent = new AMap.HawkEye(options);
          parentComponent.addControl($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      watchRedirectFn: {
        __isOpen(flag) {
          !flag ? $amapComponent.close() : $amapComponent.open();
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeControl($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return null;
    };
  }
});

script$I.__file = "src/vue-amap/packages/control/HawkEye/HawkEye.vue";

script$I.install = (app) => {
  app.component(script$I.name, script$I);
  return app;
};
const ElAmapControlHawkEye = script$I;

var script$H = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapControlMapType",
    inheritAttrs: false
  },
  __name: "MapType",
  props: buildProps({
    defaultType: {
      type: Number
    },
    // 初始化默认图层类型。 取值为0：默认底图 取值为1：卫星图 默认值：0
    showTraffic: {
      type: Boolean,
      default: false
    },
    // 叠加实时交通图层 默认值：false
    showRoad: {
      type: Boolean,
      default: false
    }
    // 叠加路网图层 默认值：false
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.MapType"], () => {
          $amapComponent = new AMap.MapType(options);
          parentComponent.addControl($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeControl($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$H.__file = "src/vue-amap/packages/control/MapType/MapType.vue";

script$H.install = (app) => {
  app.component(script$H.name, script$H);
  return app;
};
const ElAmapControlMapType = script$H;

var script$G = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapControlScale",
    inheritAttrs: false
  },
  __name: "Scale",
  props: buildProps({
    position: {
      type: [String, Object]
    },
    // 控件停靠位置 { top: 5; left: 5; right: 5; bottom: 5 } 或者 'LT': 左上角, 'RT': 右上角, 'LB': 左下角, 'RB': 右下角
    offset: {
      type: Array
    }
    // 相对于地图容器左上角的偏移量，正数代表向右下偏移。默认为AMap.Pixel(10,10)
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.Scale"], () => {
          $amapComponent = new AMap.Scale(options);
          parentComponent.addControl($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeControl($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$G.__file = "src/vue-amap/packages/control/Scale/Scale.vue";

script$G.install = (app) => {
  app.component(script$G.name, script$G);
  return app;
};
const ElAmapControlScale = script$G;

var script$F = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapControlToolBar",
    inheritAttrs: false
  },
  __name: "ToolBar",
  props: buildProps({
    position: {
      type: [String, Object]
    },
    // 控件停靠位置 { top: 5; left: 5; right: 5; bottom: 5 } 或者 'LT': 左上角, 'RT': 右上角, 'LB': 左下角, 'RB': 右下角
    offset: {
      type: Array
    }
    // 相对于地图容器左上角的偏移量，正数代表向右下偏移。默认为AMap.Pixel(10,10)
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.ToolBar"], () => {
          $amapComponent = new AMap.ToolBar(options);
          parentComponent.addControl($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeControl($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$F.__file = "src/vue-amap/packages/control/ToolBar/ToolBar.vue";

script$F.install = (app) => {
  app.component(script$F.name, script$F);
  return app;
};
const ElAmapControlToolBar = script$F;

const propsTypes$9 = buildProps({
  type: {
    type: String
  },
  //输入提示时限定POI类型，多个类型用“|”分隔，目前只支持Poi类型编码如“050000” 默认值：所有类别
  city: {
    type: String
  },
  //输入提示时限定城市。可选值：城市名（中文或中文全拼）、citycode、adcode；默认值：“全国”
  datatype: {
    type: String
  },
  //返回的数据类型。可选值：all-返回所有数据类型、poi-返回POI数据类型、bus-返回公交站点数据类型、busline-返回公交线路数据类型目前暂时不支持多种类型
  citylimit: {
    type: Boolean,
    default: false
  },
  //返回的数据类型。可选值：all-返回所有数据类型、poi-返回POI数据类型、bus-返回公交站点数据类型、busline-返回公交线路数据类型目前暂时不支持多种类型
  inputId: {
    type: String
  },
  //输入框的ID
  inputCustom: {
    type: Boolean,
    default: false
  },
  //是否自定义input，自定义的时候将使用用户的inputId
  outputId: {
    type: String
  },
  //可选参数，指定一个现有的div的id或者元素，作为展示提示结果的容器，当指定了input的时候有效，缺省的时候将自动创建一个显示结果面板
  outPutDirAuto: {
    type: Boolean,
    default: true
  },
  //默认为true，表示是否在input位于页面较下方的时候自动将输入面板显示在input上方以避免被遮挡
  closeResultOnScroll: {
    type: Boolean,
    default: true
  },
  //页面滚动时关闭搜索结果列表，默认 true
  lang: {
    type: String
  },
  //设置检索语言类型，默认中文 'zh_cn'
  placeholder: {
    type: String
  },
  debounce: {
    type: Number,
    default: 100
  }
  // 手动复写增加防抖
});

const _hoisted_1$2 = { class: "el-vue-search-box-container" };
const _hoisted_2 = ["id", "placeholder"];
var script$E = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapSearchBox",
    inheritAttrs: false
  },
  __name: "SearchBox",
  props: propsTypes$9,
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const saveInputId = ref(guid());
    const saveVisible = ref(true);
    let $amapComponent;
    let preInput;
    const { $$getInstance } = useRegister((options, parentComponent) => {
      if (options.inputId) {
        saveInputId.value = options.inputId;
        delete options.inputId;
      }
      if (options.visible) {
        saveVisible.value = options.visible;
      }
      options.input = saveInputId.value;
      if (options.outputId) {
        options.output = options.outputId;
        delete options.outputId;
      }
      let _inputTimer;
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.AutoComplete"], () => {
          const debounce = props.debounce;
          preInput = AMap.Autocomplete.prototype.onInPut;
          AMap.Autocomplete.prototype.onInPut = function() {
            clearTimeout(_inputTimer);
            _inputTimer = setTimeout(() => {
              this.output && this.autoSearch();
            }, debounce);
          };
          $amapComponent = new AMap.AutoComplete(options);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      watchRedirectFn: {
        __visible(flag) {
          saveVisible.value = flag;
        },
        __citylimit(flag) {
          $amapComponent.setCityLimit(flag);
        }
      },
      destroyComponent() {
        if (preInput && AMap.Autocomplete) {
          AMap.Autocomplete.prototype.onInPut = preInput;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock(
        "div",
        _hoisted_1$2,
        [
          !_ctx.inputCustom ? (openBlock(), createElementBlock("input", {
            key: 0,
            id: saveInputId.value,
            type: "text",
            placeholder: _ctx.placeholder
          }, null, 8, _hoisted_2)) : createCommentVNode("v-if", true)
        ],
        512
        /* NEED_PATCH */
      )), [
        [vShow, _ctx.visible && !_ctx.inputCustom]
      ]);
    };
  }
});

script$E.__file = "src/vue-amap/packages/control/SearchBox/SearchBox.vue";

script$E.install = (app) => {
  app.component(script$E.name, script$E);
  return app;
};
const ElAmapSearchBox = script$E;

const propsTypes$8 = buildProps({
  isCustom: {
    type: Boolean,
    default: false
  },
  // 是否自定义窗体。设为true时，信息窗体外框及内容完全按照content所设的值添加（默认为false，即在系统默认的信息窗体外框中显示content内容）
  autoMove: {
    type: Boolean,
    default: true
  },
  // 是否自动调整窗体到视野内（当信息窗体超出视野范围时，通过该属性设置是否自动平移地图，使信息窗体完全显示）
  avoid: {
    type: Array
  },
  // autoMove 为 true 时，自动平移到视野内后的上右下左的避让宽度。默认值： [20, 20, 20, 20]
  closeWhenClickMap: {
    type: Boolean,
    default: false
  },
  // 点标记显示位置偏移量，默认值为 [0,0] 。Marker指定position后，默认以marker左上角位置为基准点（若设置了anchor，则以anchor设置位置为基准点），对准所给定的position位置，若需使marker指定位置对准在position处，需根据marker的尺寸设置一定的偏移量。
  content: {
    type: Object
  },
  // 显示内容，可以是HTML要素字符串或者HTMLElement对象
  size: {
    type: Array
  },
  // 信息窗体尺寸（isCustom为true时，该属性无效）
  anchor: {
    type: String
  },
  // 信息窗体锚点。默认值：'bottom-center'。可选值：'top-left'|'top-center'|'top-right'|'middle-left'|'center'|'middle-right'|'bottom-left'|'bottom-center'|'bottom-right'
  offset: {
    type: Array
  },
  // 信息窗体显示位置偏移量。默认基准点为信息窗体的底部中心。默认值: [0, 0]
  position: {
    type: Object
  }
  // 信息窗体显示基点位置
});

const _hoisted_1$1 = { style: { "display": "none" } };
var script$D = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapInfoWindow",
    inheritAttrs: false
  },
  __name: "InfoWindow",
  props: propsTypes$8,
  emits: ["init", "update:visible"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const needTeleport = !props.content;
    const tempId = `info-${guid()}`;
    const divId = ref("");
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        if (!options.content) {
          options.content = `<div id="${tempId}"></div>`;
        }
        $amapComponent = new AMap.InfoWindow(options);
        $amapComponent.on("close", () => {
          emits("update:visible", false);
        });
        if (props.visible) {
          $amapComponent.open(parentComponent, props.position);
          if (needTeleport) {
            divId.value = tempId;
          }
        }
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __position(position) {
          if (props.visible) {
            $amapComponent.open(parentInstance == null ? void 0 : parentInstance.$amapComponent, position);
            if (needTeleport) {
              divId.value = tempId;
            }
          } else {
            $amapComponent.setPosition(position);
          }
        },
        __visible(flag) {
          const position = $amapComponent.getPosition();
          if (position) {
            if (!flag) {
              $amapComponent.close();
            } else {
              $amapComponent.open(parentInstance == null ? void 0 : parentInstance.$amapComponent, [position.lng, position.lat]);
              if (needTeleport) {
                divId.value = tempId;
              }
            }
          }
        }
      },
      destroyComponent() {
        if ($amapComponent) {
          if ($amapComponent.getIsOpen()) {
            $amapComponent.close();
          }
          $amapComponent = null;
        }
      }
    });
    onUnmounted(() => {
      if ($amapComponent) {
        $amapComponent.close();
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        !!divId.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "#" + divId.value
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 8, ["to"])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});

script$D.__file = "src/vue-amap/packages/infoWindow/InfoWindow/InfoWindow.vue";

script$D.install = (app) => {
  app.component(script$D.name, script$D);
  return app;
};
const ElAmapInfoWindow = script$D;

var script$C = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerCanvas",
    inheritAttrs: false
  },
  __name: "Canvas",
  props: buildProps({
    canvas: {
      required: true,
      type: Object
    },
    // Canvas DOM 对象
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    bounds: {
      type: [Array, Object]
    },
    // 图片的范围大小经纬度，如果传递数字数组类型: [minlng,minlat,maxlng,maxlat] 或 AMap.Bounds
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.CanvasLayer(options);
        parentComponent.addLayer($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeLayer($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$C.__file = "src/vue-amap/packages/layer/data/Canvas/Canvas.vue";

script$C.install = (app) => {
  app.component(script$C.name, script$C);
  return app;
};
const ElAmapLayerCanvas = script$C;

var script$B = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerCustom",
    inheritAttrs: false
  },
  __name: "Custom",
  props: buildProps({
    canvas: {
      required: true,
      type: Object
    },
    // canvas 对象
    render: {
      type: Function
    },
    // 绘制函数，初始化完成时候，开发者需要给该图层设定render方法，该方法需要实现图层的绘制，API会在合适的时机自动调用该方法
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2, 20]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    alwaysRender: {
      type: Boolean,
      default: false
    }
    // 是否主动
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        const canvas = options.canvas;
        delete options.canvas;
        $amapComponent = new AMap.CustomLayer(canvas, options);
        $amapComponent.setMap(parentComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$B.__file = "src/vue-amap/packages/layer/data/Custom/Custom.vue";

script$B.install = (app) => {
  app.component(script$B.name, script$B);
  return app;
};
const ElAmapLayerCustom = script$B;

var script$A = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerFlexible",
    inheritAttrs: false
  },
  __name: "Flexible",
  props: buildProps({
    cacheSize: {
      type: Number
    },
    // 缓存瓦片数量
    createTile: {
      type: Function
    },
    // 由开发者实现，由API自动调用，xyz分别为切片横向纵向编号和层级，切片大小 256。假设每次创建的贴片为A(支持img或者canvas)，当创建或者获取成功时请回调success(A)，不需要显示或者失败时请回调fail()
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Object
    },
    // 热力图透明度区间数组，取值范围 [0,1] ，0表示完全透明，1表示不透明，默认： [0,1]
    tileSize: {
      type: Number
    }
    // 切片大小，取值： 256  128  64。默认值为256
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer.Flexible(options);
        $amapComponent.setMap(parentComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.destroy();
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$A.__file = "src/vue-amap/packages/layer/data/Flexible/Flexible.vue";

script$A.install = (app) => {
  app.component(script$A.name, script$A);
  return app;
};
const ElAmapLayerFlexible = script$A;

var script$z = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerGlCustom",
    inheritAttrs: false
  },
  __name: "GLCustom",
  props: buildProps({
    init: {
      type: Function
    },
    // 初始化的时候，开发者可以在这个函数参数里面获取 gl 上下文，进行一些初始化的操作。
    render: {
      type: Function
    },
    // 绘制函数，初始化完成时候，开发者需要给该图层设定render方法，该方法需要实现图层的绘制，API会在合适的时机自动调用该方法
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2, 20]
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.GLCustomLayer(options);
        $amapComponent.setMap(parentComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent) {
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$z.__file = "src/vue-amap/packages/layer/data/GLCustom/GLCustom.vue";

script$z.install = (app) => {
  app.component(script$z.name, script$z);
  return app;
};
const ElAmapLayerGlCustom = script$z;

var script$y = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerHeatMap",
    inheritAttrs: false
  },
  __name: "HeatMap",
  props: buildProps({
    radius: {
      type: Number
    },
    // 热力图中单个点的半径，默认：30，单位：pixel
    gradient: {
      type: Object
    },
    // 热力图的渐变区间，热力图按照设置的颜色及间隔显示热力图，例{0.4:'rgb(0, 255, 255)',0.85:'rgb(100, 0, 255)',},其中 key 表示间隔位置，取值范围： [0,1] ，value 为颜色值。默认：heatmap.js标准配色方案
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Object
    },
    // 热力图透明度区间数组，取值范围 [0,1] ，0表示完全透明，1表示不透明，默认： [0,1]
    config: {
      type: Object
    },
    // 3D热力图属性
    dataSet: {
      type: Object
    }
    // 热力图数据集
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.HeatMap"], () => {
          delete options.dataSet;
          $amapComponent = new AMap.HeatMap(parentComponent, options);
          if (props.dataSet) {
            $amapComponent.setDataSet(props.dataSet);
          }
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.setDataSet({
            data: [],
            max: 0
          });
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$y.__file = "src/vue-amap/packages/layer/data/HeatMap/HeatMap.vue";

script$y.install = (app) => {
  app.component(script$y.name, script$y);
  return app;
};
const ElAmapLayerHeatMap = script$y;

var script$x = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerImage",
    inheritAttrs: false
  },
  __name: "Image",
  props: buildProps({
    url: {
      type: String,
      required: true
    },
    // 图片地址链接
    zoom: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    bounds: {
      type: [Array, Object]
    },
    // 图片的范围大小经纬度，如果传递数字数组类型: [minlng,minlat,maxlng,maxlat] 或 AMap.Bounds
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.ImageLayer(options);
        parentComponent.addLayer($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __url(value) {
          $amapComponent.setImageUrl(value);
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeLayer($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$x.__file = "src/vue-amap/packages/layer/data/Image/Image.vue";

script$x.install = (app) => {
  app.component(script$x.name, script$x);
  return app;
};
const ElAmapLayerImage = script$x;

var script$w = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerLabels",
    inheritAttrs: false
  },
  __name: "Labels",
  props: buildProps({
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    collision: {
      type: Boolean,
      default: true
    },
    // 标注层内的标注是否避让
    allowCollision: {
      type: Boolean,
      default: false
    }
    // 标注层内的标注是否允许其它标注层对它避让
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const needInitComponents = [];
    const provideData = {
      $amapComponent: void 0,
      addChildComponent(cb) {
        needInitComponents.push(cb);
      },
      isDestroy: false
    };
    provide(provideKey, provideData);
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.LabelsLayer(options);
        parentComponent.add($amapComponent);
        provideData.$amapComponent = $amapComponent;
        resolve($amapComponent);
      });
    }, {
      emits,
      needInitComponents,
      provideData,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeLayer($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    const $$add = (markers) => {
      $amapComponent.add(markers);
    };
    __expose({
      $$getInstance,
      $$add
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

script$w.__file = "src/vue-amap/packages/layer/data/Labels/Labels.vue";

script$w.install = (app) => {
  app.component(script$w.name, script$w);
  return app;
};
const ElAmapLayerLabels = script$w;

var script$v = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerVector",
    inheritAttrs: false
  },
  __name: "Vector",
  props: buildProps({}),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const needInitComponents = [];
    const provideData = {
      $amapComponent: void 0,
      addChildComponent(cb) {
        needInitComponents.push(cb);
      },
      isDestroy: false
    };
    provide(provideKey, provideData);
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.VectorLayer(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      needInitComponents,
      provideData,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeLayer($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

script$v.__file = "src/vue-amap/packages/layer/data/Vector/Vector.vue";

script$v.install = (app) => {
  app.component(script$v.name, script$v);
  return app;
};
const ElAmapLayerVector = script$v;

var script$u = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerBuildings",
    inheritAttrs: false
  },
  __name: "Buildings",
  props: buildProps({
    wallColor: {
      type: [String, Array]
    },
    // 楼块侧面颜色，支持 rgba、rgb、十六进制等
    roofColor: {
      type: [String, Array]
    },
    // 楼块顶面颜色，支持 rgba、rgb、十六进制等
    heightFactor: {
      type: Number
    },
    // 楼块的高度系数因子，默认为 1，也就是正常高度
    styleOpts: {
      type: Object
    },
    // 楼块的围栏和样式设置
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Buildings(options);
        parentComponent.add($amapComponent);
        if (props.styleOpts) {
          $amapComponent.setStyle(props.styleOpts);
        }
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __styleOpts(value) {
          $amapComponent.setStyle(value);
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$u.__file = "src/vue-amap/packages/layer/official/Buildings/Buildings.vue";

script$u.install = (app) => {
  app.component(script$u.name, script$u);
  return app;
};
const ElAmapLayerBuildings = script$u;

var script$t = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerDefault",
    inheritAttrs: false
  },
  __name: "DefaultLayer",
  props: buildProps({
    zoom: {
      type: Array
    },
    opacity: {
      type: Number
    }
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = AMap.createDefaultLayer(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$t.__file = "src/vue-amap/packages/layer/official/DefaultLayer/DefaultLayer.vue";

script$t.install = (app) => {
  app.component(script$t.name, script$t);
  return app;
};
const ElAmapLayerDefault = script$t;

var script$s = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerDistrict",
    inheritAttrs: false
  },
  __name: "DistrictLayer",
  props: buildProps({
    type: {
      type: String,
      default: "Country",
      validator: (value) => {
        return ["World", "Country", "Province"].indexOf(value) !== -1;
      }
    },
    adcode: {
      type: String
    },
    // 行政区的编码 adcode与省市行政区对照表，下载地址：https://a.amap.com/lbs/static/file/AMap_adcode_citycode.xlsx.zip
    SOC: {
      type: String
    },
    // 设定显示的国家,对应下载地址： https://a.amap.com/jsapi_demos/static/demo-center/js/soc-list.json
    depth: {
      type: Number
    },
    // 设定数据的层级深度，depth为0的时候只显示国家面，depth为1的时候显示省级， 当国家为中国时设置depth为2的可以显示市一级
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    styles: {
      type: Object
    }
    // 为简易行政区图设定各面的填充颜色和描边颜色。 styles各字段的值可以是颜色值，也可以是一个返回颜色值* 的回调函数function。
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        if (props.type === "World") {
          $amapComponent = new AMap.DistrictLayer.World(options);
        } else if (props.type === "Country") {
          $amapComponent = new AMap.DistrictLayer.Country(options);
        } else if (props.type === "Province") {
          $amapComponent = new AMap.DistrictLayer.Province(options);
        }
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __SOC(value) {
          $amapComponent.setSOC(value);
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$s.__file = "src/vue-amap/packages/layer/official/DistrictLayer/DistrictLayer.vue";

script$s.install = (app) => {
  app.component(script$s.name, script$s);
  return app;
};
const ElAmapLayerDistrict = script$s;

var script$r = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerIndoorMap",
    inheritAttrs: false
  },
  __name: "IndoorMap",
  props: buildProps({
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    cursor: {
      type: String
    },
    // 指定鼠标悬停到店铺面时的鼠标样式
    hideFloorBar: {
      type: Boolean,
      default: false
    }
    // 是否隐藏楼层切换控件，默认值：false
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.IndoorMap"], () => {
          $amapComponent = new AMap.IndoorMap(options);
          const layers = parentComponent.getLayers();
          layers.push($amapComponent);
          parentComponent.setLayers(layers);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      watchRedirectFn: {
        __hideFloorBar(flag) {
          !flag ? $amapComponent.hideFloorBar() : $amapComponent.showFloorBar();
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          const layers = parentInstance.$amapComponent.getLayers();
          let index = -1;
          for (let i = 0; i < layers.length; i++) {
            if (isIndoorMapInstance(layers[i])) {
              index = i;
              break;
            }
          }
          if (index > -1) {
            layers.splice(index, 1);
            parentInstance.$amapComponent.setLayers(layers);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$r.__file = "src/vue-amap/packages/layer/official/IndoorMap/IndoorMap.vue";

script$r.install = (app) => {
  app.component(script$r.name, script$r);
  return app;
};
const ElAmapLayerIndoorMap = script$r;

var script$q = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerRoadNet",
    inheritAttrs: false
  },
  __name: "RoadNet",
  props: buildProps({
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    tileSize: {
      type: Number
    }
    // 切片大小，取值： 256，表示切片大小为256 256， 128，表示切片大小为128 128， 64，表示切片大小为64*64。默认值为256
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer.RoadNet(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$q.__file = "src/vue-amap/packages/layer/official/RoadNet/RoadNet.vue";

script$q.install = (app) => {
  app.component(script$q.name, script$q);
  return app;
};
const ElAmapLayerRoadNet = script$q;

var script$p = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerSatellite",
    inheritAttrs: false
  },
  __name: "Satellite",
  props: buildProps({
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    tileSize: {
      type: Number
    }
    // 切片大小，取值： 256，表示切片大小为256 256， 128，表示切片大小为128 128， 64，表示切片大小为64*64。默认值为256
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer.Satellite(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$p.__file = "src/vue-amap/packages/layer/official/Satellite/Satellite.vue";

script$p.install = (app) => {
  app.component(script$p.name, script$p);
  return app;
};
const ElAmapLayerSatellite = script$p;

var script$o = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerTile",
    inheritAttrs: false
  },
  __name: "TileLayer",
  props: buildProps({
    tileUrl: {
      type: String,
      required: true
    },
    // 切片取图地址 如：' https://abc{0,1,2,3}.amap.com/tile?x=[x]&y=[y]&z=[z] ' [x] 、 [y] 、 [z] 分别替代切片的xyz。
    zoom: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    dataZooms: {
      type: Array
    },
    // 数据支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    tileSize: {
      type: Number
    }
    // 切片大小，取值： 256，表示切片大小为256 256， 128，表示切片大小为128 128， 64，表示切片大小为64*64。默认值为256
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$o.__file = "src/vue-amap/packages/layer/official/TileLayer/TileLayer.vue";

script$o.install = (app) => {
  app.component(script$o.name, script$o);
  return app;
};
const ElAmapLayerTile = script$o;

var script$n = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerTraffic",
    inheritAttrs: false
  },
  __name: "Traffic",
  props: buildProps({
    autoRefresh: {
      type: Boolean,
      defult: true
    },
    // 是否自动更新数据，默认开启
    interval: {
      type: Number
    },
    // 自动更新数据的间隔毫秒数，默认 180ms
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    tileSize: {
      type: Number
    }
    // 切片大小，取值： 256，表示切片大小为256 256， 128，表示切片大小为128 128， 64，表示切片大小为64*64。默认值为256
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer.Traffic(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    const stopFresh = () => {
      if ($amapComponent) {
        $amapComponent.stopFresh();
      }
    };
    __expose({
      $$getInstance,
      stopFresh
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$n.__file = "src/vue-amap/packages/layer/official/Traffic/Traffic.vue";

script$n.install = (app) => {
  app.component(script$n.name, script$n);
  return app;
};
const ElAmapLayerTraffic = script$n;

var script$m = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerMapboxVectorTile",
    inheritAttrs: false
  },
  __name: "MapboxVectorTileLayer",
  props: buildProps({
    url: {
      type: String
    },
    // MVT 数据的链接地址
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2,22]
    dataZooms: {
      type: Array
    },
    // 瓦片数据等级范围，超过范围会使用最大/最小等级的数据，默认 [2,18]
    opacity: {
      type: Number
    },
    // 透明度，默认 1
    styles: {
      type: Object
    }
    // 样式
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MapboxVectorTileLayer"], () => {
          $amapComponent = new AMap.MapboxVectorTileLayer(options);
          parentComponent.addLayer($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeLayer($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$m.__file = "src/vue-amap/packages/layer/standard/MapboxVectorTileLayer/MapboxVectorTileLayer.vue";

script$m.install = (app) => {
  app.component(script$m.name, script$m);
  return app;
};
const ElAmapLayerMapboxVectorTile = script$m;

var script$l = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerWms",
    inheritAttrs: false
  },
  __name: "WMS",
  props: buildProps({
    url: {
      type: String
    },
    // wms服务的url地址，如' https://ahocevar.com/geoserver/wms '
    blend: {
      type: Boolean,
      default: false
    },
    // 地图级别切换时，不同级别的图片是否进行混合，如图层的图像内容为部分透明请设置为false
    params: {
      type: Object
    },
    // OGC标准的WMS地图服务的GetMap接口的参数，包括VERSION、LAYERS、STYLES、FORMAT、TRANSPARENT等
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer.WMS(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$l.__file = "src/vue-amap/packages/layer/standard/WMS/WMS.vue";

script$l.install = (app) => {
  app.component(script$l.name, script$l);
  return app;
};
const ElAmapLayerWms = script$l;

var script$k = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerWmts",
    inheritAttrs: false
  },
  __name: "WMTS",
  props: buildProps({
    url: {
      type: String
    },
    // wmts服务的url地址，如：' https://services.arcgisonline.com/arcgis/rest/services/'+ 'Demographics/USA_Population_Density/MapServer/WMTS/'
    blend: {
      type: Boolean,
      default: false
    },
    // 地图级别切换时，不同级别的图片是否进行混合，如图层的图像内容为部分透明请设置为false
    params: {
      type: Object
    },
    // OGC标准的WMS地图服务的GetMap接口的参数，包括VERSION、LAYERS、STYLES、FORMAT、TRANSPARENT等
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.TileLayer.WMTS(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$k.__file = "src/vue-amap/packages/layer/standard/WMTS/WMTS.vue";

script$k.install = (app) => {
  app.component(script$k.name, script$k);
  return app;
};
const ElAmapLayerWmts = script$k;

var script$j = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapElasticMarker",
    inheritAttrs: false
  },
  __name: "ElasticMarker",
  props: buildProps({
    position: {
      type: [Array, Object],
      required: true
    },
    // 点标记在地图上显示的位置
    title: {
      type: String
    },
    // 鼠标滑过点标记时的文字提示。不设置则鼠标滑过点标无文字提示。
    offset: {
      type: [Array, Object]
    },
    // 点标记显示位置偏移量，默认值为 [0,0] 。Marker指定position后，默认以marker左上角位置为基准点（若设置了anchor，则以anchor设置位置为基准点），对准所给定的position位置，若需使marker指定位置对准在position处，需根据marker的尺寸设置一定的偏移量。
    clickable: {
      type: Boolean,
      default: true
    },
    // 点标记是否可点击，默认值: true
    draggable: {
      type: Boolean,
      default: false
    },
    // 设置点标记是否可拖拽移动，默认值：false
    bubble: {
      type: Boolean,
      default: false
    },
    // 事件是否冒泡，默认为 false
    zooms: {
      type: Array
    },
    // 点标记显示的层级范围，超过范围不显示。默认值：zooms: [2, 20]
    cursor: {
      type: String
    },
    // 指定鼠标悬停时的鼠，默认值：'pointer'
    topWhenClick: {
      type: Boolean,
      default: false
    },
    // 鼠标点击时marker是否置顶，默认false ，不置顶
    zoomStyleMapping: {
      type: Object
    },
    // 表示地图级别与styles中样式的映射，{14:0,15:0,16:1,17:1,}表示14到15级使用styles中的第0个样式，16-17级使用第二个样式
    styles: {
      type: Array
    },
    // 多个不同样式的数组
    extData: {
      type: Object,
      default: () => null
    }
  }),
  emits: ["init", "update:position"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.ElasticMarker"], () => {
          $amapComponent = new AMap.ElasticMarker(options);
          parentComponent.add($amapComponent);
          bindModelEvents();
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitPosition();
      });
      $amapComponent.on("touchend", () => {
        emitPosition();
      });
    };
    const emitPosition = () => {
      const position = $amapComponent.getPosition();
      emits("update:position", position == null ? void 0 : position.toArray());
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$j.__file = "src/vue-amap/packages/marker/ElasticMarker/ElasticMarker.vue";

script$j.install = (app) => {
  app.component(script$j.name, script$j);
  return app;
};
const ElAmapElasticMarker = script$j;

var script$i = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLabelMarker",
    inheritAttrs: false
  },
  __name: "LabelMarker",
  props: buildProps({
    name: {
      type: String
    },
    // 标注名称，作为标注标识，并非最终在地图上显示的文字内容，显示文字内容请设置 opts.text.content
    position: {
      type: [Array, Object],
      required: true
    },
    // 标注位置
    zooms: {
      type: Array
    },
    // 点标记显示的层级范围，超过范围不显示。默认值：zooms: [2, 20]
    opacity: {
      type: Number
    },
    // 标注透明度，默认值: 1
    rank: {
      type: Number
    },
    // 避让优先级，获取标注的优先级，该优先级用于 labelsLayer 支持避让时，rank 值大的标注会避让掉 rank 值低的标注。默认值：1
    icon: {
      type: Object
    },
    // 标注图标设置
    text: {
      type: Object
    },
    // 标注文本设置
    extData: null
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.LabelMarker(options);
        parentComponent.add($amapComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$i.__file = "src/vue-amap/packages/marker/LabelMarker/LabelMarker.vue";

script$i.install = (app) => {
  app.component(script$i.name, script$i);
  return app;
};
const ElAmapLabelMarker = script$i;

const propsTypes$7 = buildProps({
  position: {
    type: [Array, Object],
    required: true
  },
  // 点标记在地图上显示的位置
  icon: {
    type: [String, Object]
  },
  // 在点标记中显示的图标。可以传一个图标地址，也可以传Icon对象。有合法的content内容设置时，此属性无效。
  content: {
    type: [String, typeof HTMLElement === "undefined" ? Object : HTMLElement]
  },
  // 点标记显示内容。可以是HTML要素字符串或者HTML DOM对象。content有效时，icon属性将被覆盖。
  title: {
    type: String
  },
  // 鼠标滑过点标记时的文字提示。不设置则鼠标滑过点标无文字提示。
  offset: {
    type: [Array, Object]
  },
  // 点标记显示位置偏移量，默认值为 [0,0] 。Marker指定position后，默认以marker左上角位置为基准点（若设置了anchor，则以anchor设置位置为基准点），对准所给定的position位置，若需使marker指定位置对准在position处，需根据marker的尺寸设置一定的偏移量。
  anchor: {
    type: [String, Array]
  },
  // 设置点标记锚点，可选值：'top-left','top-center','top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-center', 'bottom-right'
  angle: {
    type: Number
  },
  // 点标记的旋转角度，，广泛用于改变车辆行驶方向。默认值：0
  clickable: {
    type: Boolean,
    default: true
  },
  // 点标记是否可点击，默认值: true
  draggable: {
    type: Boolean,
    default: false
  },
  // 设置点标记是否可拖拽移动，默认值：false
  bubble: {
    type: Boolean,
    default: false
  },
  // 事件是否冒泡，默认为 false
  zooms: {
    type: Array
  },
  // 点标记显示的层级范围，超过范围不显示。默认值：zooms: [2, 20]
  cursor: {
    type: String
  },
  // 指定鼠标悬停时的鼠，默认值：'pointer'
  topWhenClick: {
    type: Boolean,
    default: false
  },
  // 鼠标点击时marker是否置顶，默认false ，不置顶
  label: {
    type: Object
  },
  // 添加文本标注
  extData: null,
  moveOptions: {
    type: Object,
    default: () => null
  }
});

const _hoisted_1 = { style: { "display": "none" } };
var script$h = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapMarker",
    inheritAttrs: false
  },
  __name: "Marker",
  props: buildProps(propsTypes$7),
  emits: ["init", "update:position"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const tempId = `marker-${guid()}`;
    const divId = ref("");
    let $amapComponent;
    let withSlot = false;
    const $slots = useSlots();
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        if ($slots.default && $slots.default().length > 0) {
          withSlot = true;
          options.content = `<div id="${tempId}"></div>`;
        }
        $amapComponent = new AMap.Marker(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        }
        if (withSlot) {
          divId.value = tempId;
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __position(position) {
          if (!props.moveOptions) {
            $amapComponent.setPosition(position);
            return;
          }
          if (parentInstance == null ? void 0 : parentInstance.$amapComponent) {
            parentInstance.$amapComponent.plugin("AMap.MoveAnimation", () => {
              $amapComponent.moveTo(position, props.moveOptions);
            });
          }
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitPosition();
      });
      $amapComponent.on("touchend", () => {
        emitPosition();
      });
    };
    const emitPosition = () => {
      const position = $amapComponent.getPosition();
      emits("update:position", position.toArray());
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        !!divId.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "#" + divId.value
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 8, ["to"])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});

script$h.__file = "src/vue-amap/packages/marker/Marker/Marker.vue";

script$h.install = (app) => {
  app.component(script$h.name, script$h);
  return app;
};
const ElAmapMarker = script$h;

var script$g = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapMarkerCluster",
    inheritAttrs: false
  },
  __name: "MarkerCluster",
  props: buildProps({
    points: {
      type: Object,
      required: true
    },
    // 需要进行聚合显示的点数据
    gridSize: {
      type: Number
    },
    // 聚合计算时网格的像素大小，默认60
    maxZoom: {
      type: Number
    },
    // 最大的聚合级别，大于该级别就不进行相应的聚合。默认值为 18，即小于 18 级的级别均进行聚合，18 及以上级别不进行聚合
    averageCenter: {
      type: Boolean,
      default: true
    },
    // 聚合点的图标位置是否是所有聚合内点的中心点。默认为 true。数据中如果含有权重值，以权重高的点为中心进行聚合
    clusterByZoomChange: {
      type: Boolean,
      default: false
    },
    // 地图缩放过程中是否聚合。默认值 false。
    styles: {
      type: Array
    },
    // 指定聚合后的点标记的图标样式，可缺省，缺省时为默认样式
    renderClusterMarker: {
      type: Function
    },
    // 该方法用来实现聚合点的自定义绘制，由开发者自己实现，API 将在绘制每个聚合点的时候调用这个方法，可以实现聚合点样式的灵活设定，指定了 renderClusterMarker 后 styles 无效。
    renderMarker: {
      type: Function
    }
    // 该方法用来实现非聚合点的自定义绘制，由开发者自己实现，API 将在绘制每个非聚合点的时候调用这个方法
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MarkerCluster"], () => {
          const points = options.points;
          delete options.points;
          $amapComponent = new AMap.MarkerCluster(parentComponent, points, options);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      watchRedirectFn: {
        __points(value) {
          if ($amapComponent) {
            $amapComponent.setData(value);
          }
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$g.__file = "src/vue-amap/packages/marker/MarkerCluster/MarkerCluster.vue";

script$g.install = (app) => {
  app.component(script$g.name, script$g);
  return app;
};
const ElAmapMarkerCluster = script$g;

var script$f = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapMassMarks",
    inheritAttrs: false
  },
  __name: "MassMarks",
  props: buildProps({
    data: {
      type: Array,
      required: true
    },
    // 海量点数据参数
    zooms: {
      type: Array
    },
    // 点标记显示的层级范围，超过范围不显示。
    cursor: {
      type: String
    },
    // 指定鼠标悬停时的鼠，默认值：'pointer'
    styles: {
      type: [Array, Object]
    }
    // 样式
  }),
  emits: ["init", "update:center"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        const data = options.data;
        delete options.data;
        $amapComponent = new AMap.MassMarks(data, options);
        $amapComponent.setMap(parentComponent);
        resolve($amapComponent);
      });
    }, {
      emits,
      propsRedirect: {
        styles: "style"
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.clear();
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$f.__file = "src/vue-amap/packages/marker/MassMarks/MassMarks.vue";

script$f.install = (app) => {
  app.component(script$f.name, script$f);
  return app;
};
const ElAmapMassMarks = script$f;

const propsType$1 = buildProps({
  position: {
    type: [Array, Object],
    required: true
  },
  // 点标记在地图上显示的位置
  text: {
    type: String
  },
  // 标记显示的文本内容
  title: {
    type: String
  },
  // 鼠标滑过点标记时的文字提示。不设置则鼠标滑过点标无文字提示。
  offset: {
    type: [Array, Object]
  },
  // 点标记显示位置偏移量，默认值为 [0,0] 。Marker指定position后，默认以marker左上角位置为基准点（若设置了anchor，则以anchor设置位置为基准点），对准所给定的position位置，若需使marker指定位置对准在position处，需根据marker的尺寸设置一定的偏移量。
  anchor: {
    type: [String, Array]
  },
  // 设置点标记锚点，可选值：'top-left','top-center','top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-center', 'bottom-right'
  angle: {
    type: Number
  },
  // 点标记的旋转角度。默认值：0 。注：angle属性是使用CSS3来实现的，支持IE9及以上版本
  clickable: {
    type: Boolean,
    default: true
  },
  // 点标记是否可点击，默认值: true
  draggable: {
    type: Boolean,
    default: false
  },
  // 设置点标记是否可拖拽移动，默认值：false
  bubble: {
    type: Boolean,
    default: false
  },
  // 事件是否冒泡，默认为 false
  zooms: {
    type: Array
  },
  // 点标记显示的层级范围，超过范围不显示。默认值：zooms: [2, 20]
  cursor: {
    type: String
  },
  // 指定鼠标悬停时的鼠，默认值：'pointer'
  topWhenClick: {
    type: Boolean,
    default: false
  },
  // 鼠标点击时marker是否置顶，默认false ，不置顶
  textStyle: {
    type: Object
  },
  // 设置文本样式，Object同css样式表，如:{'background-color':'red'}
  extData: null
});

var script$e = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapText",
    inheritAttrs: false
  },
  __name: "Text",
  props: propsType$1,
  emits: ["init", "update:position"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Text(options);
        parentComponent.add($amapComponent);
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      propsRedirect: {
        textStyle: "style"
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          $amapComponent.setMap(null);
          $amapComponent = null;
        }
      }
    });
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitPosition();
      });
      $amapComponent.on("touchend", () => {
        emitPosition();
      });
    };
    const emitPosition = () => {
      const position = $amapComponent.getPosition();
      emits("update:position", position.toArray());
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$e.__file = "src/vue-amap/packages/marker/Text/Text.vue";

script$e.install = (app) => {
  app.component(script$e.name, script$e);
  return app;
};
const ElAmapText = script$e;

function useEditor(editor, attrs) {
  if (!editor)
    return;
  const filters = ["addnode", "adjust", "removenode", "end", "move", "add"];
  const filterSet = {};
  Object.keys(attrs).forEach((key) => {
    if (eventReg.test(key)) {
      const eventKey = convertEventToLowerCase(key);
      if (filters.indexOf(eventKey) !== -1)
        filterSet[eventKey] = attrs[key];
    }
  });
  Object.keys(filterSet).forEach((key) => {
    bindInstanceEvent(editor, key, filterSet[key]);
  });
}

const propsTypes$6 = buildProps({
  // 贝瑟尔曲线的路径。描述为一个二维数组规则如下：第一个元素是起点， 之后的元素同时描述控制点和途经点，之后每个元素可以有0个到2个控制点 控制点在前，途经点在最后 [ [lng,lat] ,//起点0 [lng,lat,lng,lat,lng,lat] ,//控制点、控制点、途经点2 [lng,lat,lng,lat] //控制点、途经点3 ] 或者 [ [ [lng,lat] ],//起点0 [ [lng,lat] , [lng,lat] ],//控制点、途经点1 [ [lng,lat] , [lng,lat] , [lng,lat] ],//控制点、控制点、途经点2 [ [lng,lat] , [lng,lat] ]//控制点、途经点3 ]
  path: {
    type: Array,
    required: true
  },
  // 是否将覆盖物的鼠标或touch等事件冒泡到地图上
  bubble: {
    type: Boolean,
    default: false
  },
  // 指定鼠标悬停时的鼠标样式，自定义cursor，IE仅支持cur/ani/ico格式，Opera不支持自定义cursor
  cursor: {
    type: String
  },
  // 线条颜色，使用16进制颜色代码赋值。默认值为#00D3FC
  strokeColor: {
    type: String
  },
  // 轮廓线透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.9
  strokeOpacity: {
    type: Number
  },
  // 轮廓线宽度。默认 2
  strokeWeight: {
    type: Number
  },
  // 描边线宽度
  borderWeight: {
    type: Number
  },
  // 是否显示描边,默认false
  isOutline: {
    type: Boolean,
    default: false
  },
  // 线条描边颜色，此项仅在isOutline为true时有效，默认：#00B2D5
  outlineColor: {
    type: String
  },
  // 设置多边形是否可拖拽移动，默认为false
  draggable: {
    type: Boolean,
    default: false
  },
  extData: {
    type: Object,
    default: () => null
  },
  // 轮廓线样式，实线:solid，虚线:dashed
  strokeStyle: {
    type: String,
    validator: (value) => {
      return ["solid", "dashed"].indexOf(value) !== -1;
    }
  },
  // 勾勒形状轮廓的虚线和间隙的样式，此属性在strokeStyle 为dashed 时有效， 此属性在ie9+浏览器有效 取值： 实线： [0,0,0] 虚线： [10,10] ， [10,10] 表示10个像素的实线和10个像素的空白（如此反复）组成的虚线 点画线： [10,2,10] ， [10,2,10] 表示10个像素的实线和2个像素的空白 + 10个像素的实线和10个像素的空白 （如此反复）组成的虚线
  strokeDasharray: {
    type: Array
  },
  // 折线拐点的绘制样式，默认值为'miter'尖角，其他可选值：'round'圆角、'bevel'斜角
  lineJoin: {
    type: String,
    validator: (value) => {
      return ["miter", "round", "bevel"].indexOf(value) !== -1;
    }
  },
  // 折线两端线帽的绘制样式，默认值为'butt'无头，其他可选值：'round'圆头、'square'方头
  lineCap: {
    type: String,
    validator: (value) => {
      return ["butt", "round", "square"].indexOf(value) !== -1;
    }
  },
  // 是否绘制成大地线，默认false
  geodesic: {
    type: Boolean,
    default: false
  },
  // 是否延路径显示白色方向箭头,默认false。建议折线宽度大于6时使用
  showDir: {
    type: Boolean,
    default: false
  },
  editable: {
    type: Boolean,
    default: false
  },
  editOptions: {
    type: Object
  }
});

var script$d = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapBezierCurve",
    inheritAttrs: false
  },
  __name: "BezierCurve",
  props: propsTypes$6,
  emits: ["init", "update:path"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let destroying = false;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.BezierCurve(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        } else if (isVectorLayerInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __zIndex(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ zIndex: value });
          }
        },
        __strokeColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeColor: value });
          }
        },
        __strokeOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeOpacity: value });
          }
        },
        __strokeWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeWeight: value });
          }
        },
        __borderWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ borderWeight: value });
          }
        },
        __isOutline(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ isOutline: value });
          }
        },
        __outlineColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ outlineColor: value });
          }
        },
        __strokeStyle(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeStyle: value });
          }
        },
        __strokeDasharray(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeDasharray: value });
          }
        },
        __lineJoin(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ lineJoin: value });
          }
        },
        __lineCap(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ lineCap: value });
          }
        },
        __geodesic(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ geodesic: value });
          }
        },
        __showDir(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ showDir: value });
          }
        },
        __editable(flag) {
          createEditor().then(() => {
            flag ? resetEditor() : editor.close();
          });
        },
        __path(path) {
          if ($amapComponent) {
            $amapComponent.setPath(path);
            resetEditor();
          }
        }
      },
      destroyComponent() {
        destroying = true;
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (editor) {
            if (!parentInstance.isDestroy) {
              editor.close();
            }
            editor = null;
          }
          if (!parentInstance.isDestroy) {
            if (isMapInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            } else if (isOverlayGroupInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.removeOverlay($amapComponent);
            } else if (isVectorLayerInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            }
          }
          if ($amapComponent.destroy) {
            $amapComponent.destroy();
          }
          $amapComponent = null;
        }
      }
    });
    const resetEditor = debounce(() => {
      if (editor && props.editable) {
        editor.close();
        editor.setTarget();
        editor.setTarget($amapComponent);
        editor.open();
      }
    }, 50);
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitModel($amapComponent);
      });
      $amapComponent.on("touchend", () => {
        emitModel($amapComponent);
      });
    };
    const emitModel = debounce((target) => {
      if (destroying) {
        return;
      }
      const path = target.getPath();
      emits("update:path", path);
    }, 50);
    let editor;
    const attrs = useAttrs();
    const createEditor = () => {
      return new Promise((resolve) => {
        if (editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.BezierCurveEditor"], () => {
            editor = new AMap.BezierCurveEditor(parentInstance == null ? void 0 : parentInstance.$amapComponent, $amapComponent, props.editOptions);
            useEditor(editor, attrs);
            bindEditorModelEvents();
            resolve();
          });
        }
      });
    };
    const bindEditorModelEvents = () => {
      editor.on("addnode", (e) => {
        emitModel(e.target);
      });
      editor.on("adjust", (e) => {
        emitModel(e.target);
      });
      editor.on("removenode", (e) => {
        emitModel(e.target);
      });
      editor.on("add", (e) => {
        emitModel(e.target);
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$d.__file = "src/vue-amap/packages/vector/BezierCurve/BezierCurve.vue";

script$d.install = (app) => {
  app.component(script$d.name, script$d);
  return app;
};
const ElAmapBezierCurve = script$d;

const propsTypes$5 = buildProps({
  // 圆心位置
  center: {
    type: Array,
    required: true
  },
  // 圆半径，单位:米
  radius: {
    type: Number,
    required: true
  },
  // 是否将覆盖物的鼠标或touch等事件冒泡到地图上
  bubble: {
    type: Boolean,
    default: false
  },
  // 指定鼠标悬停时的鼠标样式，自定义cursor，IE仅支持cur/ani/ico格式，Opera不支持自定义cursor
  cursor: {
    type: String
  },
  // 线条颜色，使用16进制颜色代码赋值。默认值为#00D3FC
  strokeColor: {
    type: String
  },
  // 轮廓线透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.9
  strokeOpacity: {
    type: Number
  },
  // 轮廓线宽度。默认 2
  strokeWeight: {
    type: Number
  },
  // 多边形填充颜色，使用16进制颜色代码赋值，如：#00B2D5
  fillColor: {
    type: String
  },
  // 多边形填充透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.5
  fillOpacity: {
    type: Number
  },
  // 设置多边形是否可拖拽移动，默认为false
  draggable: {
    type: Boolean,
    default: false
  },
  extData: {
    type: Object,
    default: () => null
  },
  // 轮廓线样式，实线:solid，虚线:dashed
  strokeStyle: {
    type: String,
    validator: (value) => {
      return ["solid", "dashed"].indexOf(value) !== -1;
    }
  },
  // 勾勒形状轮廓的虚线和间隙的样式，此属性在strokeStyle 为dashed 时有效， 此属性在ie9+浏览器有效 取值： 实线： [0,0,0] 虚线： [10,10] ， [10,10] 表示10个像素的实线和10个像素的空白（如此反复）组成的虚线 点画线： [10,2,10] ， [10,2,10] 表示10个像素的实线和2个像素的空白 + 10个像素的实线和10个像素的空白 （如此反复）组成的虚线
  strokeDasharray: {
    type: Array
  },
  editable: {
    type: Boolean,
    default: false
  },
  editOptions: {
    type: Object
  }
});

var script$c = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapCircle",
    inheritAttrs: false
  },
  __name: "Circle",
  props: propsTypes$5,
  emits: ["init", "update:center", "update:radius"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let destroying = false;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Circle(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        } else if (isVectorLayerInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __zIndex(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ zIndex: value });
          }
        },
        __strokeColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeColor: value });
          }
        },
        __strokeOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeOpacity: value });
          }
        },
        __strokeWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeWeight: value });
          }
        },
        __fillColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillColor: value });
          }
        },
        __fillOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillOpacity: value });
          }
        },
        __strokeStyle(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeStyle: value });
          }
        },
        __strokeDasharray(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeDasharray: value });
          }
        },
        __editable(flag) {
          createEditor().then(() => {
            flag ? resetEditor() : editor.close();
          });
        },
        __center(center) {
          if ($amapComponent) {
            $amapComponent.setCenter(center);
            resetEditor();
          }
        },
        __radius(radius) {
          if ($amapComponent) {
            $amapComponent.setRadius(radius);
            resetEditor();
          }
        }
      },
      destroyComponent() {
        destroying = true;
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (editor) {
            if (!parentInstance.isDestroy) {
              editor.close();
            }
            editor = null;
          }
          if (!parentInstance.isDestroy) {
            if (isMapInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            } else if (isOverlayGroupInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.removeOverlay($amapComponent);
            } else if (isVectorLayerInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            }
          }
          if ($amapComponent.destroy) {
            $amapComponent.destroy();
          }
          $amapComponent = null;
        }
      }
    });
    const resetEditor = debounce(() => {
      if (editor && props.editable) {
        editor.close();
        editor.setTarget();
        editor.setTarget($amapComponent);
        editor.open();
      }
    }, 50);
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitModel($amapComponent);
      });
      $amapComponent.on("touchend", () => {
        emitModel($amapComponent);
      });
    };
    const emitModel = (target) => {
      if (destroying) {
        return;
      }
      emits("update:center", target.getCenter().toArray());
      emits("update:radius", target.getRadius());
    };
    let editor;
    const attrs = useAttrs();
    const createEditor = () => {
      return new Promise((resolve) => {
        if (editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.CircleEditor"], () => {
            editor = new AMap.CircleEditor(parentInstance == null ? void 0 : parentInstance.$amapComponent, $amapComponent, props.editOptions);
            useEditor(editor, attrs);
            bindEditorModelEvents();
            resolve();
          });
        }
      });
    };
    const bindEditorModelEvents = () => {
      editor.on("addnode", (e) => {
        emitModel(e.target);
      });
      editor.on("adjust", (e) => {
        emitModel(e.target);
      });
      editor.on("removenode", (e) => {
        emitModel(e.target);
      });
      editor.on("add", (e) => {
        emitModel(e.target);
      });
      editor.on("move", (e) => {
        emitModel(e.target);
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$c.__file = "src/vue-amap/packages/vector/Circle/Circle.vue";

script$c.install = (app) => {
  app.component(script$c.name, script$c);
  return app;
};
const ElAmapCircle = script$c;

const propsTypes$4 = buildProps({
  // 圆心位置
  center: {
    type: Array,
    required: true
  },
  // 椭圆的半径，用2个元素的数组表示，单位：米 如： radius: [1000, 2000] 表示横向半径是1000，纵向的半径是2000 默认值： [1000, 1000]
  radius: {
    type: Array,
    required: true
  },
  // 是否将覆盖物的鼠标或touch等事件冒泡到地图上
  bubble: {
    type: Boolean,
    default: false
  },
  // 指定鼠标悬停时的鼠标样式，自定义cursor，IE仅支持cur/ani/ico格式，Opera不支持自定义cursor
  cursor: {
    type: String
  },
  // 线条颜色，使用16进制颜色代码赋值。默认值为#00D3FC
  strokeColor: {
    type: String
  },
  // 轮廓线透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.9
  strokeOpacity: {
    type: Number
  },
  // 轮廓线宽度。默认 2
  strokeWeight: {
    type: Number
  },
  // 多边形填充颜色，使用16进制颜色代码赋值，如：#00B2D5
  fillColor: {
    type: String
  },
  // 多边形填充透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.5
  fillOpacity: {
    type: Number
  },
  // 设置多边形是否可拖拽移动，默认为false
  draggable: {
    type: Boolean,
    default: false
  },
  extData: {
    type: Object,
    default: () => null
  },
  // 轮廓线样式，实线:solid，虚线:dashed
  strokeStyle: {
    type: String,
    validator: (value) => {
      return ["solid", "dashed"].indexOf(value) !== -1;
    }
  },
  // 勾勒形状轮廓的虚线和间隙的样式，此属性在strokeStyle 为dashed 时有效， 此属性在ie9+浏览器有效 取值： 实线： [0,0,0] 虚线： [10,10] ， [10,10] 表示10个像素的实线和10个像素的空白（如此反复）组成的虚线 点画线： [10,2,10] ， [10,2,10] 表示10个像素的实线和2个像素的空白 + 10个像素的实线和10个像素的空白 （如此反复）组成的虚线
  strokeDasharray: {
    type: Array
  },
  editable: {
    type: Boolean,
    default: false
  },
  editOptions: {
    type: Object
  }
});

var script$b = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapEllipse",
    inheritAttrs: false
  },
  __name: "Ellipse",
  props: propsTypes$4,
  emits: ["init", "update:center", "update:radius"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let destroying = false;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Ellipse(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        } else if (isVectorLayerInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __zIndex(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ zIndex: value });
          }
        },
        __strokeColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeColor: value });
          }
        },
        __strokeOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeOpacity: value });
          }
        },
        __strokeWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeWeight: value });
          }
        },
        __fillColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillColor: value });
          }
        },
        __fillOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillOpacity: value });
          }
        },
        __strokeStyle(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeStyle: value });
          }
        },
        __strokeDasharray(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeDasharray: value });
          }
        },
        __editable(flag) {
          createEditor().then(() => {
            flag ? resetEditor() : editor.close();
          });
        },
        __center(center) {
          if ($amapComponent) {
            $amapComponent.setCenter(center);
            resetEditor();
          }
        },
        __radius(radius) {
          if ($amapComponent) {
            $amapComponent.setRadius(radius);
            resetEditor();
          }
        }
      },
      destroyComponent() {
        destroying = true;
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (editor) {
            if (!parentInstance.isDestroy) {
              editor.close();
            }
            editor = null;
          }
          if (!parentInstance.isDestroy) {
            if (isMapInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            } else if (isOverlayGroupInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.removeOverlay($amapComponent);
            } else if (isVectorLayerInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            }
          }
          if ($amapComponent.destroy) {
            $amapComponent.destroy();
          }
          $amapComponent = null;
        }
      }
    });
    const resetEditor = debounce(() => {
      if (editor && props.editable) {
        editor.close();
        editor.setTarget();
        editor.setTarget($amapComponent);
        editor.open();
      }
    }, 50);
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitModel($amapComponent);
      });
      $amapComponent.on("touchend", () => {
        emitModel($amapComponent);
      });
    };
    const emitModel = (target) => {
      if (destroying) {
        return;
      }
      emits("update:center", target.getCenter().toArray());
      emits("update:radius", target.getRadius());
    };
    let editor;
    const attrs = useAttrs();
    const createEditor = () => {
      return new Promise((resolve) => {
        if (editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.EllipseEditor"], () => {
            editor = new AMap.EllipseEditor(parentInstance == null ? void 0 : parentInstance.$amapComponent, $amapComponent, props.editOptions);
            useEditor(editor, attrs);
            bindEditorModelEvents();
            resolve();
          });
        }
      });
    };
    const bindEditorModelEvents = () => {
      editor.on("addnode", (e) => {
        emitModel(e.target);
      });
      editor.on("adjust", (e) => {
        emitModel(e.target);
      });
      editor.on("removenode", (e) => {
        emitModel(e.target);
      });
      editor.on("add", (e) => {
        emitModel(e.target);
      });
      editor.on("move", (e) => {
        emitModel(e.target);
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$b.__file = "src/vue-amap/packages/vector/Ellipse/Ellipse.vue";

script$b.install = (app) => {
  app.component(script$b.name, script$b);
  return app;
};
const ElAmapEllipse = script$b;

var script$a = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapGeojson",
    inheritAttrs: false
  },
  __name: "GeoJSON",
  props: buildProps({
    // 要加载的标准GeoJSON对象
    geo: {
      type: Object,
      required: true
    },
    // marker的默认样式
    markerOptions: {
      type: Object
    },
    // 指定点要素的绘制方式，缺省时为Marker的默认样式。geojson为当前要素对应的GeoJSON对象，lnglats为对应的线的路径
    getMarker: {
      type: Function
    },
    // polyline的默认样式
    polylineOptions: {
      type: Object
    },
    // 指定线要素的绘制方式，缺省时为Polyline的默认样式。geojson为当前要素对应的GeoJSON对象，lnglats为对应的线的路径
    getPolyline: {
      type: Function
    },
    // polygon的默认样式
    polygonOptions: {
      type: Object
    },
    // 指定面要素的绘制方式，缺省时为Polygon的默认样式。geojson为当前要素对应的GeoJSON对象，lnglats为对应的线的路径
    getPolygon: {
      type: Function
    }
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.GeoJSON"], () => {
          if (!options.getMarker) {
            options.getMarker = createMarker;
          }
          if (!options.getPolyline) {
            options.getPolyline = createPolyline;
          }
          if (!options.getPolygon) {
            options.getPolygon = createPolygon;
          }
          $amapComponent = new AMap.GeoJSON(options);
          parentComponent.add($amapComponent);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      propsRedirect: {
        geo: "geoJSON"
      },
      watchRedirectFn: {
        __geoJSON(value) {
          if ($amapComponent) {
            $amapComponent.importData(value);
          }
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    const createMarker = (geojson, lnglat) => {
      let options = props.markerOptions || {};
      options = merge({}, options, geojson.properties);
      options.position = lnglat;
      return new AMap.Marker(options);
    };
    const createPolyline = (geojson, lnglat) => {
      let options = props.polylineOptions || {};
      options = merge({}, options, geojson.properties);
      options.path = lnglat;
      return new AMap.Polyline(options);
    };
    const createPolygon = (geojson, lnglat) => {
      let options = props.polygonOptions || {};
      options = merge({}, options, geojson.properties);
      options.path = lnglat;
      return new AMap.Polygon(options);
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$a.__file = "src/vue-amap/packages/vector/GeoJSON/GeoJSON.vue";

script$a.install = (app) => {
  app.component(script$a.name, script$a);
  return app;
};
const ElAmapGeojson = script$a;

const propsTypes$3 = buildProps({
  // 多边形轮廓线的节点坐标数组。 支持 单个普通多边形({Array })，单个带孔多边形({Array<Array >})，多个带孔多边形({Array<Array<Array >>})
  path: {
    type: Array,
    required: true
  },
  // 是否将覆盖物的鼠标或touch等事件冒泡到地图上
  bubble: {
    type: Boolean,
    default: false
  },
  // 指定鼠标悬停时的鼠标样式，自定义cursor，IE仅支持cur/ani/ico格式，Opera不支持自定义cursor
  cursor: {
    type: String
  },
  // 线条颜色，使用16进制颜色代码赋值。默认值为#00D3FC
  strokeColor: {
    type: String
  },
  // 轮廓线透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.9
  strokeOpacity: {
    type: Number
  },
  // 轮廓线宽度。默认 2
  strokeWeight: {
    type: Number
  },
  // 多边形填充颜色，使用16进制颜色代码赋值，如：#00B2D5
  fillColor: {
    type: String
  },
  // 多边形填充透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.5
  fillOpacity: {
    type: Number
  },
  // 设置多边形是否可拖拽移动，默认为false
  draggable: {
    type: Boolean,
    default: false
  },
  extData: {
    type: Object,
    default: () => null
  },
  // 轮廓线样式，实线:solid，虚线:dashed
  strokeStyle: {
    type: String,
    validator: (value) => {
      return ["solid", "dashed"].indexOf(value) !== -1;
    }
  },
  // 勾勒形状轮廓的虚线和间隙的样式，此属性在strokeStyle 为dashed 时有效， 此属性在ie9+浏览器有效 取值： 实线： [0,0,0] 虚线： [10,10] ， [10,10] 表示10个像素的实线和10个像素的空白（如此反复）组成的虚线 点画线： [10,2,10] ， [10,2,10] 表示10个像素的实线和2个像素的空白 + 10个像素的实线和10个像素的空白 （如此反复）组成的虚线
  strokeDasharray: {
    type: Array
  },
  editable: {
    type: Boolean,
    default: false
  },
  editOptions: {
    type: Object
  }
});

var script$9 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapPolygon",
    inheritAttrs: false
  },
  __name: "Polygon",
  props: propsTypes$3,
  emits: ["init", "update:path"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let destroying = false;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Polygon(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        } else if (isVectorLayerInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __zIndex(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ zIndex: value });
          }
        },
        __strokeColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeColor: value });
          }
        },
        __strokeOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeOpacity: value });
          }
        },
        __strokeWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeWeight: value });
          }
        },
        __fillColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillColor: value });
          }
        },
        __fillOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillOpacity: value });
          }
        },
        __strokeStyle(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeStyle: value });
          }
        },
        __strokeDasharray(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeDasharray: value });
          }
        },
        __editable(flag) {
          createEditor().then(() => {
            flag ? resetEditor() : editor.close();
          });
        },
        __path(path) {
          if ($amapComponent) {
            $amapComponent.setPath(path);
            resetEditor();
          }
        }
      },
      destroyComponent() {
        destroying = true;
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (editor) {
            if (!parentInstance.isDestroy) {
              editor.close();
            }
            editor = null;
          }
          if (!parentInstance.isDestroy) {
            if (isMapInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            } else if (isOverlayGroupInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.removeOverlay($amapComponent);
            } else if (isVectorLayerInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            }
          }
          if ($amapComponent.destroy) {
            $amapComponent.destroy();
          }
          $amapComponent = null;
        }
      }
    });
    const resetEditor = debounce(() => {
      if (editor && props.editable) {
        editor.close();
        editor.setTarget();
        editor.setTarget($amapComponent);
        editor.open();
      }
    }, 50);
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitModel($amapComponent);
      });
      $amapComponent.on("touchend", () => {
        emitModel($amapComponent);
      });
    };
    const emitModel = (target) => {
      if (destroying) {
        return;
      }
      const paths = target.getPath();
      const pathArray = paths == null ? void 0 : paths.map(convertLnglat);
      emits("update:path", pathArray);
    };
    let editor;
    const attrs = useAttrs();
    const createEditor = () => {
      return new Promise((resolve) => {
        if (editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.PolygonEditor"], () => {
            editor = new AMap.PolygonEditor(parentInstance == null ? void 0 : parentInstance.$amapComponent, $amapComponent, props.editOptions);
            useEditor(editor, attrs);
            bindEditorModelEvents();
            resolve();
          });
        }
      });
    };
    const bindEditorModelEvents = () => {
      editor.on("addnode", (e) => {
        emitModel(e.target);
      });
      editor.on("adjust", (e) => {
        emitModel(e.target);
      });
      editor.on("removenode", (e) => {
        emitModel(e.target);
      });
      editor.on("add", (e) => {
        emitModel(e.target);
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$9.__file = "src/vue-amap/packages/vector/Polygon/Polygon.vue";

script$9.install = (app) => {
  app.component(script$9.name, script$9);
  return app;
};
const ElAmapPolygon = script$9;

const propsTypes$2 = buildProps({
  // polyline 路径，支持 lineString 和 MultiLineString
  path: {
    type: Array,
    required: true
  },
  // 是否将覆盖物的鼠标或touch等事件冒泡到地图上
  bubble: {
    type: Boolean,
    default: false
  },
  // 指定鼠标悬停时的鼠标样式，自定义cursor，IE仅支持cur/ani/ico格式，Opera不支持自定义cursor
  cursor: {
    type: String
  },
  // 线条颜色，使用16进制颜色代码赋值。默认值为#00D3FC
  strokeColor: {
    type: String
  },
  // 轮廓线透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.9
  strokeOpacity: {
    type: Number
  },
  // 轮廓线宽度。默认 2
  strokeWeight: {
    type: Number
  },
  // 描边线宽度
  borderWeight: {
    type: Number
  },
  // 是否显示描边,默认false
  isOutline: {
    type: Boolean,
    default: false
  },
  // 线条描边颜色，此项仅在isOutline为true时有效，默认：#00B2D5
  outlineColor: {
    type: String
  },
  // 设置多边形是否可拖拽移动，默认为false
  draggable: {
    type: Boolean,
    default: false
  },
  extData: {
    type: Object,
    default: () => null
  },
  // 轮廓线样式，实线:solid，虚线:dashed
  strokeStyle: {
    type: String,
    validator: (value) => {
      return ["solid", "dashed"].indexOf(value) !== -1;
    }
  },
  // 勾勒形状轮廓的虚线和间隙的样式，此属性在strokeStyle 为dashed 时有效， 此属性在ie9+浏览器有效 取值： 实线： [0,0,0] 虚线： [10,10] ， [10,10] 表示10个像素的实线和10个像素的空白（如此反复）组成的虚线 点画线： [10,2,10] ， [10,2,10] 表示10个像素的实线和2个像素的空白 + 10个像素的实线和10个像素的空白 （如此反复）组成的虚线
  strokeDasharray: {
    type: Array
  },
  // 折线拐点的绘制样式，默认值为'miter'尖角，其他可选值：'round'圆角、'bevel'斜角
  lineJoin: {
    type: String,
    validator: (value) => {
      return ["miter", "round", "bevel"].indexOf(value) !== -1;
    }
  },
  // 折线两端线帽的绘制样式，默认值为'butt'无头，其他可选值：'round'圆头、'square'方头
  lineCap: {
    type: String,
    validator: (value) => {
      return ["butt", "round", "square"].indexOf(value) !== -1;
    }
  },
  // 是否绘制成大地线，默认false
  geodesic: {
    type: Boolean,
    default: false
  },
  // 是否延路径显示白色方向箭头,默认false。建议折线宽度大于6时使用,
  showDir: {
    type: Boolean,
    default: false
  },
  editable: {
    type: Boolean,
    default: false
  },
  editOptions: {
    type: Object
  }
});

var script$8 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapPolyline",
    inheritAttrs: false
  },
  __name: "Polyline",
  props: propsTypes$2,
  emits: ["init", "update:path"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let destroying = false;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Polyline(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        } else if (isVectorLayerInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __zIndex(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ zIndex: value });
          }
        },
        __strokeColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeColor: value });
          }
        },
        __strokeOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeOpacity: value });
          }
        },
        __strokeWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeWeight: value });
          }
        },
        __borderWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ borderWeight: value });
          }
        },
        __isOutline(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ isOutline: value });
          }
        },
        __outlineColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ outlineColor: value });
          }
        },
        __strokeStyle(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeStyle: value });
          }
        },
        __strokeDasharray(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeDasharray: value });
          }
        },
        __lineJoin(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ lineJoin: value });
          }
        },
        __lineCap(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ lineCap: value });
          }
        },
        __geodesic(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ geodesic: value });
          }
        },
        __showDir(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ showDir: value });
          }
        },
        __editable(flag) {
          createEditor().then(() => {
            flag ? resetEditor() : editor.close();
          });
        },
        __path(path) {
          if ($amapComponent) {
            $amapComponent.setPath(path);
            resetEditor();
          }
        }
      },
      destroyComponent() {
        destroying = true;
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (editor) {
            if (!parentInstance.isDestroy) {
              editor.close();
            }
            editor = null;
          }
          if (!parentInstance.isDestroy) {
            if (isMapInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            } else if (isOverlayGroupInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.removeOverlay($amapComponent);
            } else if (isVectorLayerInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            }
          }
          if ($amapComponent.destroy) {
            $amapComponent.destroy();
          }
          $amapComponent = null;
        }
      }
    });
    const resetEditor = debounce(() => {
      if (editor && props.editable) {
        editor.close();
        editor.setTarget();
        editor.setTarget($amapComponent);
        editor.open();
      }
    }, 50);
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitModel($amapComponent);
      });
      $amapComponent.on("touchend", () => {
        emitModel($amapComponent);
      });
    };
    const emitModel = (target) => {
      if (destroying) {
        return;
      }
      const paths = target.getPath();
      const pathArray = paths == null ? void 0 : paths.map(convertLnglat);
      emits("update:path", pathArray);
    };
    let editor;
    const attrs = useAttrs();
    const createEditor = () => {
      return new Promise((resolve) => {
        if (editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.PolylineEditor"], () => {
            editor = new AMap.PolylineEditor(parentInstance == null ? void 0 : parentInstance.$amapComponent, $amapComponent, props.editOptions);
            useEditor(editor, attrs);
            bindEditorModelEvents();
            resolve();
          });
        }
      });
    };
    const bindEditorModelEvents = () => {
      editor.on("addnode", (e) => {
        emitModel(e.target);
      });
      editor.on("adjust", (e) => {
        emitModel(e.target);
      });
      editor.on("removenode", (e) => {
        emitModel(e.target);
      });
      editor.on("add", (e) => {
        emitModel(e.target);
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$8.__file = "src/vue-amap/packages/vector/Polyline/Polyline.vue";

script$8.install = (app) => {
  app.component(script$8.name, script$8);
  return app;
};
const ElAmapPolyline = script$8;

const propsTypes$1 = buildProps({
  // 矩形的范围
  bounds: {
    type: Array,
    required: true
  },
  // 是否将覆盖物的鼠标或touch等事件冒泡到地图上
  bubble: {
    type: Boolean,
    default: false
  },
  // 指定鼠标悬停时的鼠标样式，自定义cursor，IE仅支持cur/ani/ico格式，Opera不支持自定义cursor
  cursor: {
    type: String
  },
  // 线条颜色，使用16进制颜色代码赋值。默认值为#00D3FC
  strokeColor: {
    type: String
  },
  // 轮廓线透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.9
  strokeOpacity: {
    type: Number
  },
  // 轮廓线宽度。默认 2
  strokeWeight: {
    type: Number
  },
  // 多边形填充颜色，使用16进制颜色代码赋值，如：#00B2D5
  fillColor: {
    type: String
  },
  // 多边形填充透明度，取值范围 [0,1] ，0表示完全透明，1表示不透明。默认为0.5
  fillOpacity: {
    type: Number
  },
  // 设置多边形是否可拖拽移动，默认为false
  draggable: {
    type: Boolean,
    default: false
  },
  extData: {
    type: Object,
    default: () => null
  },
  // 轮廓线样式，实线:solid，虚线:dashed
  strokeStyle: {
    type: String,
    validator: (value) => {
      return ["solid", "dashed"].indexOf(value) !== -1;
    }
  },
  // 勾勒形状轮廓的虚线和间隙的样式，此属性在strokeStyle 为dashed 时有效， 此属性在ie9+浏览器有效 取值： 实线： [0,0,0] 虚线： [10,10] ， [10,10] 表示10个像素的实线和10个像素的空白（如此反复）组成的虚线 点画线： [10,2,10] ， [10,2,10] 表示10个像素的实线和2个像素的空白 + 10个像素的实线和10个像素的空白 （如此反复）组成的虚线
  strokeDasharray: {
    type: Array
  },
  editable: {
    type: Boolean,
    default: false
  },
  editOptions: {
    type: Object
  }
});

var script$7 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapRectangle",
    inheritAttrs: false
  },
  __name: "Rectangle",
  props: propsTypes$1,
  emits: ["init", "update:bounds"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let destroying = false;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.Rectangle(options);
        if (isMapInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        } else if (isOverlayGroupInstance(parentComponent)) {
          parentComponent.addOverlay($amapComponent);
        } else if (isVectorLayerInstance(parentComponent)) {
          parentComponent.add($amapComponent);
        }
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      converts: {
        bounds: (path) => {
          return new AMap.Bounds(toLngLat(path[0]), toLngLat(path[1]));
        }
      },
      watchRedirectFn: {
        __zIndex(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ zIndex: value });
          }
        },
        __strokeColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeColor: value });
          }
        },
        __strokeOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeOpacity: value });
          }
        },
        __strokeWeight(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeWeight: value });
          }
        },
        __fillColor(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillColor: value });
          }
        },
        __fillOpacity(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ fillOpacity: value });
          }
        },
        __strokeStyle(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeStyle: value });
          }
        },
        __strokeDasharray(value) {
          if ($amapComponent) {
            $amapComponent.setOptions({ strokeDasharray: value });
          }
        },
        __editable(flag) {
          createEditor().then(() => {
            flag ? resetEditor() : editor.close();
          });
        },
        __bounds(bounds) {
          if ($amapComponent) {
            $amapComponent.setBounds(bounds);
            resetEditor();
          }
        }
      },
      destroyComponent() {
        destroying = true;
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (editor) {
            if (!parentInstance.isDestroy) {
              editor.close();
            }
            editor = null;
          }
          if (!parentInstance.isDestroy) {
            if (isMapInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            } else if (isOverlayGroupInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.removeOverlay($amapComponent);
            } else if (isVectorLayerInstance(parentInstance.$amapComponent)) {
              parentInstance.$amapComponent.remove($amapComponent);
            }
          }
          if ($amapComponent.destroy) {
            $amapComponent.destroy();
          }
          $amapComponent = null;
        }
      }
    });
    const resetEditor = debounce(() => {
      if (editor && props.editable) {
        editor.close();
        editor.setTarget();
        editor.setTarget($amapComponent);
        editor.open();
      }
    }, 50);
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitModel($amapComponent);
      });
      $amapComponent.on("touchend", () => {
        emitModel($amapComponent);
      });
    };
    const emitModel = (target) => {
      if (destroying) {
        return;
      }
      const bounds = target.getBounds();
      const southWest = bounds.getSouthWest();
      const northEast = bounds.getNorthEast();
      const paths = [southWest.toArray(), northEast.toArray()];
      emits("update:bounds", paths);
    };
    let editor;
    const attrs = useAttrs();
    const createEditor = () => {
      return new Promise((resolve) => {
        if (editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.RectangleEditor"], () => {
            editor = new AMap.RectangleEditor(parentInstance == null ? void 0 : parentInstance.$amapComponent, $amapComponent, props.editOptions);
            useEditor(editor, attrs);
            bindEditorModelEvents();
            resolve();
          });
        }
      });
    };
    const bindEditorModelEvents = () => {
      editor.on("addnode", (e) => {
        emitModel(e.target);
      });
      editor.on("adjust", (e) => {
        emitModel(e.target);
      });
      editor.on("removenode", (e) => {
        emitModel(e.target);
      });
      editor.on("add", (e) => {
        emitModel(e.target);
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$7.__file = "src/vue-amap/packages/vector/Rectangle/Rectangle.vue";

script$7.install = (app) => {
  app.component(script$7.name, script$7);
  return app;
};
const ElAmapRectangle = script$7;

var script$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerTiles3d",
    inheritAttrs: false
  },
  __name: "Tiles3D",
  props: buildProps({
    url: {
      type: String,
      required: true
    },
    threeScriptUrl: {
      type: String,
      default: "//a.amap.com/jsapi_demos/static/data3d/lib/three.117.js"
    },
    threeGltfLoader: {
      type: String,
      default: "//a.amap.com/jsapi_demos/static/data3d/lib/GLTFLoader.117.min.js"
    },
    layerStyle: {
      type: Object
    }
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.3DTilesLayer"], () => {
          if (!window["THREE"]) {
            loadScript(options.threeScriptUrl, () => {
              loadScript(options.threeGltfLoader, () => {
                createLayer(options);
                resolve($amapComponent);
              });
            });
          } else {
            createLayer(options);
            resolve($amapComponent);
          }
        });
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent) {
          $amapComponent = null;
        }
      }
    });
    const createLayer = (options) => {
      let layerStyle = {};
      if (options.layerStyle) {
        layerStyle = JSON.parse(JSON.stringify(options.layerStyle));
      }
      $amapComponent = new AMap["3DTilesLayer"]({
        map: parentInstance == null ? void 0 : parentInstance.$amapComponent,
        url: options.url,
        // 3d Tiles 入口文件
        style: layerStyle
      });
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$6.__file = "src/vue-amap/packages/layer/data/Tiles3D/Tiles3D.vue";

script$6.install = (app) => {
  app.component(script$6.name, script$6);
  return app;
};
const ElAmapLayerTiles3d = script$6;

const propsType = buildProps({
  //悬停位置，默认为"RB"，即右下角.'LT': 左上角, 'RT': 右上角, 'LB': 左下角, 'RB': 右下角
  position: {
    type: String
  },
  //缩略图距离悬停位置的像素距离，如 [2,2]
  offset: {
    type: Array
  },
  //按钮边框颜色值，同CSS，如'silver'
  borderColor: {
    type: String
  },
  borderRadius: {
    type: String
  },
  //按钮圆角边框值，同CSS，如'5px'
  buttonSize: {
    type: String
  },
  //箭头按钮的像素尺寸，同CSS，如'12px'
  convert: {
    type: Boolean,
    default: true
  },
  //是否将定位结果转换为高德坐标
  enableHighAccuracy: {
    type: Boolean,
    default: false
  },
  //进行浏览器原生定位的时候是否尝试获取较高精度，可能影响定位效率，默认为false
  timeout: {
    type: Number
  },
  //定位的超时时间，毫秒
  maximumAge: {
    type: Number
  },
  //浏览器原生定位的缓存时间，毫秒
  showButton: {
    type: Boolean,
    default: true
  },
  //是否显示定位按钮，默认为true
  showCircle: {
    type: Boolean,
    default: true
  },
  //是否显示定位精度圆，默认为true
  showMarker: {
    type: Boolean,
    default: true
  },
  //是否显示定位点，默认为true
  markerOptions: {
    type: Object
  },
  //定位点的样式
  circleOptions: {
    type: Object
  },
  //CircleOptions
  panToLocation: {
    type: Boolean,
    default: true
  },
  //定位成功后是否自动移动到响应位置
  zoomToAccuracy: {
    type: Boolean,
    default: true
  },
  //定位成功后是否自动调整级别
  GeoLocationFirst: {
    type: Boolean,
    default: true
  },
  //优先使用H5定位，默认false
  noIpLocate: {
    type: Number
  },
  //是否禁用IP精确定位，默认为0，0:都用 1:手机上不用 2:PC上不用 3:都不用
  noGeoLocation: {
    type: Number
  },
  //是否禁用浏览器原生定位，默认为0，0:都用 1:手机上不用 2:PC上不用 3:都不用
  useNative: {
    type: Boolean,
    default: false
  },
  //是否与高德定位SDK能力结合，需要同时使用安卓版高德定位sdk，否则无效
  getCityWhenFail: {
    type: Boolean,
    default: false
  },
  //定位失败之后是否返回基本城市定位信息
  needAddress: {
    type: Boolean,
    default: false
  },
  //是否需要将定位结果进行逆地理编码操作
  extensions: {
    type: String,
    validator: (value) => {
      return ["base", "all"].indexOf(value) !== -1;
    }
  }
  //是否需要详细的逆地理编码信息，默认为'base'只返回基本信息，可选'all'
});

var script$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapControlGeolocation",
    inheritAttrs: false
  },
  __name: "Geolocation",
  props: propsType,
  emits: ["init", "complete"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const emitComplete = (e) => {
      emits("complete", e);
    };
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        parentComponent.plugin(["AMap.Geolocation"], () => {
          $amapComponent = new AMap.Geolocation(options);
          parentComponent.addControl($amapComponent);
          $amapComponent.on("complete", emitComplete);
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      destroyComponent() {
        $amapComponent.off("complete", emitComplete);
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeControl($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return null;
    };
  }
});

script$5.__file = "src/vue-amap/packages/control/Geolocation/Geolocation.vue";

script$5.install = (app) => {
  app.component(script$5.name, script$5);
  return app;
};
const ElAmapControlGeolocation = script$5;

var script$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapCircleMarker",
    inheritAttrs: false
  },
  __name: "CircleMarker",
  props: buildProps({
    zIndex: {
      type: Number
    },
    center: {
      type: Array,
      required: true
    },
    bubble: {
      type: Boolean,
      default: false
    },
    cursor: {
      type: String
    },
    radius: {
      type: Number
    },
    strokeColor: {
      type: String
    },
    strokeOpacity: {
      type: Number
    },
    strokeWeight: {
      type: Number
    },
    fillColor: {
      type: String
    },
    fillOpacity: {
      type: Number
    },
    draggable: {
      type: Boolean,
      default: false
    },
    extData: {
      type: Object
    }
  }),
  emits: ["init", "update:center"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new AMap.CircleMarker(options);
        parentComponent.add($amapComponent);
        bindModelEvents();
        resolve($amapComponent);
      });
    }, {
      emits,
      watchRedirectFn: {
        __strokeColor(value) {
          $amapComponent.setOptions({
            strokeColor: value
          });
        },
        __strokeOpacity(value) {
          $amapComponent.setOptions({
            strokeOpacity: value
          });
        },
        __strokeWeight(value) {
          $amapComponent.setOptions({
            strokeWeight: value
          });
        },
        __fillColor(value) {
          $amapComponent.setOptions({
            fillColor: value
          });
        },
        __fillOpacity(value) {
          $amapComponent.setOptions({
            fillOpacity: value
          });
        }
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            parentInstance == null ? void 0 : parentInstance.$amapComponent.remove($amapComponent);
          }
          $amapComponent = null;
        }
      }
    });
    const bindModelEvents = () => {
      $amapComponent.on("dragend", () => {
        emitPosition();
      });
      $amapComponent.on("touchend", () => {
        emitPosition();
      });
    };
    const emitPosition = () => {
      const center = $amapComponent.getCenter();
      emits("update:center", center.toArray());
    };
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$4.__file = "src/vue-amap/packages/marker/CircleMarker/CircleMarker.vue";

script$4.install = (app) => {
  app.component(script$4.name, script$4);
  return app;
};
const ElAmapCircleMarker = script$4;

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class VideoLayer {
  constructor(options, video) {
    __publicField(this, "canvas");
    __publicField(this, "context");
    __publicField(this, "video");
    __publicField(this, "layer");
    __publicField(this, "canPlay", false);
    __publicField(this, "frame", -1);
    const canvas = document.createElement("canvas");
    this.video = video;
    video.src = options.url;
    video.autoplay = true;
    video.muted = true;
    video.crossOrigin = "anonymous";
    video.loop = options.loop;
    const layerOptions = {
      ...options,
      canvas
    };
    this.canvas = canvas;
    this.context = canvas.getContext("2d");
    this.layer = new AMap.CanvasLayer(layerOptions);
    this.initVideoEvents();
    this.load();
  }
  getLayer() {
    return this.layer;
  }
  initVideoEvents() {
    var _a;
    (_a = this.video) == null ? void 0 : _a.addEventListener("canplaythrough", () => {
      var _a2, _b;
      if (this.canvas) {
        this.canvas.width = (_a2 = this.video) == null ? void 0 : _a2.videoWidth;
        this.canvas.height = (_b = this.video) == null ? void 0 : _b.videoHeight;
      }
      this.canPlay = true;
      this.play();
    });
  }
  load() {
    var _a;
    (_a = this.video) == null ? void 0 : _a.load();
  }
  play() {
    var _a;
    if (this.canPlay) {
      (_a = this.video) == null ? void 0 : _a.play();
      this.stopRender();
      this.render();
    }
  }
  pause() {
    var _a;
    this.stopRender();
    (_a = this.video) == null ? void 0 : _a.pause();
  }
  stopRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
    }
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.frame = window.requestAnimationFrame(() => {
      this.render();
    });
    if ((_a = this.video) == null ? void 0 : _a.paused) {
      (_b = this.video) == null ? void 0 : _b.play();
    } else {
      (_e = this.context) == null ? void 0 : _e.clearRect(0, 0, (_c = this.canvas) == null ? void 0 : _c.width, (_d = this.canvas) == null ? void 0 : _d.height);
      (_h = this.context) == null ? void 0 : _h.drawImage(this.video, 0, 0, (_f = this.canvas) == null ? void 0 : _f.width, (_g = this.canvas) == null ? void 0 : _g.height);
      this.layer.reFresh();
    }
  }
  destroy() {
    this.stopRender();
    if (this.video) {
      this.video.pause();
    }
    this.video = null;
  }
  setUrl(url) {
    this.stopRender();
    this.canPlay = false;
    if (this.video) {
      this.video.src = url;
      this.load();
    }
  }
  setZooms(zooms) {
    this.getLayer().setZoom(zooms);
  }
  setOpacity(opacity) {
    this.getLayer().setOpacity(opacity);
  }
  setBounds(bounds) {
    this.getLayer().setBounds(bounds);
  }
  setzIndex(zIndex) {
    this.getLayer().setzIndex(zIndex);
  }
  show() {
    this.getLayer().show();
  }
  hide() {
    this.getLayer().hide();
  }
}

var script$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerVideo",
    inheritAttrs: false
  },
  __name: "Video",
  props: buildProps({
    url: {
      required: true,
      type: String
    },
    // 视频地址
    zooms: {
      type: Array
    },
    // 支持的缩放级别范围，默认范围 [2-30]
    bounds: {
      type: [Array, Object]
    },
    // 图片的范围大小经纬度，如果传递数字数组类型: [minlng,minlat,maxlng,maxlat] 或 AMap.Bounds
    opacity: {
      type: Number
    }
    // 透明度，默认 1
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const videoRef = ref();
    let $amapComponent;
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new VideoLayer(options, videoRef.value);
        parentComponent.addLayer($amapComponent.getLayer());
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            $amapComponent.destroy();
            parentInstance == null ? void 0 : parentInstance.$amapComponent.removeLayer($amapComponent.getLayer());
          }
          $amapComponent = null;
        }
      }
    });
    const $$play = () => {
      $amapComponent.play();
    };
    const $$pause = () => {
      $amapComponent.pause();
    };
    __expose({
      $$getInstance,
      $$play,
      $$pause
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "video",
        {
          ref_key: "videoRef",
          ref: videoRef,
          style: { "display": "none" },
          muted: ""
        },
        null,
        512
        /* NEED_PATCH */
      );
    };
  }
});

script$3.__file = "src/vue-amap/packages/layer/data/Video/Video.vue";

script$3.install = (app) => {
  app.component(script$3.name, script$3);
  return app;
};
const ElAmapLayerVideo = script$3;

var script$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapMouseTool",
    inheritAttrs: false
  },
  __name: "MouseTool",
  props: buildProps({
    type: {
      type: String,
      required: true,
      default: "marker",
      validator: (value) => {
        return ["marker", "circle", "rectangle", "polyline", "polygon", "measureArea", "rule", "rectZoomIn", "rectZoomOut"].includes(value);
      }
    },
    // 类型
    drawOptions: {
      type: Object,
      default: () => null
    },
    // 绘制图层的属性
    autoClear: {
      type: Boolean,
      default: true
    },
    // 是否绘制结束后自动清空图层
    showTooltip: {
      type: Boolean,
      default: true
    },
    // 是否显示提示信息
    tooltipTextMap: {
      type: Object,
      default: () => null
    },
    // 提示信息的map
    textOptions: {
      type: Object,
      default: () => null
    },
    drawCursor: {
      type: String,
      default: "crosshair"
    }
  }),
  emits: ["init", "draw"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    let $amapComponent;
    let preMapCursor = "";
    const tipTexts = {
      marker: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u70B9\u4F4D",
      circle: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u5706",
      rectangle: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62",
      polyline: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u6298\u7EBF\u7ED8\u5236",
      polygon: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u591A\u8FB9\u5F62\u7ED8\u5236",
      measureArea: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u7ED8\u5236\u5E76\u8BA1\u7B97\u9762\u79EF",
      rule: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53F3\u51FB\u5730\u56FE\u5B8C\u6210\u7ED8\u5236\u5E76\u8BA1\u7B97\u8DDD\u79BB",
      rectZoomIn: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62\uFF0C\u677E\u5F00\u5DE6\u952E\u653E\u5927\u5730\u56FE",
      rectZoomOut: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62\uFF0C\u677E\u5F00\u5DE6\u952E\u653E\u5927\u5730\u56FE"
    };
    let isDrawing = true;
    const __type = () => {
      if (!isDrawing) {
        return;
      }
      const type = props.type;
      if ($amapComponent[type]) {
        const options = props.drawOptions || {};
        $amapComponent[type](options);
        setText(tipTexts[type]);
      }
    };
    const { $$getInstance, parentInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MouseTool"], () => {
          if (props.tooltipTextMap) {
            Object.assign(tipTexts, props.tooltipTextMap);
          }
          $amapComponent = new AMap.MouseTool(parentComponent);
          preMapCursor = parentComponent.getDefaultCursor();
          createTooltip();
          __type();
          bindEvent();
          changeMapCursor();
          resolve($amapComponent);
        });
      });
    }, {
      emits,
      watchRedirectFn: {
        __type
      },
      destroyComponent() {
        if ($amapComponent && (parentInstance == null ? void 0 : parentInstance.$amapComponent)) {
          if (!(parentInstance == null ? void 0 : parentInstance.isDestroy)) {
            $amapComponent.close(true);
            revertMapCursor();
            if ($text) {
              parentInstance.$amapComponent.off("mousemove", getMousePosition);
              parentInstance.$amapComponent.remove($text);
              $text = null;
            }
          }
          $amapComponent = null;
        }
      }
    });
    let $text;
    const createTooltip = () => {
      if (props.showTooltip) {
        const textOptions = props.textOptions || {};
        textOptions.anchor = "top-left";
        textOptions.clickable = false;
        textOptions.bubble = true;
        textOptions.offset = [10, 10];
        $text = new AMap.Text(textOptions);
        parentInstance == null ? void 0 : parentInstance.$amapComponent.add($text);
        parentInstance == null ? void 0 : parentInstance.$amapComponent.on("mousemove", getMousePosition);
      }
    };
    const getMousePosition = (e) => {
      const lnglat = e.lnglat;
      $text.setPosition([lnglat.lng, lnglat.lat]);
    };
    const setText = (content) => {
      if ($text) {
        $text.setText(content);
      }
    };
    const bindEvent = () => {
      $amapComponent.on("draw", (e) => {
        const type = props.type;
        let emitData;
        if (type === "marker") {
          emitData = e.obj.getPosition().toArray();
        } else if (type === "circle") {
          emitData = {
            center: e.obj.getCenter().toArray(),
            radius: e.obj.getRadius()
          };
        } else if (type === "rectangle") {
          const bounds = e.obj.getBounds();
          const southWest = bounds.getSouthWest();
          const northEast = bounds.getNorthEast();
          emitData = [southWest.toArray(), northEast.toArray()];
        } else if (type === "polyline") {
          const path = e.obj.getPath();
          emitData = path.map((v) => v.toArray());
        } else if (type === "polygon") {
          const path = e.obj.getPath();
          emitData = path.map((v) => v.toArray());
        } else if (type === "measureArea") {
          const path = e.obj.getPath().map((v) => v.toArray());
          emitData = AMap.GeometryUtil.ringArea(path);
        } else if (type === "rule") {
          const path = e.obj.getPath().map((v) => v.toArray());
          emitData = AMap.GeometryUtil.distanceOfLine(path);
        } else if (type === "rectZoomIn") {
          emitData = true;
        } else if (type === "rectZoomOut") {
          emitData = true;
        }
        emits("draw", emitData, e.obj);
        if (props.autoClear) {
          $$clear();
          __type();
        }
      });
    };
    const _close = (ifClear = true) => {
      $amapComponent.close(ifClear);
    };
    const $$close = (ifClear = true) => {
      isDrawing = false;
      if ($amapComponent) {
        _close(ifClear);
        revertMapCursor();
        if ($text) {
          $text.hide();
        }
      }
    };
    const $$open = () => {
      isDrawing = true;
      changeMapCursor();
      __type();
      if ($text) {
        $text.show();
      }
    };
    const $$clear = () => {
      _close(true);
    };
    const changeMapCursor = () => {
      parentInstance == null ? void 0 : parentInstance.$amapComponent.setDefaultCursor(props.drawCursor);
    };
    const revertMapCursor = () => {
      if (preMapCursor) {
        parentInstance == null ? void 0 : parentInstance.$amapComponent.setDefaultCursor(preMapCursor);
      }
    };
    __expose({
      $$getInstance,
      $$open,
      $$close,
      $$clear
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$2.__file = "src/vue-amap/packages/util/MouseTool/MouseTool.vue";

script$2.install = (app) => {
  app.component(script$2.name, script$2);
  return app;
};
const ElAmapMouseTool = script$2;

if (typeof process !== "undefined" && typeof process.env === "undefined") {
  process.env = {};
}

let Y$1 = class Y{constructor(){this._listeners={};}on(t,e,r){this._listeners[t]?this._listeners[t].push({callback:e,isOnce:r}):this._listeners[t]=[{callback:e,isOnce:r}];}off(t,e){if(!e)throw new Error("\u53D6\u6D88\u4E8B\u4EF6\u65F6\u9700\u8981\u4F20\u5165\u539F\u56DE\u8C03\u51FD\u6570");const r=this._listeners[t];if(r&&r.length>0){for(let i=0;i<r.length;i++)if(r[i].callback===e){r.splice(i,1);break}}}emit(t,...e){const r=this._listeners[t];if(r&&r.length>0)for(let n=0;n<r.length;n++){const s=r[n];s.callback.call(this,...e),s.isOnce&&(r.splice(n,1),n--);}const i=this._listeners["*"];if(i&&i.length>0)for(let n=0;n<i.length;n++){const s=i[n];s.callback.call(this,t,...e),s.isOnce&&(i.splice(n,1),n--);}}trigger(t,...e){this.emit(t,e);}};function dt$1(o,t,e){e===void 0&&(e={});var r={type:"Feature"};return (e.id===0||e.id)&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.properties=t||{},r.geometry=o,r}function H$1(o,t,e){e===void 0&&(e={});for(var r=0,i=o;r<i.length;r++){var n=i[r];if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var s=0;s<n[n.length-1].length;s++)if(n[n.length-1][s]!==n[0][s])throw new Error("First and last Position are not equivalent.")}var a={type:"Polygon",coordinates:o};return dt$1(a,t,e)}function Bt$1(o,t,e){e===void 0&&(e={});var r={type:"MultiPolygon",coordinates:o};return dt$1(r,t,e)}function ft$1(o){return o.type==="Feature"?o.geometry:o}/**
 * splaytree v3.1.1
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function $t$1(o,t){var e={label:0,sent:function(){if(n[0]&1)throw n[1];return n[1]},trys:[],ops:[]},r,i,n,s;return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(h){return u([l,h])}}function u(l){if(r)throw new TypeError("Generator is already executing.");for(;e;)try{if(r=1,i&&(n=l[0]&2?i.return:l[0]?i.throw||((n=i.return)&&n.call(i),0):i.next)&&!(n=n.call(i,l[1])).done)return n;switch(i=0,n&&(l=[l[0]&2,n.value]),l[0]){case 0:case 1:n=l;break;case 4:return e.label++,{value:l[1],done:!1};case 5:e.label++,i=l[1],l=[0];continue;case 7:l=e.ops.pop(),e.trys.pop();continue;default:if(n=e.trys,!(n=n.length>0&&n[n.length-1])&&(l[0]===6||l[0]===2)){e=0;continue}if(l[0]===3&&(!n||l[1]>n[0]&&l[1]<n[3])){e.label=l[1];break}if(l[0]===6&&e.label<n[1]){e.label=n[1],n=l;break}if(n&&e.label<n[2]){e.label=n[2],e.ops.push(l);break}n[2]&&e.ops.pop(),e.trys.pop();continue}l=t.call(o,e);}catch(h){l=[6,h],i=0;}finally{r=n=0;}if(l[0]&5)throw l[1];return {value:l[0]?l[1]:void 0,done:!0}}}var A=function(){function o(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null;}return o}();function zt$1(o,t){return o>t?1:o<t?-1:0}function P(o,t,e){for(var r=new A(null,null),i=r,n=r;;){var s=e(o,t.key);if(s<0){if(t.left===null)break;if(e(o,t.left.key)<0){var a=t.left;if(t.left=a.right,a.right=t,t=a,t.left===null)break}n.left=t,n=t,t=t.left;}else if(s>0){if(t.right===null)break;if(e(o,t.right.key)>0){var a=t.right;if(t.right=a.left,a.left=t,t=a,t.right===null)break}i.right=t,i=t,t=t.right;}else break}return i.right=t.left,n.left=t.right,t.left=r.right,t.right=r.left,t}function X$1(o,t,e,r){var i=new A(o,t);if(e===null)return i.left=i.right=null,i;e=P(o,e,r);var n=r(o,e.key);return n<0?(i.left=e.left,i.right=e,e.left=null):n>=0&&(i.right=e.right,i.left=e,e.right=null),i}function pt$1(o,t,e){var r=null,i=null;if(t){t=P(o,t,e);var n=e(t.key,o);n===0?(r=t.left,i=t.right):n<0?(i=t.right,t.right=null,r=t):(r=t.left,t.left=null,i=t);}return {left:r,right:i}}function Gt$1(o,t,e){return t===null?o:(o===null||(t=P(o.key,t,e),t.left=o),t)}function Q$1(o,t,e,r,i){if(o){r(""+t+(e?"\u2514\u2500\u2500 ":"\u251C\u2500\u2500 ")+i(o)+`
`);var n=t+(e?"    ":"\u2502   ");o.left&&Q$1(o.left,n,!1,r,i),o.right&&Q$1(o.right,n,!0,r,i);}}var J$1=function(){function o(t){t===void 0&&(t=zt$1),this._root=null,this._size=0,this._comparator=t;}return o.prototype.insert=function(t,e){return this._size++,this._root=X$1(t,e,this._root,this._comparator)},o.prototype.add=function(t,e){var r=new A(t,e);this._root===null&&(r.left=r.right=null,this._size++,this._root=r);var i=this._comparator,n=P(t,this._root,i),s=i(t,n.key);return s===0?this._root=n:(s<0?(r.left=n.left,r.right=n,n.left=null):s>0&&(r.right=n.right,r.left=n,n.right=null),this._size++,this._root=r),this._root},o.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator);},o.prototype._remove=function(t,e,r){var i;if(e===null)return null;e=P(t,e,r);var n=r(t,e.key);return n===0?(e.left===null?i=e.right:(i=P(t,e.left,r),i.right=e.right),this._size--,i):e},o.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=P(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},o.prototype.findStatic=function(t){for(var e=this._root,r=this._comparator;e;){var i=r(t,e.key);if(i===0)return e;i<0?e=e.left:e=e.right;}return null},o.prototype.find=function(t){return this._root&&(this._root=P(t,this._root,this._comparator),this._comparator(t,this._root.key)!==0)?null:this._root},o.prototype.contains=function(t){for(var e=this._root,r=this._comparator;e;){var i=r(t,e.key);if(i===0)return !0;i<0?e=e.left:e=e.right;}return !1},o.prototype.forEach=function(t,e){for(var r=this._root,i=[],n=!1;!n;)r!==null?(i.push(r),r=r.left):i.length!==0?(r=i.pop(),t.call(e,r),r=r.right):n=!0;return this},o.prototype.range=function(t,e,r,i){for(var n=[],s=this._comparator,a=this._root,u;n.length!==0||a;)if(a)n.push(a),a=a.left;else {if(a=n.pop(),u=s(a.key,e),u>0)break;if(s(a.key,t)>=0&&r.call(i,a))return this;a=a.right;}return this},o.prototype.keys=function(){var t=[];return this.forEach(function(e){var r=e.key;return t.push(r)}),t},o.prototype.values=function(){var t=[];return this.forEach(function(e){var r=e.data;return t.push(r)}),t},o.prototype.min=function(){return this._root?this.minNode(this._root).key:null},o.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},o.prototype.minNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.left;)t=t.left;return t},o.prototype.maxNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.right;)t=t.right;return t},o.prototype.at=function(t){for(var e=this._root,r=!1,i=0,n=[];!r;)if(e)n.push(e),e=e.left;else if(n.length>0){if(e=n.pop(),i===t)return e;i++,e=e.right;}else r=!0;return null},o.prototype.next=function(t){var e=this._root,r=null;if(t.right){for(r=t.right;r.left;)r=r.left;return r}for(var i=this._comparator;e;){var n=i(t.key,e.key);if(n===0)break;n<0?(r=e,e=e.left):e=e.right;}return r},o.prototype.prev=function(t){var e=this._root,r=null;if(t.left!==null){for(r=t.left;r.right;)r=r.right;return r}for(var i=this._comparator;e;){var n=i(t.key,e.key);if(n===0)break;n<0?e=e.left:(r=e,e=e.right);}return r},o.prototype.clear=function(){return this._root=null,this._size=0,this},o.prototype.toList=function(){return Vt$1(this._root)},o.prototype.load=function(t,e,r){e===void 0&&(e=[]),r===void 0&&(r=!1);var i=t.length,n=this._comparator;if(r&&et$1(t,e,0,i-1,n),this._root===null)this._root=K$1(t,e,0,i),this._size=i;else {var s=qt$1(this.toList(),Zt$1(t,e),n);i=this._size+i,this._root=tt$1({head:s},0,i);}return this},o.prototype.isEmpty=function(){return this._root===null},Object.defineProperty(o.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(o.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),o.prototype.toString=function(t){t===void 0&&(t=function(r){return String(r.key)});var e=[];return Q$1(this._root,"",!0,function(r){return e.push(r)},t),e.join("")},o.prototype.update=function(t,e,r){var i=this._comparator,n=pt$1(t,this._root,i),s=n.left,a=n.right;i(t,e)<0?a=X$1(e,r,a,i):s=X$1(e,r,s,i),this._root=Gt$1(s,a,i);},o.prototype.split=function(t){return pt$1(t,this._root,this._comparator)},o.prototype[Symbol.iterator]=function(){var t;return $t$1(this,function(e){switch(e.label){case 0:t=this.minNode(),e.label=1;case 1:return t?[4,t]:[3,3];case 2:return e.sent(),t=this.next(t),[3,1];case 3:return [2]}})},o}();function K$1(o,t,e,r){var i=r-e;if(i>0){var n=e+Math.floor(i/2),s=o[n],a=t[n],u=new A(s,a);return u.left=K$1(o,t,e,n),u.right=K$1(o,t,n+1,r),u}return null}function Zt$1(o,t){for(var e=new A(null,null),r=e,i=0;i<o.length;i++)r=r.next=new A(o[i],t[i]);return r.next=null,e.next}function Vt$1(o){for(var t=o,e=[],r=!1,i=new A(null,null),n=i;!r;)t?(e.push(t),t=t.left):e.length>0?(t=n=n.next=e.pop(),t=t.right):r=!0;return n.next=null,i.next}function tt$1(o,t,e){var r=e-t;if(r>0){var i=t+Math.floor(r/2),n=tt$1(o,t,i),s=o.head;return s.left=n,o.head=o.head.next,s.right=tt$1(o,i+1,e),s}return null}function qt$1(o,t,e){for(var r=new A(null,null),i=r,n=o,s=t;n!==null&&s!==null;)e(n.key,s.key)<0?(i.next=n,n=n.next):(i.next=s,s=s.next),i=i.next;return n!==null?i.next=n:s!==null&&(i.next=s),r.next}function et$1(o,t,e,r,i){if(!(e>=r)){for(var n=o[e+r>>1],s=e-1,a=r+1;;){do s++;while(i(o[s],n)<0);do a--;while(i(o[a],n)>0);if(s>=a)break;var u=o[s];o[s]=o[a],o[a]=u,u=t[s],t[s]=t[a],t[a]=u;}et$1(o,t,e,a,i),et$1(o,t,a+1,r,i);}}function S$1(o,t){if(!(o instanceof t))throw new TypeError("Cannot call a class as a function")}function gt$1(o,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(o,r.key,r);}}function b(o,t,e){return t&&gt$1(o.prototype,t),e&&gt$1(o,e),o}var z=function(t,e){return t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y},rt$1=function(t,e){if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;var r=t.ll.x<e.ll.x?e.ll.x:t.ll.x,i=t.ur.x<e.ur.x?t.ur.x:e.ur.x,n=t.ll.y<e.ll.y?e.ll.y:t.ll.y,s=t.ur.y<e.ur.y?t.ur.y:e.ur.y;return {ll:{x:r,y:n},ur:{x:i,y:s}}},N=Number.EPSILON;N===void 0&&(N=Math.pow(2,-52));var jt$1=N*N,it$1=function(t,e){if(-N<t&&t<N&&-N<e&&e<N)return 0;var r=t-e;return r*r<jt$1*t*e?0:t<e?-1:1},Ut$1=function(){function o(){S$1(this,o),this.reset();}return b(o,[{key:"reset",value:function(){this.xRounder=new yt$1,this.yRounder=new yt$1;}},{key:"round",value:function(e,r){return {x:this.xRounder.round(e),y:this.yRounder.round(r)}}}]),o}(),yt$1=function(){function o(){S$1(this,o),this.tree=new J$1,this.round(0);}return b(o,[{key:"round",value:function(e){var r=this.tree.add(e),i=this.tree.prev(r);if(i!==null&&it$1(r.key,i.key)===0)return this.tree.remove(e),i.key;var n=this.tree.next(r);return n!==null&&it$1(r.key,n.key)===0?(this.tree.remove(e),n.key):e}}]),o}(),G$1=new Ut$1,Z$1=function(t,e){return t.x*e.y-t.y*e.x},vt$1=function(t,e){return t.x*e.x+t.y*e.y},_t$1=function(t,e,r){var i={x:e.x-t.x,y:e.y-t.y},n={x:r.x-t.x,y:r.y-t.y},s=Z$1(i,n);return it$1(s,0)},V$1=function(t){return Math.sqrt(vt$1(t,t))},Wt$1=function(t,e,r){var i={x:e.x-t.x,y:e.y-t.y},n={x:r.x-t.x,y:r.y-t.y};return Z$1(n,i)/V$1(n)/V$1(i)},Yt$1=function(t,e,r){var i={x:e.x-t.x,y:e.y-t.y},n={x:r.x-t.x,y:r.y-t.y};return vt$1(n,i)/V$1(n)/V$1(i)},mt$1=function(t,e,r){return e.y===0?null:{x:t.x+e.x/e.y*(r-t.y),y:r}},xt$1=function(t,e,r){return e.x===0?null:{x:r,y:t.y+e.y/e.x*(r-t.x)}},Ht$1=function(t,e,r,i){if(e.x===0)return xt$1(r,i,t.x);if(i.x===0)return xt$1(t,e,r.x);if(e.y===0)return mt$1(r,i,t.y);if(i.y===0)return mt$1(t,e,r.y);var n=Z$1(e,i);if(n==0)return null;var s={x:r.x-t.x,y:r.y-t.y},a=Z$1(s,e)/n,u=Z$1(s,i)/n,l=t.x+u*e.x,h=r.x+a*i.x,c=t.y+u*e.y,d=r.y+a*i.y,f=(l+h)/2,g=(c+d)/2;return {x:f,y:g}},I$1=function(){b(o,null,[{key:"compare",value:function(e,r){var i=o.comparePoints(e.point,r.point);return i!==0?i:(e.point!==r.point&&e.link(r),e.isLeft!==r.isLeft?e.isLeft?1:-1:q.compare(e.segment,r.segment))}},{key:"comparePoints",value:function(e,r){return e.x<r.x?-1:e.x>r.x?1:e.y<r.y?-1:e.y>r.y?1:0}}]);function o(t,e){S$1(this,o),t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e;}return b(o,[{key:"link",value:function(e){if(e.point===this.point)throw new Error("Tried to link already linked events");for(var r=e.point.events,i=0,n=r.length;i<n;i++){var s=r[i];this.point.events.push(s),s.point=this.point;}this.checkForConsuming();}},{key:"checkForConsuming",value:function(){for(var e=this.point.events.length,r=0;r<e;r++){var i=this.point.events[r];if(i.segment.consumedBy===void 0)for(var n=r+1;n<e;n++){var s=this.point.events[n];s.consumedBy===void 0&&i.otherSE.point.events===s.otherSE.point.events&&i.segment.consume(s.segment);}}}},{key:"getAvailableLinkedEvents",value:function(){for(var e=[],r=0,i=this.point.events.length;r<i;r++){var n=this.point.events[r];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&e.push(n);}return e}},{key:"getLeftmostComparator",value:function(e){var r=this,i=new Map,n=function(a){var u=a.otherSE;i.set(a,{sine:Wt$1(r.point,e.point,u.point),cosine:Yt$1(r.point,e.point,u.point)});};return function(s,a){i.has(s)||n(s),i.has(a)||n(a);var u=i.get(s),l=u.sine,h=u.cosine,c=i.get(a),d=c.sine,f=c.cosine;return l>=0&&d>=0?h<f?1:h>f?-1:0:l<0&&d<0?h<f?-1:h>f?1:0:d<l?-1:d>l?1:0}}}]),o}(),Xt$1=0,q=function(){b(o,null,[{key:"compare",value:function(e,r){var i=e.leftSE.point.x,n=r.leftSE.point.x,s=e.rightSE.point.x,a=r.rightSE.point.x;if(a<i)return 1;if(s<n)return -1;var u=e.leftSE.point.y,l=r.leftSE.point.y,h=e.rightSE.point.y,c=r.rightSE.point.y;if(i<n){if(l<u&&l<h)return 1;if(l>u&&l>h)return -1;var d=e.comparePoint(r.leftSE.point);if(d<0)return 1;if(d>0)return -1;var f=r.comparePoint(e.rightSE.point);return f!==0?f:-1}if(i>n){if(u<l&&u<c)return -1;if(u>l&&u>c)return 1;var g=r.comparePoint(e.leftSE.point);if(g!==0)return g;var p=e.comparePoint(r.rightSE.point);return p<0?1:p>0?-1:1}if(u<l)return -1;if(u>l)return 1;if(s<a){var y=r.comparePoint(e.rightSE.point);if(y!==0)return y}if(s>a){var m=e.comparePoint(r.rightSE.point);if(m<0)return 1;if(m>0)return -1}if(s!==a){var x=h-u,w=s-i,_=c-l,k=a-n;if(x>w&&_<k)return 1;if(x<w&&_>k)return -1}return s>a?1:s<a||h<c?-1:h>c?1:e.id<r.id?-1:e.id>r.id?1:0}}]);function o(t,e,r,i){S$1(this,o),this.id=++Xt$1,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=r,this.windings=i;}return b(o,[{key:"replaceRightSE",value:function(e){this.rightSE=e,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE;}},{key:"bbox",value:function(){var e=this.leftSE.point.y,r=this.rightSE.point.y;return {ll:{x:this.leftSE.point.x,y:e<r?e:r},ur:{x:this.rightSE.point.x,y:e>r?e:r}}}},{key:"vector",value:function(){return {x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}},{key:"isAnEndpoint",value:function(e){return e.x===this.leftSE.point.x&&e.y===this.leftSE.point.y||e.x===this.rightSE.point.x&&e.y===this.rightSE.point.y}},{key:"comparePoint",value:function(e){if(this.isAnEndpoint(e))return 0;var r=this.leftSE.point,i=this.rightSE.point,n=this.vector();if(r.x===i.x)return e.x===r.x?0:e.x<r.x?1:-1;var s=(e.y-r.y)/n.y,a=r.x+s*n.x;if(e.x===a)return 0;var u=(e.x-r.x)/n.x,l=r.y+u*n.y;return e.y===l?0:e.y<l?-1:1}},{key:"getIntersection",value:function(e){var r=this.bbox(),i=e.bbox(),n=rt$1(r,i);if(n===null)return null;var s=this.leftSE.point,a=this.rightSE.point,u=e.leftSE.point,l=e.rightSE.point,h=z(r,u)&&this.comparePoint(u)===0,c=z(i,s)&&e.comparePoint(s)===0,d=z(r,l)&&this.comparePoint(l)===0,f=z(i,a)&&e.comparePoint(a)===0;if(c&&h)return f&&!d?a:!f&&d?l:null;if(c)return d&&s.x===l.x&&s.y===l.y?null:s;if(h)return f&&a.x===u.x&&a.y===u.y?null:u;if(f&&d)return null;if(f)return a;if(d)return l;var g=Ht$1(s,this.vector(),u,e.vector());return g===null||!z(n,g)?null:G$1.round(g.x,g.y)}},{key:"split",value:function(e){var r=[],i=e.events!==void 0,n=new I$1(e,!0),s=new I$1(e,!1),a=this.rightSE;this.replaceRightSE(s),r.push(s),r.push(n);var u=new o(n,a,this.rings.slice(),this.windings.slice());return I$1.comparePoints(u.leftSE.point,u.rightSE.point)>0&&u.swapEvents(),I$1.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),i&&(n.checkForConsuming(),s.checkForConsuming()),r}},{key:"swapEvents",value:function(){var e=this.rightSE;this.rightSE=this.leftSE,this.leftSE=e,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(var r=0,i=this.windings.length;r<i;r++)this.windings[r]*=-1;}},{key:"consume",value:function(e){for(var r=this,i=e;r.consumedBy;)r=r.consumedBy;for(;i.consumedBy;)i=i.consumedBy;var n=o.compare(r,i);if(n!==0){if(n>0){var s=r;r=i,i=s;}if(r.prev===i){var a=r;r=i,i=a;}for(var u=0,l=i.rings.length;u<l;u++){var h=i.rings[u],c=i.windings[u],d=r.rings.indexOf(h);d===-1?(r.rings.push(h),r.windings.push(c)):r.windings[d]+=c;}i.rings=null,i.windings=null,i.consumedBy=r,i.leftSE.consumedBy=r.leftSE,i.rightSE.consumedBy=r.rightSE;}}},{key:"prevInResult",value:function(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}},{key:"beforeState",value:function(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else {var e=this.prev.consumedBy||this.prev;this._beforeState=e.afterState();}return this._beforeState}},{key:"afterState",value:function(){if(this._afterState!==void 0)return this._afterState;var e=this.beforeState();this._afterState={rings:e.rings.slice(0),windings:e.windings.slice(0),multiPolys:[]};for(var r=this._afterState.rings,i=this._afterState.windings,n=this._afterState.multiPolys,s=0,a=this.rings.length;s<a;s++){var u=this.rings[s],l=this.windings[s],h=r.indexOf(u);h===-1?(r.push(u),i.push(l)):i[h]+=l;}for(var c=[],d=[],f=0,g=r.length;f<g;f++)if(i[f]!==0){var p=r[f],y=p.poly;if(d.indexOf(y)===-1)if(p.isExterior)c.push(y);else {d.indexOf(y)===-1&&d.push(y);var m=c.indexOf(p.poly);m!==-1&&c.splice(m,1);}}for(var x=0,w=c.length;x<w;x++){var _=c[x].multiPoly;n.indexOf(_)===-1&&n.push(_);}return this._afterState}},{key:"isInResult",value:function(){if(this.consumedBy)return !1;if(this._isInResult!==void 0)return this._isInResult;var e=this.beforeState().multiPolys,r=this.afterState().multiPolys;switch(L.type){case"union":{var i=e.length===0,n=r.length===0;this._isInResult=i!==n;break}case"intersection":{var s,a;e.length<r.length?(s=e.length,a=r.length):(s=r.length,a=e.length),this._isInResult=a===L.numMultiPolys&&s<a;break}case"xor":{var u=Math.abs(e.length-r.length);this._isInResult=u%2===1;break}case"difference":{var l=function(c){return c.length===1&&c[0].isSubject};this._isInResult=l(e)!==l(r);break}default:throw new Error("Unrecognized operation type found ".concat(L.type))}return this._isInResult}}],[{key:"fromRing",value:function(e,r,i){var n,s,a,u=I$1.comparePoints(e,r);if(u<0)n=e,s=r,a=1;else if(u>0)n=r,s=e,a=-1;else throw new Error("Tried to create degenerate segment at [".concat(e.x,", ").concat(e.y,"]"));var l=new I$1(n,!0),h=new I$1(s,!1);return new o(l,h,[i],[a])}}]),o}(),bt$1=function(){function o(t,e,r){if(S$1(this,o),!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=r,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var i=G$1.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};for(var n=i,s=1,a=t.length;s<a;s++){if(typeof t[s][0]!="number"||typeof t[s][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var u=G$1.round(t[s][0],t[s][1]);u.x===n.x&&u.y===n.y||(this.segments.push(q.fromRing(n,u,this)),u.x<this.bbox.ll.x&&(this.bbox.ll.x=u.x),u.y<this.bbox.ll.y&&(this.bbox.ll.y=u.y),u.x>this.bbox.ur.x&&(this.bbox.ur.x=u.x),u.y>this.bbox.ur.y&&(this.bbox.ur.y=u.y),n=u);}(i.x!==n.x||i.y!==n.y)&&this.segments.push(q.fromRing(n,i,this));}return b(o,[{key:"getSweepEvents",value:function(){for(var e=[],r=0,i=this.segments.length;r<i;r++){var n=this.segments[r];e.push(n.leftSE),e.push(n.rightSE);}return e}}]),o}(),Qt$1=function(){function o(t,e){if(S$1(this,o),!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new bt$1(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(var r=1,i=t.length;r<i;r++){var n=new bt$1(t[r],this,!1);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.interiorRings.push(n);}this.multiPoly=e;}return b(o,[{key:"getSweepEvents",value:function(){for(var e=this.exteriorRing.getSweepEvents(),r=0,i=this.interiorRings.length;r<i;r++)for(var n=this.interiorRings[r].getSweepEvents(),s=0,a=n.length;s<a;s++)e.push(n[s]);return e}}]),o}(),wt$1=function(){function o(t,e){if(S$1(this,o),!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t]);}catch(s){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(var r=0,i=t.length;r<i;r++){var n=new Qt$1(t[r],this);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.polys.push(n);}this.isSubject=e;}return b(o,[{key:"getSweepEvents",value:function(){for(var e=[],r=0,i=this.polys.length;r<i;r++)for(var n=this.polys[r].getSweepEvents(),s=0,a=n.length;s<a;s++)e.push(n[s]);return e}}]),o}(),Jt$1=function(){b(o,null,[{key:"factory",value:function(e){for(var r=[],i=0,n=e.length;i<n;i++){var s=e[i];if(!(!s.isInResult()||s.ringOut)){for(var a=null,u=s.leftSE,l=s.rightSE,h=[u],c=u.point,d=[];a=u,u=l,h.push(u),u.point!==c;)for(;;){var f=u.getAvailableLinkedEvents();if(f.length===0){var g=h[0].point,p=h[h.length-1].point;throw new Error("Unable to complete output ring starting at [".concat(g.x,",")+" ".concat(g.y,"]. Last matching segment found ends at")+" [".concat(p.x,", ").concat(p.y,"]."))}if(f.length===1){l=f[0].otherSE;break}for(var y=null,m=0,x=d.length;m<x;m++)if(d[m].point===u.point){y=m;break}if(y!==null){var w=d.splice(y)[0],_=h.splice(w.index);_.unshift(_[0].otherSE),r.push(new o(_.reverse()));continue}d.push({index:h.length,point:u.point});var k=u.getLeftmostComparator(a);l=f.sort(k)[0].otherSE;break}r.push(new o(h));}}return r}}]);function o(t){S$1(this,o),this.events=t;for(var e=0,r=t.length;e<r;e++)t[e].segment.ringOut=this;this.poly=null;}return b(o,[{key:"getGeom",value:function(){for(var e=this.events[0].point,r=[e],i=1,n=this.events.length-1;i<n;i++){var s=this.events[i].point,a=this.events[i+1].point;_t$1(s,e,a)!==0&&(r.push(s),e=s);}if(r.length===1)return null;var u=r[0],l=r[1];_t$1(u,e,l)===0&&r.shift(),r.push(r[0]);for(var h=this.isExteriorRing()?1:-1,c=this.isExteriorRing()?0:r.length-1,d=this.isExteriorRing()?r.length:-1,f=[],g=c;g!=d;g+=h)f.push([r[g].x,r[g].y]);return f}},{key:"isExteriorRing",value:function(){if(this._isExteriorRing===void 0){var e=this.enclosingRing();this._isExteriorRing=e?!e.isExteriorRing():!0;}return this._isExteriorRing}},{key:"enclosingRing",value:function(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}},{key:"_calcEnclosingRing",value:function(){for(var e=this.events[0],r=1,i=this.events.length;r<i;r++){var n=this.events[r];I$1.compare(e,n)>0&&(e=n);}for(var s=e.segment.prevInResult(),a=s?s.prevInResult():null;;){if(!s)return null;if(!a)return s.ringOut;if(a.ringOut!==s.ringOut)return a.ringOut.enclosingRing()!==s.ringOut?s.ringOut:s.ringOut.enclosingRing();s=a.prevInResult(),a=s?s.prevInResult():null;}}}]),o}(),St$1=function(){function o(t){S$1(this,o),this.exteriorRing=t,t.poly=this,this.interiorRings=[];}return b(o,[{key:"addInterior",value:function(e){this.interiorRings.push(e),e.poly=this;}},{key:"getGeom",value:function(){var e=[this.exteriorRing.getGeom()];if(e[0]===null)return null;for(var r=0,i=this.interiorRings.length;r<i;r++){var n=this.interiorRings[r].getGeom();n!==null&&e.push(n);}return e}}]),o}(),Kt$1=function(){function o(t){S$1(this,o),this.rings=t,this.polys=this._composePolys(t);}return b(o,[{key:"getGeom",value:function(){for(var e=[],r=0,i=this.polys.length;r<i;r++){var n=this.polys[r].getGeom();n!==null&&e.push(n);}return e}},{key:"_composePolys",value:function(e){for(var r=[],i=0,n=e.length;i<n;i++){var s=e[i];if(!s.poly)if(s.isExteriorRing())r.push(new St$1(s));else {var a=s.enclosingRing();a.poly||r.push(new St$1(a)),a.poly.addInterior(s);}}return r}}]),o}(),te$1=function(){function o(t){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:q.compare;S$1(this,o),this.queue=t,this.tree=new J$1(e),this.segments=[];}return b(o,[{key:"process",value:function(e){var r=e.segment,i=[];if(e.consumedBy)return e.isLeft?this.queue.remove(e.otherSE):this.tree.remove(r),i;var n=e.isLeft?this.tree.insert(r):this.tree.find(r);if(!n)throw new Error("Unable to find segment #".concat(r.id," ")+"[".concat(r.leftSE.point.x,", ").concat(r.leftSE.point.y,"] -> ")+"[".concat(r.rightSE.point.x,", ").concat(r.rightSE.point.y,"] ")+"in SweepLine tree. Please submit a bug report.");for(var s=n,a=n,u=void 0,l=void 0;u===void 0;)s=this.tree.prev(s),s===null?u=null:s.key.consumedBy===void 0&&(u=s.key);for(;l===void 0;)a=this.tree.next(a),a===null?l=null:a.key.consumedBy===void 0&&(l=a.key);if(e.isLeft){var h=null;if(u){var c=u.getIntersection(r);if(c!==null&&(r.isAnEndpoint(c)||(h=c),!u.isAnEndpoint(c)))for(var d=this._splitSafely(u,c),f=0,g=d.length;f<g;f++)i.push(d[f]);}var p=null;if(l){var y=l.getIntersection(r);if(y!==null&&(r.isAnEndpoint(y)||(p=y),!l.isAnEndpoint(y)))for(var m=this._splitSafely(l,y),x=0,w=m.length;x<w;x++)i.push(m[x]);}if(h!==null||p!==null){var _=null;if(h===null)_=p;else if(p===null)_=h;else {var k=I$1.comparePoints(h,p);_=k<=0?h:p;}this.queue.remove(r.rightSE),i.push(r.rightSE);for(var D=r.split(_),M=0,R=D.length;M<R;M++)i.push(D[M]);}i.length>0?(this.tree.remove(r),i.push(e)):(this.segments.push(r),r.prev=u);}else {if(u&&l){var E=u.getIntersection(l);if(E!==null){if(!u.isAnEndpoint(E))for(var T=this._splitSafely(u,E),F=0,U=T.length;F<U;F++)i.push(T[F]);if(!l.isAnEndpoint(E))for(var B=this._splitSafely(l,E),$=0,W=B.length;$<W;$++)i.push(B[$]);}}this.tree.remove(r);}return i}},{key:"_splitSafely",value:function(e,r){this.tree.remove(e);var i=e.rightSE;this.queue.remove(i);var n=e.split(r);return n.push(i),e.consumedBy===void 0&&this.tree.insert(e),n}}]),o}(),Et$1=typeof process!="undefined"&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,ee$1=typeof process!="undefined"&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6,re$1=function(){function o(){S$1(this,o);}return b(o,[{key:"run",value:function(e,r,i){L.type=e,G$1.reset();for(var n=[new wt$1(r,!0)],s=0,a=i.length;s<a;s++)n.push(new wt$1(i[s],!1));if(L.numMultiPolys=n.length,L.type==="difference")for(var u=n[0],l=1;l<n.length;)rt$1(n[l].bbox,u.bbox)!==null?l++:n.splice(l,1);if(L.type==="intersection"){for(var h=0,c=n.length;h<c;h++)for(var d=n[h],f=h+1,g=n.length;f<g;f++)if(rt$1(d.bbox,n[f].bbox)===null)return []}for(var p=new J$1(I$1.compare),y=0,m=n.length;y<m;y++)for(var x=n[y].getSweepEvents(),w=0,_=x.length;w<_;w++)if(p.insert(x[w]),p.size>Et$1)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");for(var k=new te$1(p),D=p.size,M=p.pop();M;){var R=M.key;if(p.size===D){var E=R.segment;throw new Error("Unable to pop() ".concat(R.isLeft?"left":"right"," SweepEvent ")+"[".concat(R.point.x,", ").concat(R.point.y,"] from segment #").concat(E.id," ")+"[".concat(E.leftSE.point.x,", ").concat(E.leftSE.point.y,"] -> ")+"[".concat(E.rightSE.point.x,", ").concat(E.rightSE.point.y,"] from queue. ")+"Please file a bug report.")}if(p.size>Et$1)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");if(k.segments.length>ee$1)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");for(var T=k.process(R),F=0,U=T.length;F<U;F++){var B=T[F];B.consumedBy===void 0&&p.insert(B);}D=p.size,M=p.pop();}G$1.reset();var $=Jt$1.factory(k.segments),W=new Kt$1($);return W.getGeom()}}]),o}(),L=new re$1,ie$1=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("union",t,r)},ne$1=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("intersection",t,r)},oe$1=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("xor",t,r)},se$1=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("difference",t,r)},ae$1={union:ie$1,intersection:ne$1,xor:oe$1,difference:se$1};function ue$1(o,t,e){e===void 0&&(e={});var r=ft$1(o),i=ft$1(t),n=ae$1.intersection(r.coordinates,i.coordinates);return n.length===0?null:n.length===1?H$1(n[0],e.properties):Bt$1(n,e.properties)}const v={mergeArray(o,t){if(t.length<5e4)o.push.apply(o,t);else for(let e=0,r=t.length;e<r;e+=1)o.push(t[e]);},now:Date.now||function(){return new Date().getTime()},bind(o,t){return o.bind?o.bind(t):function(){return o.apply(t,arguments)}},forEach(o,t,e){if(o.forEach)return o.forEach(t,e);for(let r=0,i=o.length;r<i;r++)t.call(e,o[r],r);},map(o,t,e){if(o.map)return o.map(t,e);const r=[];for(let i=0,n=o.length;i<n;i++)r[i]=t.call(e,o[i],i);return r},merge(o,t){if(t.length<5e4)Array.prototype.push.apply(o,t);else for(let e=0,r=t.length;e<r;e+=1)o.push(t[e]);},arrayIndexOf(o,t,e){if(o.indexOf)return o.indexOf(t,e);let r,i=o,n=i.length>>>0;if(n===0)return -1;const s=0|e;if(s>=n)return -1;for(r=Math.max(s>=0?s:n-Math.abs(s),0);r<n;){if(r in i&&i[r]===t)return r;r++;}return -1},extend(o){return o||(o={}),this.extendObjs(o,Array.prototype.slice.call(arguments,1))},extendObjs(o,t){o||(o={});for(let e=0,r=t.length;e<r;e++){const i=t[e];if(i)for(const n in i)i.hasOwnProperty(n)&&(o[n]=i[n]);}return o},debounce(o,t,e){let r,i,n,s,a,u=function(){const l=v.now()-s;l<t&&l>=0?r=setTimeout(u,t-l):(r=null,e||(a=o.apply(n,i),r||(n=i=null)));};return function(){n=this,i=arguments,s=v.now();const l=e&&!r;return r||(r=setTimeout(u,t)),l&&(a=o.apply(n,i),n=i=null),a}},throttle(o,t,e){let r,i,n,s=null,a=0;e||(e={});const u=function(){a=e.leading===!1?0:v.now(),s=null,n=o.apply(r,i),s||(r=i=null);};return function(){const l=v.now();a||e.leading!==!1||(a=l);const h=t-(l-a);return r=this,i=arguments,h<=0||h>t?(s&&(clearTimeout(s),s=null),a=l,n=o.apply(r,i),s||(r=i=null)):s||e.trailing===!1||(s=setTimeout(u,h)),n}},escapeHtml(o){const t={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"};return `${o}`.replace(/[&<>"']/g,function(e){return t[e]})}};var nt$1={BBRFLAG:{I:1,S:2},ADCODES:{COUNTRY:1e5}};function le$1(o){return o}function he$1(o){if(o==null)return le$1;var t,e,r=o.scale[0],i=o.scale[1],n=o.translate[0],s=o.translate[1];return function(a,u){u||(t=e=0);var l=2,h=a.length,c=new Array(h);for(c[0]=(t+=a[0])*r+n,c[1]=(e+=a[1])*i+s;l<h;)c[l]=a[l],++l;return c}}function ce$1(o,t){for(var e,r=o.length,i=r-t;i<--r;)e=o[i],o[i++]=o[r],o[r]=e;}function de$1(o,t){return typeof t=="string"&&(t=o.objects[t]),t.type==="GeometryCollection"?{type:"FeatureCollection",features:t.geometries.map(function(e){return Lt$1(o,e)})}:Lt$1(o,t)}function Lt$1(o,t){var e=t.id,r=t.bbox,i=t.properties==null?{}:t.properties,n=fe$1(o,t);return e==null&&r==null?{type:"Feature",properties:i,geometry:n}:r==null?{type:"Feature",id:e,properties:i,geometry:n}:{type:"Feature",id:e,bbox:r,properties:i,geometry:n}}function fe$1(o,t){var e=he$1(o.transform),r=o.arcs;function i(h,c){c.length&&c.pop();for(var d=r[h<0?~h:h],f=0,g=d.length;f<g;++f)c.push(e(d[f],f));h<0&&ce$1(c,g);}function n(h){return e(h)}function s(h){for(var c=[],d=0,f=h.length;d<f;++d)i(h[d],c);return c.length<2&&c.push(c[0]),c}function a(h){for(var c=s(h);c.length<4;)c.push(c[0]);return c}function u(h){return h.map(a)}function l(h){var c=h.type,d;switch(c){case"GeometryCollection":return {type:c,geometries:h.geometries.map(l)};case"Point":d=n(h.coordinates);break;case"MultiPoint":d=h.coordinates.map(n);break;case"LineString":d=s(h.arcs);break;case"MultiLineString":d=h.arcs.map(s);break;case"Polygon":d=u(h.arcs);break;case"MultiPolygon":d=h.arcs.map(u);break;default:return null}return {type:c,coordinates:d}}return l(t)}function pe$1(o,t){let e,r,i,n,s=o;e=t[t.length-2];for(let a=0,u=t.length-1;a<u;a++){r=t[a];const l=s;s=[],i=l[l.length-1];for(let h=0,c=l.length;h<c;h++)n=l[h],ot$1(n,e,r)?(ot$1(i,e,r)||s.push(kt$1(e,r,i,n)),s.push(n)):ot$1(i,e,r)&&s.push(kt$1(e,r,i,n)),i=n;e=r;}return s.length<3?[]:(s.push(s[0]),s)}function ge$1(o,t,e){const r=(e[1]-t[1])/(e[0]-t[0])*(o[0]-t[0])+t[1];return Math.abs(r-o[1])<1e-6&&o[0]>=t[0]&&o[0]<=e[0]}function ye$1(o,t){for(let e=0,r=t.length;e<r-1;e++)if(ge$1(o,t[e],t[e+1]))return !0;return !1}function ve$1(o,t){let e=!1;for(let r=o[0],i=o[1],n=0,s=t.length,a=s-1;n<s;a=n++){const u=t[n][0],l=t[n][1],h=t[a][0],c=t[a][1];l>i!=c>i&&r<(h-u)*(i-l)/(c-l)+u&&(e=!e);}return e}function _e$1(o,t,e){let r,i=t[0],n=t[1];const s=e[0]-i,a=e[1]-n,u=s*s+a*a;return u>0&&(r=((o[0]-i)*s+(o[1]-n)*a)/u,r>1?(i=e[0],n=e[1]):r>0&&(i+=s*r,n+=a*r)),[i,n]}function me$1(o,t,e){const r=_e$1(o,t,e),i=o[0]-r[0],n=o[1]-r[1];return i*i+n*n}function xe$1(o,t){let e=Number.MAX_VALUE;for(let r=0,i=t.length;r<i-1;r++){const n=me$1(o,t[r],t[r+1]);n<e&&(e=n);}return e}function ot$1(o,t,e){return (e[0]-t[0])*(o[1]-t[1])>(e[1]-t[1])*(o[0]-t[0])}function kt$1(o,t,e,r){const i=[o[0]-t[0],o[1]-t[1]],n=[e[0]-r[0],e[1]-r[1]],s=o[0]*t[1]-o[1]*t[0],a=e[0]*r[1]-e[1]*r[0],u=1/(i[0]*n[1]-i[1]*n[0]);return [(s*n[0]-a*i[0])*u,(s*n[1]-a*i[1])*u]}var j$1={sqClosestDistanceToPolygon:xe$1,pointOnPolygon:ye$1,pointInPolygon:ve$1,polygonClip:pe$1};const st$1=nt$1.BBRFLAG,at$1=[];function be$1(o,t){const e=[];for(let r=0,i=o.length;r<i;r++){const n=o[r].split("-");let s=n[0],a=n.length>1?n[1]:s;s=parseInt(s,t),a=parseInt(a,t);for(let u=s;u<=a;u++)e.push(u);}return e}function It$1(o,t,e){if(o[t])throw new Error(`Alreay exists:  ${o[t]}`);o[t]=e;}function we$1(o){return at$1[o]||(at$1[o]=[st$1.I,o]),at$1[o]}function Se$1(o,t,e){if(o)for(let r=o.split(":"),i=parseInt(r[0],t),n=be$1(r[1].split(","),t),s=we$1(i),a=0,u=n.length;a<u;a++)It$1(e,n[a],s);}function Ee$1(o,t,e){if(o){const r=[];let i=o.split(":"),n=parseInt(i[0],t);const s=i[1].split(";");for(let a=0,u=s.length;a<u;a++){i=s[a].split(",");const l=[parseInt(i[0],t),0];i.length>1&&(l[1]=parseInt(i[1],t)),r.push(l);}It$1(e,n,[st$1.S,r]);}}function At$1(o,t){if(!o)return null;const e=o.split(","),r=[];for(let i=0,n=e.length;i<n;i++){if(parseInt(e[i],t)<0)return null;r.push(parseInt(e[i],t));}return r}function Le$1(o,t){if(!o)return null;const e=o.split(";"),r=[];for(let i=0,n=e.length;i<n;i++)r.push(At$1(e[i],t));return r}function ke$1(o){let t,e;const r=o.r,i=[],n=o.idx.i.split("|");for(o.idx.i=null,t=0,e=n.length;t<e;t++)Se$1(n[t],r,i);n.length=0;const s=o.idx.s.split("|");for(o.idx.s=null,t=0,e=s.length;t<e;t++)Ee$1(s[t],r,i);s.length=0,o.idx=null,o.idxList=i,o.mxr&&(o.maxRect=At$1(o.mxr,r),o.mxr=null),o.mxsr&&(o.maxSubRect=Le$1(o.mxsr,r),o.mxsr=null);}function Ie$1(o,t,e){for(let r=o.geoData.sub.features,i=0,n=e.length;i<n;i++){const s=e[i],a=r[s[0]],u=a.geometry.coordinates[s[1]][0],l=j$1.polygonClip(u,t);!l||l.length<4?console.warn(`Cliped ring length werid: ${l}`):s[2]=l;}return !0}function Ae$1(o,t,e){const r=o.bbIndex,i=r.s;(t<0||e<0||e>=r.h||t>=r.w)&&console.warn("Wrong x,y",t,e,r);const n=e*r.w+t,s=r.idxList[n];if(s[0]!==st$1.S)return !1;const a=s[1];if(a[0].length>2)return !1;const u=t*i+r.l,l=e*i+r.t;return Ie$1(o,[[u,l],[u+i,l],[u+i,l+i],[u,l+i],[u,l]],a),!0}var Pt$1={prepareGridFeatureClip:Ae$1,buildIdxList:ke$1};class C{constructor(t,e,r,i){this.x=t,this.y=e,this.width=r,this.height=i;}static getBoundsItemToExpand(){return new C(Number.MAX_VALUE,Number.MAX_VALUE,-1,-1)}static boundsIntersect(t,e){return t.x<=e.x+e.width&&e.x<=t.x+t.width&&t.y<=e.y+e.height&&e.y<=t.y+t.height}isEmpty(){return this.width<0}expandByPoint(t,e){let r,i,n,s;this.isEmpty()?(r=n=t,i=s=e):(r=this.x,i=this.y,n=this.x+this.width,s=this.y+this.height,t<r?r=t:t>n&&(n=t),e<i?i=e:e>s&&(s=e)),this.x=r,this.y=i,this.width=n-r,this.height=s-i;}}function Pe$1(o){const t={},e=o.objects;for(const r in e)t[r]=de$1(o,e[r]);return t}function Ne$1(o){for(let t=o.sub?o.sub.features:[],e=o.parent.properties,r=(e.acroutes||[]).concat([e.adcode]),i=0,n=t.length;i<n;i++)t[i].properties.subFeatureIndex=i,t[i].properties.acroutes=r;}function Me$1(o){if(!o._isBuiled){Pt$1.buildIdxList(o.bbIndex),o.geoData=Pe$1(o.topo),o.geoData.sub&&Ne$1(o.geoData);const t=o.topo.bbox;o.bounds=new C(t[0],t[1],t[2]-t[0],t[3]-t[1]),o.topo=null,o._isBuiled=!0;}return o}var Re$1={buildData:Me$1};const ut$1={},O$1=Math.PI/180,Nt$1=180/Math.PI,Fe$1=Math.PI/4,Mt$1=.5/Math.PI;function lt$1(o){return ut$1[o]||(ut$1[o]=256*Math.pow(2,o)),ut$1[o]}function Oe$1(o){let t=o[1],e=o[0]*O$1,r=t*O$1;return r=Math.log(Math.tan(Fe$1+r/2)),[e,r]}function Ce$1(o,t){t=t||1;const e=Mt$1,r=.5,i=-e,n=.5;return [t*(e*o[0]+r),t*(i*o[1]+n)]}function De$1(o){const t=o[0]*Nt$1,e=(2*Math.atan(Math.exp(o[1]))-Math.PI/2)*Nt$1;return [parseFloat(t.toFixed(6)),parseFloat(e.toFixed(6))]}function Te$1(o,t){const e=Mt$1,r=.5,i=-e,n=.5;return [(o[0]/t-r)/e,(o[1]/t-n)/i]}function Rt$1(o,t,e){const r=Ce$1(Oe$1(o),t);return e&&(r[0]=Math.round(r[0]),r[1]=Math.round(r[1])),r}function Be$1(o,t,e){return Rt$1(o,lt$1(t),e)}function $e$1(o,t){const e=lt$1(t),r=Te$1(o,e);return De$1(r)}function ze$1(o,t){const e=Math.cos,r=o[1]*O$1,i=o[0]*O$1,n=t[1]*O$1,s=t[0]*O$1,a=n-r,u=s-i,l=(1-e(a)+(1-e(u))*e(r)*e(n))/2;return 12756274*Math.asin(Math.sqrt(l))}var ht$1={haversineDistance:ze$1,getScale:lt$1,lngLatToPointByScale:Rt$1,pointToLngLat:$e$1,lngLatToPoint:Be$1};let ct$1 = class ct{constructor(t,e,r){this.adcode=t,this._data=e,this._sqScaleFactor=e.scale*e.scale,this._opts=Object.assign({nearTolerance:2},r),this.setNearTolerance(this._opts.nearTolerance);}static getPropsOfFeature(t){return t&&t.properties?t.properties:null}static getAdcodeOfFeature(t){return t?t.properties.adcode:null}static doesFeatureHasChildren(t){return !!t&&t.properties.childrenNum>0}setNearTolerance(t){this._opts.nearTolerance=t,this._sqNearTolerance=t*t;}getIdealZoom(){return this._data.idealZoom}_getEmptySubFeatureGroupItem(t){return {subFeatureIndex:t,subFeature:this.getSubFeatureByIndex(t),pointsIndexes:[],points:[]}}groupByPosition(t,e){let r,i,n={},s=null;for(r=0,i=t.length;r<i;r++){const u=this.getLocatedSubFeatureIndex(e.call(null,t[r],r));n[u]||(n[u]=this._getEmptySubFeatureGroupItem(u)),n[u].pointsIndexes.push(r),n[u].points.push(t[r]),u<0&&(s=n[u]);}const a=[];if(this._data.geoData.sub)for(r=0,i=this._data.geoData.sub.features.length;r<i;r++)a.push(n[r]||this._getEmptySubFeatureGroupItem(r));return s&&a.push(s),n=null,a}getLocatedSubFeatureIndex(t){return this._getLocatedSubFeatureIndexByPixel(this.lngLatToPixel(t))}getSubFeatureByIndex(t){return t>=0?this.getSubFeatures()[t]:null}_getLocatedSubFeatureIndexByPixel(t){if(!this._data.geoData.sub)return -1;const e=this._data,r=e.bbIndex,i=t[0]-r.l,n=t[1]-r.t,s=Math.floor(n/r.s),a=Math.floor(i/r.s);if(a<0||s<0||s>=r.h||a>=r.w)return -1;const u=s*r.w+a,l=r.idxList[u];if(!l)return -1;const h=nt$1.BBRFLAG;switch(l[0]){case h.I:return l[1];case h.S:return Pt$1.prepareGridFeatureClip(e,a,s),this._calcLocatedFeatureIndexOfSList(t,l[1]);default:throw new Error(`Unknown BBRFLAG: ${l[0]}`)}}_calcNearestFeatureIndexOfSList(t,e){let r=[];this._data.geoData.sub&&(r=this._data.geoData.sub.features);const i={sq:Number.MAX_VALUE,idx:-1};for(let n=0,s=e.length;n<s;n++){const a=e[n],u=r[a[0]],l=a[2]||u.geometry.coordinates[a[1]][0],h=j$1.sqClosestDistanceToPolygon(t,l);h<i.sq&&(i.sq=h,i.idx=a[0]);}return i.sq/this._sqScaleFactor<this._sqNearTolerance?i.idx:-1}_calcLocatedFeatureIndexOfSList(t,e){for(let r=this._data.geoData.sub.features,i=0,n=e.length;i<n;i++){const s=e[i],a=r[s[0]],u=s[2]||a.geometry.coordinates[s[1]][0];if(j$1.pointInPolygon(t,u)||j$1.pointOnPolygon(t,u))return s[0]}return this._calcNearestFeatureIndexOfSList(t,e)}pixelToLngLat(t,e){return ht$1.pointToLngLat([t,e],this._data.pz)}lngLatToPixel(t){t instanceof AMap.LngLat&&(t=[t.getLng(),t.getLat()]);const e=ht$1.lngLatToPoint(t,this._data.pz);return [Math.round(e[0]),Math.round(e[1])]}_convertRingCoordsToLngLats(t){const e=[];for(let r=0,i=t.length;r<i;r++)e[r]=this.pixelToLngLat(t[r][0],t[r][1]);return e}_convertPolygonCoordsToLngLats(t){const e=[];for(let r=0,i=t.length;r<i;r++)e[r]=this._convertRingCoordsToLngLats(t[r]);return e}_convertMultiPolygonCoordsToLngLats(t){const e=[];for(let r=0,i=t.length;r<i;r++)e[r]=this._convertPolygonCoordsToLngLats(t[r]);return e}_convertCoordsToLngLats(t,e){switch(t){case"MultiPolygon":return this._convertMultiPolygonCoordsToLngLats(e);default:throw new Error(`Unknown type ${t}`)}}_createLngLatFeature(t,e){const r=Object.assign({},t);return e&&Object.assign(r.properties,e),r.geometry=Object.assign({},r.geometry),r.geometry.coordinates=this._convertCoordsToLngLats(r.geometry.type,r.geometry.coordinates),r}getAdcode(){return this.getProps("adcode")}getName(){return this.getProps("name")}getChildrenNum(){return this.getProps("childrenNum")}getProps(t){const e=ct.getPropsOfFeature(this._data.geoData.parent);return e?t?e[t]:e:null}getParentFeature(){const t=this._data.geoData;return t.lngLatParent||(t.lngLatParent=this._createLngLatFeature(t.parent)),t.lngLatParent}getParentFeatureInPixel(){return this._data.geoData.parent}getSubFeatures(){const t=this._data.geoData;if(!t.sub)return [];if(!t.lngLatSubList){const e=[];for(let r=t.sub.features,i=0,n=r.length;i<n;i++)e[i]=this._createLngLatFeature(r[i]);t.lngLatSubList=e;}return [].concat(t.lngLatSubList)}getSubFeaturesInPixel(){return this._data.geoData.sub?[].concat(this._data.geoData.sub.features):[]}getBounds(){const t=this._data;if(!t.lngLatBounds){const e=this._data.bounds;t.lngLatBounds=new AMap.Bounds(this.pixelToLngLat(e.x,e.y+e.height),this.pixelToLngLat(e.x+e.width,e.y));}return t.lngLatBounds}};let Ge$1 = class Ge extends Y$1{constructor(t){super(),this._opts=Object.assign({distDataLoc:"//webapi.amap.com/ui/1.1/ui/geo/DistrictExplorer/assets/d_v2"},t),this._areaNodesForLocating=null,this._areaNodeCache={},this._opts.preload&&this.loadMultiAreaNodes(this._opts.preload);}setAreaNodesForLocating(t){t?Array.isArray(t)||(t=[t]):t=[],this._areaNodesForLocating=t||[];}_loadJson(t,e){const r=this;return fetch(t,{headers:{Accept:"application/json"}}).then(i=>i.json()).then(i=>{e&&e.call(r,null,i);}).catch(i=>{if(!e)throw i;e(i);})}_getAreaNodeDataFileName(t){return `an_${t}.json`}_getAreaNodeDataSrc(t){return `${this._opts.distDataLoc}/${this._getAreaNodeDataFileName(t)}`}loadAreaTree(t){this._loadJson(`${this._opts.distDataLoc}/area_tree.json`,t);}loadCountryNode(t){this.loadAreaNode(nt$1.ADCODES.COUNTRY,t);}loadMultiAreaNodes(t,e){let r=[],i=!1,n;function s(a){return function(u,l){i||(n--,u?(e&&e(u),i=!0):(r[a]=l,n===0&&e&&e(null,r)));}}if(t&&t.length){const a=t.length;for(let u=0;u<a;u++)this.loadAreaNode(t[u],e?s(u):null);}else e&&e(null,[]);}loadAreaNode(t,e,r,i){if(r=r||this,this._areaNodeCache[t]){if(e){const n=this._areaNodeCache[t];i?e.call(r,null,n,!0):setTimeout(function(){e.call(r,null,n);},0);}}else this._loadJson(this._getAreaNodeDataSrc(t),(n,s)=>{n?e&&e.call(r,n):(this._buildAreaNode(t,s),e&&e.call(r,null,this._areaNodeCache[t]));});}getLocalAreaNode(t){return this._areaNodeCache[t]||null}_buildAreaNode(t,e){if(!this._areaNodeCache[t]){if(!e)throw new Error(`Empty distData: ${t}`);const r=new ct$1(t,Re$1.buildData(e),this._opts);this._areaNodeCache[t]=r,this._areaNodesForLocating||(this._areaNodesForLocating=[r]);}}clearAreaNodeCacheByAdcode(t){const e=this._areaNodeCache;return delete e[t],!0}destroy(){this._areaNodesForLocating=null,this._areaNodeCache=null,this._opts=null;}};let Ze$1 = class Ze{constructor(t){this.isDistReady=!1,this.nodeMap={},this.waitFnList=[],this.singleDistExplorer=new Ge$1({}),this._opts=v.extend({topAdcodes:[1e5]},t),this._touchMap={},this.singleDistExplorer.loadAreaTree((e,r)=>{if(e)throw e;if(this.filterAreaTree(r),this.singleCountryNode=r,this.isDistReady=!0,this.waitFnList.length){for(let i=0,n=this.waitFnList.length;i<n;i++)this.waitFnList[i][0].call(this.waitFnList[i][1]);this.waitFnList.length=0;}this.singleDistExplorer.loadMultiAreaNodes(this._opts.topAdcodes);});}pixelToLngLat(t,e,r){return ht$1.pointToLngLat([t,e],r)}getBounds(t){const e=t.bbounds;return new AMap.Bounds(this.pixelToLngLat(e.x,e.y+e.height,20),this.pixelToLngLat(e.x+e.width,e.y,20))}filterAreaTree(t){const e=[t];do{const r=e.pop();this.nodeMap[r.adcode]=r;const i=r.bbox;if(r.bbounds=new C(i[0],i[1],i[2],i[3]),r.bbox=this.getBounds(r),r.children)for(let n=r.children,s=0,a=n.length;s<a;s++)n[s].childIdx=s,e.push(n[s]);}while(e.length)}isReady(){return this.isDistReady}getParentAdcode(t,e){if(!e){const r=this.getNodeByAdcode(t);if(!r)return console.warn(`Can not find node: ${t}`),null;e=r.acroutes;}return e&&e.length?e[e.length-1]:null}getSubIdx(t){return this.getNodeByAdcode(t).childIdx}getChildrenNum(t){const e=this.getNodeByAdcode(t);return this.getChildrenNumOfNode(e)}getChildrenNumOfNode(t){return t.children?t.children.length:t.childrenNum||0}getNodeByAdcode(t){const e=this.nodeMap[t];if(!e){let r=this.singleDistExplorer.getLocalAreaNode(`${`${t}`.substr(0,4)}00`);if(r||(r=this.singleDistExplorer.getLocalAreaNode(`${`${t}`.substr(0,2)}0000`)),!r)return null;for(let i=r.getSubFeatures(),n=0,s=i.length;n<s;n++)if(i[n].properties.adcode===t)return i[n].properties}return e}getNodeChildren(t){const e=this.getNodeByAdcode(t);if(!e)return null;if(e.children)return e.children;if(e.childrenNum>=0){const r=this.singleDistExplorer.getLocalAreaNode(t);if(!r)return null;const i=[],n=r.getSubFeaturesInPixel();for(let s=0,a=n.length;s<a;s++)i.push(n[s].properties);return i}return null}getExplorer(){return this.singleDistExplorer}traverseCountry(t,e,r,i,n){this.traverseNode(this.singleCountryNode,t,e,r,i,n,[]);}getNodeBoundsSize(t,e){const r=this.getPixelZoom(),i=Math.pow(2,r-e);return [t.bbounds.width/i,t.bbounds.height/i]}doesRingRingIntersect(t,e){const r=[t.getNorthWest().toArray(),t.getNorthEast().toArray(),t.getSouthEast().toArray(),t.getSouthWest().toArray(),t.getNorthWest().toArray()],i=[e.getNorthWest().toArray(),e.getNorthEast().toArray(),e.getSouthEast().toArray(),e.getSouthWest().toArray(),e.getNorthWest().toArray()];return !!ue$1(H$1([r]),H$1([i]))}traverseNode(t,e,r,i,n,s,a,u){if(!(a&&a.indexOf(t.adcode)>=0)){if(this.doesRingRingIntersect(e,t.bbox)){const l=t.children,h=l&&l.length>0;if(r>t.idealZoom&&h)for(let c=0,d=l.length;c<d;c++)this.traverseNode(l[c],e,r,i,null,s,a);else i.call(s,t);}n&&(u?(u.count++,u.count>=u.total&&n.call(s)):n.call(s));}}onReady(t,e,r){this.isDistReady?r?t.call(e):setTimeout(function(){t.call(e);},0):this.waitFnList.push([t,e]);}getPixelZoom(){var t;return (t=this.singleCountryNode)===null||t===void 0?void 0:t.pz}loadAreaNode(t,e,r,i){this.singleDistExplorer.loadAreaNode(t,e,r,i);}isExcludedAdcode(t){const e=this._opts.excludedAdcodes;return e&&e.indexOf(t)>=0}traverseTopNodes(t,e,r,i,n){const s=this._opts.topAdcodes,a=this._opts.excludedAdcodes,u={total:s.length,count:0};for(let l=0,h=s.length;l<h;l++){const c=this.getNodeByAdcode(s[l]);if(!c)throw new Error(`Can not find adcode: ${s[l]}`);this.traverseNode(c,t,e,r,i,n,a,u);}}tryClearCache(t,e){if(!(e<0)){const r=[this.singleCountryNode],i=[],n=this._touchMap;do{const a=r.pop();a.children&&v.mergeArray(r,a.children);const u=n[a.adcode];u&&u!==t&&i.push(a.adcode);}while(r.length);i.sort(function(a,u){const l=n[a]-n[u];return l===0?a-u:l});const s=i.length-e;if(!(s<=0))for(let a=0;a<s;a++)this.singleDistExplorer.clearAreaNodeCacheByAdcode(i[a])&&this.touchAdcode(i[a],null);}}touchAdcode(t,e){this._touchMap[t]=e;}destroy(){this.singleDistExplorer.destroy(),this._touchMap={},this.nodeMap={},this.singleDistExplorer=void 0,this._opts=void 0,this.waitFnList=[],this.singleCountryNode=void 0;}};function Ve$1(o){return [o.x,o.y]}let qe$1 = class qe{constructor(t){this._data=[],this._pointsMap={},this._opts=v.extend({topAdcode:1e5},t),this.clearData();}clearData(){this._data=[],this._pointsMap={};}setData(t){this.clearData(),this._data=t,this._updatePointsMap(this._opts.topAdcode,"all",t);}_updatePointsMap(t,e,r){let i=this._pointsMap[t];i||(i=this._pointsMap[t]={}),i[e]=r,i[`${e}_pack`]=this._buildPackItemsByAdcode(t,r);}getPointsByAdcode(t,e){return this._pointsMap[t]?this._pointsMap[t][e||"all"]:[]}getPackItemsByAdcode(t,e){return this._pointsMap[t]?this._pointsMap[t][`${e||"all"}_pack`]:[]}_buildPackItemsByAdcode(t,e){const r=this._opts.pointPacker,i=[];for(let n=0,s=e.length;n<s;n++)i[n]=r.call(this._opts.pointPackerThisArg,e[n]);return i}calcDistGroup(t,e,r,i){const n=this._opts.distMgr.getNodeByAdcode(t);let s=n.acroutes||[1e5];e&&n.acroutes&&(s=[].concat(s),s.push(t)),this._calcGroupWithRoutes(s,0,r,i);}_calcGroupWithRoutes(t,e,r,i){const n=()=>{e<t.length-1?this._calcGroupWithRoutes(t,e+1,r,i):r&&r.call(i);},s=t[e];if(this.getPointsByAdcode(s,"__done"))n.call(this);else {const a=this.getPointsByAdcode(s);if(!a)throw new Error(`Not points found:  ${s}`);this._opts.distMgr.getExplorer().loadAreaNode(s,(u,l)=>{this._groupByAreaNode(l,a),n.call(this);},this,!0);}}_groupByAreaNode(t,e){const r=t.groupByPosition(e,Ve$1),i=t.getAdcode()===this._opts.topAdcode,n=[];for(let s=0,a=r.length;s<a;s++){const u=r[s];u.subFeature?(this._updatePointsMap(u.subFeature.properties.adcode,"all",u.points),i&&v.mergeArray(n,u.points)):this._updatePointsMap(t.getAdcode(),"hanging",u.points);}i&&this._updatePointsMap(t.getAdcode(),"all",n),this._updatePointsMap(t.getAdcode(),"__done",!0);}destroy(){this.clearData(),this._opts=null;}};var je$1=Object.defineProperty,Ue$1=Object.defineProperties,We$1=Object.getOwnPropertyDescriptors,Ft$1=Object.getOwnPropertySymbols,Ye$1=Object.prototype.hasOwnProperty,He$1=Object.prototype.propertyIsEnumerable,Ot$1=(o,t,e)=>t in o?je$1(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,Ct$1=(o,t)=>{for(var e in t||(t={}))Ye$1.call(t,e)&&Ot$1(o,e,t[e]);if(Ft$1)for(var e of Ft$1(t))He$1.call(t,e)&&Ot$1(o,e,t[e]);return o},Xe$1=(o,t)=>Ue$1(o,We$1(t));let Qe$1 = class Qe extends Y$1{constructor(t,e){super(),this.baseId=1,this._currentZoom=2,this._currentFeatures=[],this._loadLeft=0,this._polygonCache=[],this._markerCache=[],this._opts=v.extend({engine:"default",areaNodeCacheLimit:-1,minHeightToShowSubFeatures:630,minSiblingAvgHeightToShowSubFeatures:600,minSubAvgHeightToShowSubFeatures:300,zooms:[2,30],clusterMarkerEventSupport:!0,clusterMarkerClickToShowSub:!0,featureEventSupport:!0,featureClickToShowSub:!1,featureStyleByLevel:{country:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(49, 163, 84)",fillOpacity:.8},province:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(116, 196, 118)",fillOpacity:.7},city:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(161, 217, 155)",fillOpacity:.6},district:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(199, 233, 192)",fillOpacity:.5}}},e),this._map=this._opts.map,this._createLayer(),this._ins=t,this._isRendering=!1,this._loadLeft=0,this._currentFeatures=[];}_createLayer(){this.markerGroup=new AMap.OverlayGroup,this._map.add(this.markerGroup),this.layer=new AMap.VectorLayer({zIndex:this._opts.zIndex||10,visible:this._opts.visible||!0}),this._map.addLayer(this.layer);}zoomToShowSubFeatures(t,e){const r=this.getMinZoomToShowSub(t);if(r>=3){const i=this._ins.getMap();i&&(e||(e=this._ins._distMgr.getNodeByAdcode(t).center),i.setZoomAndCenter(r,e));}}getPixelRatio(){return Math.min(2,Math.round(window.devicePixelRatio||1))}refreshViewState(){if(!this._ins._distMgr.isReady())return !1;const t=this._ins;if(!t.isReady())return !1;const e=t.getMap(),r=e.getBounds(),i=e.getSize(),n=e.getZoom(3),s=this._opts.zooms[1],a=Math.pow(2,s-n),u=r.getNorthWest(),l=e.lngLatToCoords([u.getLng(),u.getLat()]),h=new C(l[0],l[1],i.width*a,i.height*a);this._currentZoom=n,this._currentScaleFactor=a,this._currentViewBounds=h,this._currentViewBoundsInLngLat=r,this._currentPixelRatio=this.getPixelRatio();}renderViewport(){if(this.refreshViewState(),!this._currentViewBounds)return !1;this._currentRenderId=this.baseId++,this._loadLeft=0,this._currentFeatures=[],this._renderViewDist(this._currentRenderId),this._isRendering=!1;}getCurrentRenderId(){return this._currentRenderId}isRenderIdStillValid(t){return t===this._currentRenderId}_renderViewDist(t){const e=[];if(this._currentZoom<this._opts.zooms[0]||this._currentZoom>this._opts.zooms[1]){this.isRenderIdStillValid(t)&&this._prepareFeatures(t,e);return}this._ins.getDistMgr().traverseTopNodes(this._currentViewBoundsInLngLat,this._currentZoom,r=>{e.push(r.adcode);},()=>{this.isRenderIdStillValid(t)&&this._prepareFeatures(t,e);},this);}getMinZoomToShowSub(t){const e=this._ins._distMgr.getNodeByAdcode(t);if(!e||!e.idealZoom)return -1;if(!e._minZoomToShowSub){const r=this._ins.getZooms();for(let i=r[0];i<=r[1];i++)if(this.shouldShowSubOnZoom(e,i)){e._minZoomToShowSub=i;break}}return e._minZoomToShowSub||-1}shouldShowSubOnZoom(t,e){if(!t.idealZoom)return !1;if(t._minZoomToShowSub&&e>=t._minZoomToShowSub)return !0;let r=this._ins._distMgr.getNodeBoundsSize(t,e);if(t.adcode===1e5&&r[1]>400)return !0;if(r[1]<this._opts.minHeightToShowSubFeatures)return !1;let i,n,s;if(t.children){const u=t.children;if(s=0,n=u.length,n){for(i=0;i<n;i++)r=this._ins._distMgr.getNodeBoundsSize(u[i],e),s+=r[1];if(s/n<this._opts.minSubAvgHeightToShowSubFeatures)return !1}}const a=this._ins._distMgr.getParentAdcode(t.adcode,t.acroutes);if(a){const u=this._ins._distMgr.getNodeByAdcode(a),l=u.children;if(l||console.error("No children bound",t,u),n=l.length,n>1){for(s=0,i=0;i<n;i++)l[i].adcode!==t.adcode&&(r=this._ins._distMgr.getNodeBoundsSize(l[i],e),s+=r[1]);if(s/(n-1)<this._opts.minSiblingAvgHeightToShowSubFeatures)return !1}}return !0}_shouldShowSub(t){return !(!t.children||!t.children.length)&&this.shouldShowSubOnZoom(t,this._currentZoom)}_prepareFeatures(t,e){const r=[],i=[];for(let n=0,s=e.length;n<s;n++){const a=this._ins._distMgr.getNodeByAdcode(e[n]);if(!a)throw new Error(`Can not find node: ${e[n]}`);this._shouldShowSub(a)?i.push(e[n]):r.push(e[n]);}this._prepareSelfFeatures(t,r),this._prepareSubFeatures(t,i),this._checkLoadFinish(t);}_prepareSelfFeatures(t,e){let r;const i=this._currentZoom;for(let n=0,s=e.length;n<s;n++){const a=this._ins._distMgr.getNodeByAdcode(e[n]);if(r=null,a.acroutes){const u=this._ins._distMgr.getNodeByAdcode(a.acroutes[a.acroutes.length-1]);(!a.idealZoom||i<a.idealZoom-1||Math.abs(i-u.idealZoom)<=Math.abs(a.idealZoom-i))&&(r=u.adcode);}this._loadAndRenderSelf(t,r||e[n],e[n]);}}_prepareSubFeatures(t,e){let r,i;for(r=0,i=e.length;r<i;r++)this._loadAndRenderSub(t,e[r]);}_renderSelf(t,e,r){let i;if(e===r.getAdcode())i=r.getParentFeature();else {const n=r.getSubFeatures(),s=this._ins._distMgr.getSubIdx(e);if(i=n[s],!i){console.warn("Werid, can not find sub feature",r.getAdcode(),e);return}if(i.properties.adcode!==e){console.warn("Sub adcode not match!!",n,s);return}}this._ins.getDistCounter().calcDistGroup(e,!1,()=>{this.isRenderIdStillValid(t)&&this._prepRenderFeatureInPixel(t,i);},this);}_checkLoadFinish(t){if(this._loadLeft===0){const e=this;setTimeout(function(){e.isRenderIdStillValid(t)&&e._handleRenderFinish();},0);}}_renderSub(t,e){const r=e.getSubFeatures();this._ins.getDistCounter().calcDistGroup(e.getAdcode(),!0,()=>{if(this.isRenderIdStillValid(t))for(let i=0,n=r.length;i<n;i++)this._prepRenderFeatureInPixel(t,r[i]);},this);}_handleRenderFinish(){this._tryFreeMemery(),this._renderAllFeature();}_renderAllFeature(){this._renderAllFeatureByDefault();}_renderAllFeatureByDefault(){var t,e;const r=[],i=[],n=[],s=[];for(let a=0;a<this._polygonCache.length;a++){const u=this._polygonCache[a],l=u.getExtData()._data.adcode;let h=!1;for(let c=0;c<this._currentFeatures.length;c++){const d=this._currentFeatures[c].feature.properties;if(l===d.adcode){h=!0,this._currentFeatures.splice(c,1);break}}h||(i.push(u),this._polygonCache.splice(a,1),s.push(this._markerCache[a]),this._markerCache.splice(a,1),a--);}this._currentFeatures.forEach(a=>{const u=this._createPolygonFeature(a.feature,a.dataItems);this._opts.featureEventSupport&&(u.on("click",v.bind(h=>{this.emit("featureClick",h,a.feature),this._opts.featureClickToShowSub&&this._ins.zoomToShowSubFeatures(a.feature.properties.adcode);},this)),u.on("mouseover",v.bind(h=>{this.emit("featureMouseover",h,a.feature);},this)),u.on("mouseout",v.bind(h=>{this.emit("featureMouseout",h,a.feature);},this)));const l=this._createClusterMarker(a.feature,a.dataItems);this._opts.clusterMarkerEventSupport&&l.on("click",v.bind(h=>{this.emit("clusterMarkerClick",h,Ct$1({adcode:a.feature.properties.adcode},a)),this._opts.clusterMarkerClickToShowSub&&this._ins.zoomToShowSubFeatures(a.feature.properties.adcode);},this)),r.push(u),n.push(l);}),this.layer.remove(i),(t=this.markerGroup)===null||t===void 0||t.removeOverlays(s),this.layer.add(r),this._polygonCache.push(...r),r.length=0,(e=this.markerGroup)===null||e===void 0||e.addOverlays(n),this._markerCache.push(...n),n.length=0;}_tryFreeMemery(){this._ins.getDistMgr().tryClearCache(this._currentRenderId,this._opts.areaNodeCacheLimit);}_increaseLoadLeft(){this._loadLeft++;}_decreaseLoadLeft(t){this._loadLeft--,this._loadLeft===0&&this._checkLoadFinish(t);}_loadAndRenderSelf(t,e,r){this._ins.getDistMgr().touchAdcode(e,t);const i=this._ins._distMgr.getExplorer(),n=i.getLocalAreaNode(e);n?this._renderSelf(t,r,n):(this._increaseLoadLeft(),i.loadAreaNode(e,(s,a)=>{this.isRenderIdStillValid(t)&&(s?console.error(s):this._renderSelf(t,r,a),this._decreaseLoadLeft(t));},this));}_loadAndRenderSub(t,e){this._ins.getDistMgr().touchAdcode(e,t);const r=this._ins._distMgr.getExplorer(),i=r.getLocalAreaNode(e);i?this._renderSub(t,i):(this._increaseLoadLeft(),r.loadAreaNode(e,(n,s)=>{this.isRenderIdStillValid(t)&&(n?console.error(n):this._renderSub(t,s),this._decreaseLoadLeft(t));},this));}_prepRenderFeatureInPixel(t,e){if(!this._ins.getDistMgr().isExcludedAdcode(e.properties.adcode)){const r=this._ins.getDistCounter().getPackItemsByAdcode(e.properties.adcode);this._currentFeatures.push({feature:e,dataItems:r});}}_createPolygonFeature(t,e){const r=Object.assign({},t.properties);if(r.dataItems=e,this._opts.renderPolygon){const n=this._opts.renderPolygon(t,e),s=n.getExtData()||{};return s._data=r,n.setExtData(s),n}const i=this._getFeatureStyleOptions(t,e)||{};return new AMap.Polygon(Xe$1(Ct$1({path:t.geometry.coordinates},i),{extData:{_data:r}}))}_createClusterMarker(t,e){const r=t.properties;if(r.dataItems=e,this._opts.renderClusterMarker){const h=this._opts.renderClusterMarker(t,e),c=h.getExtData()||{};return c._data=r,h.setExtData(c),h}const i={title:"amap-ui-district-cluster-marker-title",body:"amap-ui-district-cluster-marker-body",container:"amap-ui-district-cluster-marker"},n=document.createElement("div"),s=document.createElement("span");s.className=i.title;const a=document.createElement("span");a.className=i.body,n.appendChild(s),n.appendChild(a);const u=[],l=[i.container,`level_${r.level}`,`adcode_${r.adcode}`];if(r.acroutes)for(let h=r.acroutes,c=0,d=h.length;c<d;c++)l.push(`descendant_of_${h[c]}`),c===d-1&&l.push(`child_of_${h[c]}`),c>0&&u.push(this._ins._distMgr.getNodeByAdcode(h[c]).name);return n.className=l.join(" "),u.length>0?(u.push(r.name),n.setAttribute("title",u.join(">"))):n.removeAttribute("title"),s.innerHTML=v.escapeHtml(r.name),a.innerHTML=e.length,new AMap.Marker({topWhenClick:!0,offset:new AMap.Pixel(-20,-30),content:n,position:r.center,extData:{_data:r}})}_getFeatureStyleOptions(t,e){const r=this._opts.getFeatureStyle,i=this._opts.featureStyleByLevel[t.properties.level];if(!r)return i;const n=r.call(null,t,e);return n?v.extend({},this._opts.featureStyleByLevel[t.properties.level],n):i}renderLater(t){this._renderLaterId||(this._renderLaterId=setTimeout(()=>{this.render();},t||100));}isRendering(){return this._isRendering}render(){this._renderLaterId&&(clearTimeout(this._renderLaterId),this._renderLaterId=null),this._isRendering=!0,this._ins._distMgr.onReady(this.renderViewport,this,!0);}forceRender(){this._renderLaterId&&(clearTimeout(this._renderLaterId),this._renderLaterId=null),this._isRendering=!0,this.clear(),this._ins._distMgr.onReady(this.renderViewport,this,!0);}getOption(t){return this._opts[t]}getOptions(){return this._opts}show(){var t;this.layer.show(),(t=this.markerGroup)===null||t===void 0||t.show();}hide(){var t;this.layer.hide(),(t=this.markerGroup)===null||t===void 0||t.hide();}clear(){var t;this.layer.clear(),(t=this.markerGroup)===null||t===void 0||t.clearOverlays(),this._polygonCache=[],this._markerCache=[];}setzIndex(t){this.layer.setzIndex(t);}getZooms(){return this._opts.zooms}destroy(){this._map.removeLayer(this.layer),this._map.remove(this.markerGroup),this._currentFeatures=[],this.clear(),this.layer=null,this._map=null,this._ins=null;}};let Je$1 = class Je{constructor(t,e,r){this.x=t,this.y=e,this.idx=r;}};var Ke$1=Object.defineProperty,tr$1=Object.defineProperties,er=Object.getOwnPropertyDescriptors,Dt$1=Object.getOwnPropertySymbols,rr=Object.prototype.hasOwnProperty,ir$1=Object.prototype.propertyIsEnumerable,Tt$1=(o,t,e)=>t in o?Ke$1(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,nr$1=(o,t)=>{for(var e in t||(t={}))rr.call(t,e)&&Tt$1(o,e,t[e]);if(Dt$1)for(var e of Dt$1(t))ir$1.call(t,e)&&Tt$1(o,e,t[e]);return o},or$1=(o,t)=>tr$1(o,er(t));let sr$1 = class sr extends Y$1{constructor(t){super(),this._data={list:[],bounds:null,source:null},this._mouseEvent=v.bind(v.debounce(()=>{this.renderLater();},50),this),this.initCSS();const e={autoSetFitView:!0,topAdcodes:[1e5],visible:!0,excludedAdcodes:null,zIndex:10,renderOptions:{}};this._opts=v.extend({},e,t),this.map=t.map,this._distMgr=new Ze$1({topAdcodes:this._opts.topAdcodes,excludedAdcodes:this._opts.excludedAdcodes}),this._distCounter=new qe$1({distMgr:this._distMgr,pointPackerThisArg:this,pointPacker:r=>this._packDataItem(r)}),this.renderEngine=new Qe$1(this,or$1(nr$1({},t.renderOptions),{zIndex:this._opts.zIndex,visible:this._opts.visible,map:t.map})),this.renderEngine.on("*",(r,...i)=>{this.emit(r,...i);}),this._opts.data&&this.setData(this._opts.data),this.bindOrUnbindMapEvent();}bindOrUnbindMapEvent(t=!0){const e=t?"on":"off";this.map[e]("moveend",this._mouseEvent),this.map[e]("zoomend",this._mouseEvent),this.map[e]("resize",this._mouseEvent),this.map[e]("rotateend",this._mouseEvent),this.map[e]("dragend",this._mouseEvent);}initCSS(){const t="_amap_district_cluster_css";if(document.getElementById(t))return;const e=".amap-ui-district-cluster-container{cursor:default;-webkit-backface-visibility:hidden;-webkit-transform:translateZ(0) scale(1,1)}.amap-ui-district-cluster-container canvas{position:absolute}.amap-ui-district-cluster-container .amap-ui-hide{display:none!important}.amap-ui-district-cluster-container .overlay-title,.amap-ui-district-cluster-marker{color:#555;background-color:#fffeef;font-size:12px;white-space:nowrap;position:absolute}.amap-ui-district-cluster-container .overlay-title{padding:2px 6px;display:inline-block;z-index:99999;border:1px solid #7e7e7e;border-radius:2px}.amap-ui-district-cluster-container .overlay-title:after,.amap-ui-district-cluster-container .overlay-title:before{content:'';display:block;position:absolute;margin:auto;width:0;height:0;border:solid transparent;border-width:5px}.amap-ui-district-cluster-container .overlay-title.left{transform:translate(10px,-50%)}.amap-ui-district-cluster-container .overlay-title.left:before{top:5px}.amap-ui-district-cluster-container .overlay-title.left:after{left:-9px;top:5px;border-right-color:#fffeef}.amap-ui-district-cluster-container .overlay-title.left:before{left:-10px;border-right-color:#7e7e7e}.amap-ui-district-cluster-container .overlay-title.top{transform:translate(-50%,-130%)}.amap-ui-district-cluster-container .overlay-title.top:before{left:0;right:0}.amap-ui-district-cluster-container .overlay-title.top:after{bottom:-9px;left:0;right:0;border-top-color:#fffeef}.amap-ui-district-cluster-container .overlay-title.top:before{bottom:-10px;border-top-color:#7e7e7e}.amap-ui-district-cluster-marker{border:1px solid #8e8e8e;width:auto;height:22px;border-radius:5px 5px 5px 0;left:0;top:0}.amap-ui-district-cluster-marker:after,.amap-ui-district-cluster-marker:before{content:'';display:block;position:absolute;width:0;height:0;border:solid rgba(0,0,0,0);border-width:6px;left:13px}.amap-ui-district-cluster-marker:after{bottom:-12px;border-top-color:#fffeef}.amap-ui-district-cluster-marker:before{bottom:-13px;border-top-color:#8e8e8e}.amap-ui-district-cluster-marker span{vertical-align:middle;padding:3px 5px;display:inline-block;height:16px;line-height:16px}.amap-ui-district-cluster-marker-title{border-radius:5px 0 0 0}.amap-ui-district-cluster-marker-body{background-color:#dc3912;color:#fff;border-radius:0 5px 5px 0}.amap-ui-district-cluster-marker.level_country .amap-ui-district-cluster-marker-body{background-color:#36c}.amap-ui-district-cluster-marker.level_province .amap-ui-district-cluster-marker-body{background-color:#dc3912}.amap-ui-district-cluster-marker.level_city .amap-ui-district-cluster-marker-body{background-color:#909}.amap-ui-district-cluster-marker.level_district .amap-ui-district-cluster-marker-body{background-color:#d47}",r=document,i="appendChild",n="styleSheet",s=r.createElement("style");s.id=t,s.type="text/css",r.getElementsByTagName("head")[0][i](s),s[n]?s[n].cssText=e:s[i](r.createTextNode(e));}getMinZoomToShowSub(t){return this.renderEngine.getMinZoomToShowSub(t)}getAreaNodeProps(t){return this._distMgr.getNodeByAdcode(t)}getDistrictExplorer(){return this._distMgr.getExplorer()}getRender(){return this.renderEngine}zoomToShowSubFeatures(t,e){this.renderEngine.zoomToShowSubFeatures(t,e);}renderLater(t){this.renderEngine.renderLater(t);}render(){this.renderEngine.render();}forceRender(){this.renderEngine.forceRender();}getDistMgr(){return this._distMgr}_clearData(){this.trigger("willClearData"),this._data?this._data.list.length=0:this._data={list:[],bounds:null},this._data.source=null,this._data.bounds=null,this._data.kdTree=null,this._distCounter.clearData(),this.trigger("didClearData");}_buildDataItems(t){const e=this._opts,r=e.getPosition,i=this._data.list,n=this._data.bounds;for(let s=0,a=t.length;s<a;s++){let u=t[s],l=r.call(this,u,s);l&&(l.getLng&&(l=[l.getLng(),l.getLat()]),i[s]=new Je$1(l[0],l[1],s),n.expandByPoint(l[0],l[1]));}}getDataItemsByBounds(t){const e=this._data.kdTree;if(!e)return null;const r=t.getSouthWest(),i=t.getNorthEast(),n=this._data.list,s=e.range(r.getLng(),r.getLat(),i.getLng(),i.getLat()),a=[];for(let u=0,l=s.length;u<l;u++)a[u]=this._packDataItem(n[s[u]]);return a}_packDataItem(t){if(!t)return null;if(!t._packedItem){const e=t.idx,r=[t.x,t.y];t._packedItem={dataIndex:e,dataItem:this._data.source[e],position:r};}return t._packedItem}_buildData(t){this._clearData(),this.trigger("willBuildData",t),this._data.source=t,this._data.bounds=C.getBoundsItemToExpand(),this._buildDataItems(t),this._distCounter.setData(this._data.list),this.trigger("didBuildData",t);}setData(t){t||(t=[]),this._buildData(t),this.forceRender(),t.length&&this._opts.autoSetFitView&&this.setFitView();}isReady(){return this._distMgr.isReady()&&!!this._data}setFitView(){const t=this._data.bounds,e=this.getMap(),r=new AMap.Bounds([t.x,t.y],[t.x+t.width,t.y+t.height]);e&&e.setBounds(r);}getDistCounter(){return this._distCounter}getMap(){return this._opts.map}getZooms(){return this.renderEngine.getZooms()}isHidden(){return !this._opts.visible}show(){return this._opts.visible=!0,this.getRender().show()}hide(){return this._opts.visible=!1,this.getRender().hide()}destroy(){this.bindOrUnbindMapEvent(!1),this.getRender().destroy(),this._distCounter.destroy(),this._distMgr.destroy(),this.renderEngine=null,this._data={list:[],bounds:null},this._distMgr=null,this.map=void 0,this._opts=void 0;}getzIndex(){return this._opts.zIndex}setzIndex(t){this._opts.zIndex=t,this.getRender().setzIndex(t);}};

var script$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerDistrictCluster",
    inheritAttrs: false
  },
  __name: "DistrictCluster",
  props: buildProps({
    data: {
      required: true,
      type: Array
    },
    // 数据源数组，每个元素即为点相关的信息
    getPosition: {
      type: Function
    },
    // 返回数据项中的经纬度信息
    autoSetFitView: {
      type: Boolean,
      default: true
    },
    // 是否在绘制后自动调整地图视野以适合全部点，默认true
    topAdcodes: {
      type: Array
    },
    // 顶层区划的adcode列表
    excludedAdcodes: {
      type: Array
    },
    renderOptions: {
      type: Object
    }
    // 绘制的引擎的参数
  }),
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        options.map = parentComponent;
        $amapComponent = new sr$1(options);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent) {
          $amapComponent.destroy();
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script$1.__file = "src/vue-amap/packages/layer/data/DistrictCluster/DistrictCluster.vue";

script$1.install = (app) => {
  app.component(script$1.name, script$1);
  return app;
};
const ElAmapLayerDistrictCluster = script$1;

var hr={exports:{}};hr.exports=cr,hr.exports.default=cr;function cr(r,e,t){t=t||2;var n=e&&e.length,i=n?e[0]*t:r.length,a=Zr(r,0,i,t,!0),s=[];if(!a||a.next===a.prev)return s;var h,c,l,f,v,o,M;if(n&&(a=ct(r,e,a,t)),r.length>80*t){h=l=r[0],c=f=r[1];for(var p=t;p<i;p+=t)v=r[p],o=r[p+1],v<h&&(h=v),o<c&&(c=o),v>l&&(l=v),o>f&&(f=o);M=Math.max(l-h,f-c),M=M!==0?32767/M:0;}return tr(a,s,t,h,c,M,0),s}function Zr(r,e,t,n,i){var a,s;if(i===wr(r,e,t,n)>0)for(a=e;a<t;a+=n)s=Ur(a,r[a],r[a+1],s);else for(a=t-n;a>=e;a-=n)s=Ur(a,r[a],r[a+1],s);return s&&lr(s,s.next)&&(ir(s),s=s.next),s}function H(r,e){if(!r)return r;e||(e=r);var t=r,n;do if(n=!1,!t.steiner&&(lr(t,t.next)||Y(t.prev,t,t.next)===0)){if(ir(t),t=e=t.prev,t===t.next)break;n=!0;}else t=t.next;while(n||t!==e);return e}function tr(r,e,t,n,i,a,s){if(!!r){!s&&a&&Mt(r,n,i,a);for(var h=r,c,l;r.prev!==r.next;){if(c=r.prev,l=r.next,a?at(r,n,i,a):it(r)){e.push(c.i/t|0),e.push(r.i/t|0),e.push(l.i/t|0),ir(r),r=l.next,h=l.next;continue}if(r=l,r===h){s?s===1?(r=st(H(r),e,t),tr(r,e,t,n,i,a,2)):s===2&&ht(r,e,t,n,i,a):tr(H(r),e,t,n,i,a,1);break}}}}function it(r){var e=r.prev,t=r,n=r.next;if(Y(e,t,n)>=0)return !1;for(var i=e.x,a=t.x,s=n.x,h=e.y,c=t.y,l=n.y,f=i<a?i<s?i:s:a<s?a:s,v=h<c?h<l?h:l:c<l?c:l,o=i>a?i>s?i:s:a>s?a:s,M=h>c?h>l?h:l:c>l?c:l,p=n.next;p!==e;){if(p.x>=f&&p.x<=o&&p.y>=v&&p.y<=M&&j(i,h,a,c,s,l,p.x,p.y)&&Y(p.prev,p,p.next)>=0)return !1;p=p.next;}return !0}function at(r,e,t,n){var i=r.prev,a=r,s=r.next;if(Y(i,a,s)>=0)return !1;for(var h=i.x,c=a.x,l=s.x,f=i.y,v=a.y,o=s.y,M=h<c?h<l?h:l:c<l?c:l,p=f<v?f<o?f:o:v<o?v:o,x=h>c?h>l?h:l:c>l?c:l,y=f>v?f>o?f:o:v>o?v:o,d=Pr(M,p,e,t,n),R=Pr(x,y,e,t,n),m=r.prevZ,g=r.nextZ;m&&m.z>=d&&g&&g.z<=R;){if(m.x>=M&&m.x<=x&&m.y>=p&&m.y<=y&&m!==i&&m!==s&&j(h,f,c,v,l,o,m.x,m.y)&&Y(m.prev,m,m.next)>=0||(m=m.prevZ,g.x>=M&&g.x<=x&&g.y>=p&&g.y<=y&&g!==i&&g!==s&&j(h,f,c,v,l,o,g.x,g.y)&&Y(g.prev,g,g.next)>=0))return !1;g=g.nextZ;}for(;m&&m.z>=d;){if(m.x>=M&&m.x<=x&&m.y>=p&&m.y<=y&&m!==i&&m!==s&&j(h,f,c,v,l,o,m.x,m.y)&&Y(m.prev,m,m.next)>=0)return !1;m=m.prevZ;}for(;g&&g.z<=R;){if(g.x>=M&&g.x<=x&&g.y>=p&&g.y<=y&&g!==i&&g!==s&&j(h,f,c,v,l,o,g.x,g.y)&&Y(g.prev,g,g.next)>=0)return !1;g=g.nextZ;}return !0}function st(r,e,t){var n=r;do{var i=n.prev,a=n.next.next;!lr(i,a)&&Dr(i,n,n.next,a)&&nr(i,a)&&nr(a,i)&&(e.push(i.i/t|0),e.push(n.i/t|0),e.push(a.i/t|0),ir(n),ir(n.next),n=r=a),n=n.next;}while(n!==r);return H(n)}function ht(r,e,t,n,i,a){var s=r;do{for(var h=s.next.next;h!==s.prev;){if(s.i!==h.i&&xt(s,h)){var c=Vr(s,h);s=H(s,s.next),c=H(c,c.next),tr(s,e,t,n,i,a,0),tr(c,e,t,n,i,a,0);return}h=h.next;}s=s.next;}while(s!==r)}function ct(r,e,t,n){var i=[],a,s,h,c,l;for(a=0,s=e.length;a<s;a++)h=e[a]*n,c=a<s-1?e[a+1]*n:r.length,l=Zr(r,h,c,n,!1),l===l.next&&(l.steiner=!0),i.push(yt(l));for(i.sort(lt),a=0;a<i.length;a++)t=ft(i[a],t);return t}function lt(r,e){return r.x-e.x}function ft(r,e){var t=ot(r,e);if(!t)return e;var n=Vr(t,r);return H(n,n.next),H(t,t.next)}function ot(r,e){var t=e,n=r.x,i=r.y,a=-1/0,s;do{if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){var h=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(h<=n&&h>a&&(a=h,s=t.x<t.next.x?t:t.next,h===n))return s}t=t.next;}while(t!==e);if(!s)return null;var c=s,l=s.x,f=s.y,v=1/0,o;t=s;do n>=t.x&&t.x>=l&&n!==t.x&&j(i<f?n:a,i,l,f,i<f?a:n,i,t.x,t.y)&&(o=Math.abs(i-t.y)/(n-t.x),nr(t,r)&&(o<v||o===v&&(t.x>s.x||t.x===s.x&&vt(s,t)))&&(s=t,v=o)),t=t.next;while(t!==c);return s}function vt(r,e){return Y(r.prev,r,e.prev)<0&&Y(e.next,r,r.next)<0}function Mt(r,e,t,n){var i=r;do i.z===0&&(i.z=Pr(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,pt(i);}function pt(r){var e,t,n,i,a,s,h,c,l=1;do{for(t=r,r=null,a=null,s=0;t;){for(s++,n=t,h=0,e=0;e<l&&(h++,n=n.nextZ,!!n);e++);for(c=l;h>0||c>0&&n;)h!==0&&(c===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,h--):(i=n,n=n.nextZ,c--),a?a.nextZ=i:r=i,i.prevZ=a,a=i;t=n;}a.nextZ=null,l*=2;}while(s>1);return r}function Pr(r,e,t,n,i){return r=(r-t)*i|0,e=(e-n)*i|0,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function yt(r){var e=r,t=r;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==r);return t}function j(r,e,t,n,i,a,s,h){return (i-s)*(e-h)>=(r-s)*(a-h)&&(r-s)*(n-h)>=(t-s)*(e-h)&&(t-s)*(a-h)>=(i-s)*(n-h)}function xt(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!mt(r,e)&&(nr(r,e)&&nr(e,r)&&dt(r,e)&&(Y(r.prev,r,e.prev)||Y(r,e.prev,e))||lr(r,e)&&Y(r.prev,r,r.next)>0&&Y(e.prev,e,e.next)>0)}function Y(r,e,t){return (e.y-r.y)*(t.x-e.x)-(e.x-r.x)*(t.y-e.y)}function lr(r,e){return r.x===e.x&&r.y===e.y}function Dr(r,e,t,n){var i=or(Y(r,e,t)),a=or(Y(r,e,n)),s=or(Y(t,n,r)),h=or(Y(t,n,e));return !!(i!==a&&s!==h||i===0&&fr(r,t,e)||a===0&&fr(r,n,e)||s===0&&fr(t,r,n)||h===0&&fr(t,e,n))}function fr(r,e,t){return e.x<=Math.max(r.x,t.x)&&e.x>=Math.min(r.x,t.x)&&e.y<=Math.max(r.y,t.y)&&e.y>=Math.min(r.y,t.y)}function or(r){return r>0?1:r<0?-1:0}function mt(r,e){var t=r;do{if(t.i!==r.i&&t.next.i!==r.i&&t.i!==e.i&&t.next.i!==e.i&&Dr(t,t.next,r,e))return !0;t=t.next;}while(t!==r);return !1}function nr(r,e){return Y(r.prev,r,r.next)<0?Y(r,e,r.next)>=0&&Y(r,r.prev,e)>=0:Y(r,e,r.prev)<0||Y(r,r.next,e)<0}function dt(r,e){var t=r,n=!1,i=(r.x+e.x)/2,a=(r.y+e.y)/2;do t.y>a!=t.next.y>a&&t.next.y!==t.y&&i<(t.next.x-t.x)*(a-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==r);return n}function Vr(r,e){var t=new Lr(r.i,r.x,r.y),n=new Lr(e.i,e.x,e.y),i=r.next,a=e.prev;return r.next=e,e.prev=r,t.next=i,i.prev=t,n.next=t,t.prev=n,a.next=n,n.prev=a,n}function Ur(r,e,t,n){var i=new Lr(r,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function ir(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ);}function Lr(r,e,t){this.i=r,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1;}cr.deviation=function(r,e,t,n){var i=e&&e.length,a=i?e[0]*t:r.length,s=Math.abs(wr(r,0,a,t));if(i)for(var h=0,c=e.length;h<c;h++){var l=e[h]*t,f=h<c-1?e[h+1]*t:r.length;s-=Math.abs(wr(r,l,f,t));}var v=0;for(h=0;h<n.length;h+=3){var o=n[h]*t,M=n[h+1]*t,p=n[h+2]*t;v+=Math.abs((r[o]-r[p])*(r[M+1]-r[o+1])-(r[o]-r[M])*(r[p+1]-r[o+1]));}return s===0&&v===0?0:Math.abs((v-s)/s)};function wr(r,e,t,n){for(var i=0,a=e,s=t-n;a<t;a+=n)i+=(r[s]-r[a])*(r[a+1]+r[s+1]),s=a;return i}cr.flatten=function(r){for(var e=r[0][0].length,t={vertices:[],holes:[],dimensions:e},n=0,i=0;i<r.length;i++){for(var a=0;a<r[i].length;a++)for(var s=0;s<e;s++)t.vertices.push(r[i][a][s]);i>0&&(n+=r[i-1].length,t.holes.push(n));}return t};const X={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0};function gt(r,{precision:e=X.precision}={}){return r=ut(r),"".concat(parseFloat(r.toPrecision(e)))}function $r(r){return Array.isArray(r)||ArrayBuffer.isView(r)&&!(r instanceof DataView)}function Xr(r,e,t){const n=X.EPSILON;t&&(X.EPSILON=t);try{if(r===e)return !0;if($r(r)&&$r(e)){if(r.length!==e.length)return !1;for(let i=0;i<r.length;++i)if(!Xr(r[i],e[i]))return !1;return !0}return r&&r.equals?r.equals(e):e&&e.equals?e.equals(r):typeof r=="number"&&typeof e=="number"?Math.abs(r-e)<=X.EPSILON*Math.max(1,Math.abs(r),Math.abs(e)):!1}finally{X.EPSILON=n;}}function ut(r){return Math.round(r/X.EPSILON)*X.EPSILON}function Tt(r){function e(){var t=Reflect.construct(r,Array.from(arguments));return Object.setPrototypeOf(t,Object.getPrototypeOf(this)),t}return e.prototype=Object.create(r.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),Object.setPrototypeOf?Object.setPrototypeOf(e,r):e.__proto__=r,e}class Et extends Tt(Array){clone(){return new this.constructor().copy(this)}fromArray(e,t=0){for(let n=0;n<this.ELEMENTS;++n)this[n]=e[n+t];return this.check()}toArray(e=[],t=0){for(let n=0;n<this.ELEMENTS;++n)e[t+n]=this[n];return e}from(e){return Array.isArray(e)?this.copy(e):this.fromObject(e)}to(e){return e===this?this:$r(e)?this.toArray(e):this.toObject(e)}toTarget(e){return e?this.to(e):this}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(X)}formatString(e){let t="";for(let n=0;n<this.ELEMENTS;++n)t+=(n>0?", ":"")+gt(this[n],e);return "".concat(e.printTypes?this.constructor.name:"","[").concat(t,"]")}equals(e){if(!e||this.length!==e.length)return !1;for(let t=0;t<this.ELEMENTS;++t)if(!Xr(this[t],e[t]))return !1;return !0}exactEquals(e){if(!e||this.length!==e.length)return !1;for(let t=0;t<this.ELEMENTS;++t)if(this[t]!==e[t])return !1;return !0}negate(){for(let e=0;e<this.ELEMENTS;++e)this[e]=-this[e];return this.check()}lerp(e,t,n){if(n===void 0)return this.lerp(this,e,t);for(let i=0;i<this.ELEMENTS;++i){const a=e[i];this[i]=a+n*(t[i]-a);}return this.check()}min(e){for(let t=0;t<this.ELEMENTS;++t)this[t]=Math.min(e[t],this[t]);return this.check()}max(e){for(let t=0;t<this.ELEMENTS;++t)this[t]=Math.max(e[t],this[t]);return this.check()}clamp(e,t){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e[n]),t[n]);return this.check()}add(...e){for(const t of e)for(let n=0;n<this.ELEMENTS;++n)this[n]+=t[n];return this.check()}subtract(...e){for(const t of e)for(let n=0;n<this.ELEMENTS;++n)this[n]-=t[n];return this.check()}scale(e){if(typeof e=="number")for(let t=0;t<this.ELEMENTS;++t)this[t]*=e;else for(let t=0;t<this.ELEMENTS&&t<e.length;++t)this[t]*=e[t];return this.check()}multiplyByScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]*=e;return this.check()}check(){if(X.debug&&!this.validate())throw new Error("math.gl: ".concat(this.constructor.name," some fields set to invalid numbers'"));return this}validate(){let e=this.length===this.ELEMENTS;for(let t=0;t<this.ELEMENTS;++t)e=e&&Number.isFinite(this[t]);return e}sub(e){return this.subtract(e)}setScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]=e;return this.check()}addScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]+=e;return this.check()}subScalar(e){return this.addScalar(-e)}multiplyScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]*=e;return this.check()}divideScalar(e){return this.multiplyByScalar(1/e)}clampScalar(e,t){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e),t);return this.check()}get elements(){return this}}function _t(r,e){if(r.length!==e)return !1;for(let t=0;t<r.length;++t)if(!Number.isFinite(r[t]))return !1;return !0}function Rt(r){if(!Number.isFinite(r))throw new Error("Invalid number ".concat(r));return r}function Sr(r,e,t=""){if(X.debug&&!_t(r,e))throw new Error("math.gl: ".concat(t," some fields set to invalid numbers'"));return r}var _={},W={};Object.defineProperty(W,"__esModule",{value:!0}),W.setMatrixArrayType=At,W.toRadian=Lt,W.equals=wt,W.RANDOM=W.ARRAY_TYPE=W.EPSILON=void 0;var Ir=1e-6;W.EPSILON=Ir;var Kr=typeof Float32Array!="undefined"?Float32Array:Array;W.ARRAY_TYPE=Kr;var Ot=Math.random;W.RANDOM=Ot;function At(r){W.ARRAY_TYPE=Kr=r;}var Pt=Math.PI/180;function Lt(r){return r*Pt}function wt(r,e){return Math.abs(r-e)<=Ir*Math.max(1,Math.abs(r),Math.abs(e))}Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)});function vr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?vr=function(t){return typeof t}:vr=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},vr(r)}Object.defineProperty(_,"__esModule",{value:!0}),_.create=Hr,_.clone=zt,_.fromValues=Ct,_.copy=Ft,_.set=Nt,_.add=bt,_.subtract=Qr,_.multiply=Jr,_.divide=jr,_.ceil=qt,_.floor=Yt,_.min=kt,_.max=Wt,_.round=Bt,_.scale=Zt,_.scaleAndAdd=Dt,_.distance=re,_.squaredDistance=ee,_.length=te,_.squaredLength=ne,_.negate=Vt,_.inverse=Ut,_.normalize=Xt,_.dot=It,_.cross=Kt,_.lerp=Gt,_.random=Ht,_.transformMat2=Qt,_.transformMat2d=Jt,_.transformMat3=jt;var $t=_.transformMat4=rn;_.rotate=en,_.angle=tn,_.zero=nn,_.str=an,_.exactEquals=sn,_.equals=hn,_.forEach=_.sqrLen=_.sqrDist=_.dist=_.div=_.mul=_.sub=_.len=void 0;var Q=St(W);function Gr(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,t=new WeakMap;return (Gr=function(i){return i?t:e})(r)}function St(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||vr(r)!=="object"&&typeof r!="function")return {default:r};var t=Gr(e);if(t&&t.has(r))return t.get(r);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=r[a];}return n.default=r,t&&t.set(r,n),n}function Hr(){var r=new Q.ARRAY_TYPE(2);return Q.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0),r}function zt(r){var e=new Q.ARRAY_TYPE(2);return e[0]=r[0],e[1]=r[1],e}function Ct(r,e){var t=new Q.ARRAY_TYPE(2);return t[0]=r,t[1]=e,t}function Ft(r,e){return r[0]=e[0],r[1]=e[1],r}function Nt(r,e,t){return r[0]=e,r[1]=t,r}function bt(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r}function Qr(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r}function Jr(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r}function jr(r,e,t){return r[0]=e[0]/t[0],r[1]=e[1]/t[1],r}function qt(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r}function Yt(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r}function kt(r,e,t){return r[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r}function Wt(r,e,t){return r[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r}function Bt(r,e){return r[0]=Math.round(e[0]),r[1]=Math.round(e[1]),r}function Zt(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r}function Dt(r,e,t,n){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r}function re(r,e){var t=e[0]-r[0],n=e[1]-r[1];return Math.hypot(t,n)}function ee(r,e){var t=e[0]-r[0],n=e[1]-r[1];return t*t+n*n}function te(r){var e=r[0],t=r[1];return Math.hypot(e,t)}function ne(r){var e=r[0],t=r[1];return e*e+t*t}function Vt(r,e){return r[0]=-e[0],r[1]=-e[1],r}function Ut(r,e){return r[0]=1/e[0],r[1]=1/e[1],r}function Xt(r,e){var t=e[0],n=e[1],i=t*t+n*n;return i>0&&(i=1/Math.sqrt(i)),r[0]=e[0]*i,r[1]=e[1]*i,r}function It(r,e){return r[0]*e[0]+r[1]*e[1]}function Kt(r,e,t){var n=e[0]*t[1]-e[1]*t[0];return r[0]=r[1]=0,r[2]=n,r}function Gt(r,e,t,n){var i=e[0],a=e[1];return r[0]=i+n*(t[0]-i),r[1]=a+n*(t[1]-a),r}function Ht(r,e){e=e||1;var t=Q.RANDOM()*2*Math.PI;return r[0]=Math.cos(t)*e,r[1]=Math.sin(t)*e,r}function Qt(r,e,t){var n=e[0],i=e[1];return r[0]=t[0]*n+t[2]*i,r[1]=t[1]*n+t[3]*i,r}function Jt(r,e,t){var n=e[0],i=e[1];return r[0]=t[0]*n+t[2]*i+t[4],r[1]=t[1]*n+t[3]*i+t[5],r}function jt(r,e,t){var n=e[0],i=e[1];return r[0]=t[0]*n+t[3]*i+t[6],r[1]=t[1]*n+t[4]*i+t[7],r}function rn(r,e,t){var n=e[0],i=e[1];return r[0]=t[0]*n+t[4]*i+t[12],r[1]=t[1]*n+t[5]*i+t[13],r}function en(r,e,t,n){var i=e[0]-t[0],a=e[1]-t[1],s=Math.sin(n),h=Math.cos(n);return r[0]=i*h-a*s+t[0],r[1]=i*s+a*h+t[1],r}function tn(r,e){var t=r[0],n=r[1],i=e[0],a=e[1],s=Math.sqrt(t*t+n*n)*Math.sqrt(i*i+a*a),h=s&&(t*i+n*a)/s;return Math.acos(Math.min(Math.max(h,-1),1))}function nn(r){return r[0]=0,r[1]=0,r}function an(r){return "vec2("+r[0]+", "+r[1]+")"}function sn(r,e){return r[0]===e[0]&&r[1]===e[1]}function hn(r,e){var t=r[0],n=r[1],i=e[0],a=e[1];return Math.abs(t-i)<=Q.EPSILON*Math.max(1,Math.abs(t),Math.abs(i))&&Math.abs(n-a)<=Q.EPSILON*Math.max(1,Math.abs(n),Math.abs(a))}var cn=te;_.len=cn;var ln=Qr;_.sub=ln;var fn=Jr;_.mul=fn;var on=jr;_.div=on;var vn=re;_.dist=vn;var Mn=ee;_.sqrDist=Mn;var pn=ne;_.sqrLen=pn;var yn=function(){var r=Hr();return function(e,t,n,i,a,s){var h,c;for(t||(t=2),n||(n=0),i?c=Math.min(i*t+n,e.length):c=e.length,h=n;h<c;h+=t)r[0]=e[h],r[1]=e[h+1],a(r,r,s),e[h]=r[0],e[h+1]=r[1];return e}}();_.forEach=yn;function xn(r,e,t){const n=e[0],i=e[1],a=t[3]*n+t[7]*i||1;return r[0]=(t[0]*n+t[4]*i)/a,r[1]=(t[1]*n+t[5]*i)/a,r}function mn(r,e,t){const n=e[0],i=e[1],a=e[2],s=t[3]*n+t[7]*i+t[11]*a||1;return r[0]=(t[0]*n+t[4]*i+t[8]*a)/s,r[1]=(t[1]*n+t[5]*i+t[9]*a)/s,r[2]=(t[2]*n+t[6]*i+t[10]*a)/s,r}var T={};function Mr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Mr=function(t){return typeof t}:Mr=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Mr(r)}Object.defineProperty(T,"__esModule",{value:!0}),T.create=ae,T.clone=un,T.length=se,T.fromValues=Tn,T.copy=En,T.set=_n,T.add=Rn,T.subtract=he,T.multiply=ce,T.divide=le,T.ceil=On,T.floor=An,T.min=Pn,T.max=Ln,T.round=wn,T.scale=$n,T.scaleAndAdd=Sn,T.distance=fe,T.squaredDistance=oe,T.squaredLength=ve,T.negate=zn,T.inverse=Cn,T.normalize=Fn,T.dot=Me,T.cross=Nn,T.lerp=bn,T.hermite=qn,T.bezier=Yn,T.random=kn;var dn=T.transformMat4=Wn;T.transformMat3=Bn,T.transformQuat=Zn,T.rotateX=Dn,T.rotateY=Vn,T.rotateZ=Un,T.angle=Xn,T.zero=In,T.str=Kn,T.exactEquals=Gn,T.equals=Hn,T.forEach=T.sqrLen=T.len=T.sqrDist=T.dist=T.div=T.mul=T.sub=void 0;var I=gn(W);function ie(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,t=new WeakMap;return (ie=function(i){return i?t:e})(r)}function gn(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||Mr(r)!=="object"&&typeof r!="function")return {default:r};var t=ie(e);if(t&&t.has(r))return t.get(r);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=r[a];}return n.default=r,t&&t.set(r,n),n}function ae(){var r=new I.ARRAY_TYPE(3);return I.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function un(r){var e=new I.ARRAY_TYPE(3);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e}function se(r){var e=r[0],t=r[1],n=r[2];return Math.hypot(e,t,n)}function Tn(r,e,t){var n=new I.ARRAY_TYPE(3);return n[0]=r,n[1]=e,n[2]=t,n}function En(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r}function _n(r,e,t,n){return r[0]=e,r[1]=t,r[2]=n,r}function Rn(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r}function he(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}function ce(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r}function le(r,e,t){return r[0]=e[0]/t[0],r[1]=e[1]/t[1],r[2]=e[2]/t[2],r}function On(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r[2]=Math.ceil(e[2]),r}function An(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r[2]=Math.floor(e[2]),r}function Pn(r,e,t){return r[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r[2]=Math.min(e[2],t[2]),r}function Ln(r,e,t){return r[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r[2]=Math.max(e[2],t[2]),r}function wn(r,e){return r[0]=Math.round(e[0]),r[1]=Math.round(e[1]),r[2]=Math.round(e[2]),r}function $n(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}function Sn(r,e,t,n){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function fe(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2];return Math.hypot(t,n,i)}function oe(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2];return t*t+n*n+i*i}function ve(r){var e=r[0],t=r[1],n=r[2];return e*e+t*t+n*n}function zn(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r}function Cn(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r}function Fn(r,e){var t=e[0],n=e[1],i=e[2],a=t*t+n*n+i*i;return a>0&&(a=1/Math.sqrt(a)),r[0]=e[0]*a,r[1]=e[1]*a,r[2]=e[2]*a,r}function Me(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]}function Nn(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[0],h=t[1],c=t[2];return r[0]=i*c-a*h,r[1]=a*s-n*c,r[2]=n*h-i*s,r}function bn(r,e,t,n){var i=e[0],a=e[1],s=e[2];return r[0]=i+n*(t[0]-i),r[1]=a+n*(t[1]-a),r[2]=s+n*(t[2]-s),r}function qn(r,e,t,n,i,a){var s=a*a,h=s*(2*a-3)+1,c=s*(a-2)+a,l=s*(a-1),f=s*(3-2*a);return r[0]=e[0]*h+t[0]*c+n[0]*l+i[0]*f,r[1]=e[1]*h+t[1]*c+n[1]*l+i[1]*f,r[2]=e[2]*h+t[2]*c+n[2]*l+i[2]*f,r}function Yn(r,e,t,n,i,a){var s=1-a,h=s*s,c=a*a,l=h*s,f=3*a*h,v=3*c*s,o=c*a;return r[0]=e[0]*l+t[0]*f+n[0]*v+i[0]*o,r[1]=e[1]*l+t[1]*f+n[1]*v+i[1]*o,r[2]=e[2]*l+t[2]*f+n[2]*v+i[2]*o,r}function kn(r,e){e=e||1;var t=I.RANDOM()*2*Math.PI,n=I.RANDOM()*2-1,i=Math.sqrt(1-n*n)*e;return r[0]=Math.cos(t)*i,r[1]=Math.sin(t)*i,r[2]=n*e,r}function Wn(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[3]*n+t[7]*i+t[11]*a+t[15];return s=s||1,r[0]=(t[0]*n+t[4]*i+t[8]*a+t[12])/s,r[1]=(t[1]*n+t[5]*i+t[9]*a+t[13])/s,r[2]=(t[2]*n+t[6]*i+t[10]*a+t[14])/s,r}function Bn(r,e,t){var n=e[0],i=e[1],a=e[2];return r[0]=n*t[0]+i*t[3]+a*t[6],r[1]=n*t[1]+i*t[4]+a*t[7],r[2]=n*t[2]+i*t[5]+a*t[8],r}function Zn(r,e,t){var n=t[0],i=t[1],a=t[2],s=t[3],h=e[0],c=e[1],l=e[2],f=i*l-a*c,v=a*h-n*l,o=n*c-i*h,M=i*o-a*v,p=a*f-n*o,x=n*v-i*f,y=s*2;return f*=y,v*=y,o*=y,M*=2,p*=2,x*=2,r[0]=h+f+M,r[1]=c+v+p,r[2]=l+o+x,r}function Dn(r,e,t,n){var i=[],a=[];return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],a[0]=i[0],a[1]=i[1]*Math.cos(n)-i[2]*Math.sin(n),a[2]=i[1]*Math.sin(n)+i[2]*Math.cos(n),r[0]=a[0]+t[0],r[1]=a[1]+t[1],r[2]=a[2]+t[2],r}function Vn(r,e,t,n){var i=[],a=[];return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],a[0]=i[2]*Math.sin(n)+i[0]*Math.cos(n),a[1]=i[1],a[2]=i[2]*Math.cos(n)-i[0]*Math.sin(n),r[0]=a[0]+t[0],r[1]=a[1]+t[1],r[2]=a[2]+t[2],r}function Un(r,e,t,n){var i=[],a=[];return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],a[0]=i[0]*Math.cos(n)-i[1]*Math.sin(n),a[1]=i[0]*Math.sin(n)+i[1]*Math.cos(n),a[2]=i[2],r[0]=a[0]+t[0],r[1]=a[1]+t[1],r[2]=a[2]+t[2],r}function Xn(r,e){var t=r[0],n=r[1],i=r[2],a=e[0],s=e[1],h=e[2],c=Math.sqrt(t*t+n*n+i*i),l=Math.sqrt(a*a+s*s+h*h),f=c*l,v=f&&Me(r,e)/f;return Math.acos(Math.min(Math.max(v,-1),1))}function In(r){return r[0]=0,r[1]=0,r[2]=0,r}function Kn(r){return "vec3("+r[0]+", "+r[1]+", "+r[2]+")"}function Gn(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]}function Hn(r,e){var t=r[0],n=r[1],i=r[2],a=e[0],s=e[1],h=e[2];return Math.abs(t-a)<=I.EPSILON*Math.max(1,Math.abs(t),Math.abs(a))&&Math.abs(n-s)<=I.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-h)<=I.EPSILON*Math.max(1,Math.abs(i),Math.abs(h))}var Qn=he;T.sub=Qn;var Jn=ce;T.mul=Jn;var jn=le;T.div=jn;var ri=fe;T.dist=ri;var ei=oe;T.sqrDist=ei;var ti=se;T.len=ti;var ni=ve;T.sqrLen=ni;var ii=function(){var r=ae();return function(e,t,n,i,a,s){var h,c;for(t||(t=3),n||(n=0),i?c=Math.min(i*t+n,e.length):c=e.length,h=n;h<c;h+=t)r[0]=e[h],r[1]=e[h+1],r[2]=e[h+2],a(r,r,s),e[h]=r[0],e[h+1]=r[1],e[h+2]=r[2];return e}}();T.forEach=ii;class ai extends Et{toString(){let e="[";if(X.printRowMajor){e+="row-major:";for(let t=0;t<this.RANK;++t)for(let n=0;n<this.RANK;++n)e+=" ".concat(this[n*this.RANK+t]);}else {e+="column-major:";for(let t=0;t<this.ELEMENTS;++t)e+=" ".concat(this[t]);}return e+="]",e}getElementIndex(e,t){return t*this.RANK+e}getElement(e,t){return this[t*this.RANK+e]}setElement(e,t,n){return this[t*this.RANK+e]=Rt(n),this}getColumn(e,t=new Array(this.RANK).fill(-0)){const n=e*this.RANK;for(let i=0;i<this.RANK;++i)t[i]=this[n+i];return t}setColumn(e,t){const n=e*this.RANK;for(let i=0;i<this.RANK;++i)this[n+i]=t[i];return this}}var w={};function pr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?pr=function(t){return typeof t}:pr=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},pr(r)}Object.defineProperty(w,"__esModule",{value:!0}),w.create=hi,w.fromMat4=ci,w.clone=li,w.copy=fi,w.fromValues=oi,w.set=vi,w.identity=Mi,w.transpose=pi,w.invert=yi,w.adjoint=xi,w.determinant=mi,w.multiply=ye,w.translate=di,w.rotate=gi,w.scale=ui,w.fromTranslation=Ti,w.fromRotation=Ei,w.fromScaling=_i,w.fromMat2d=Ri,w.fromQuat=Oi,w.normalFromMat4=Ai,w.projection=Pi,w.str=Li,w.frob=wi,w.add=$i,w.subtract=xe,w.multiplyScalar=Si,w.multiplyScalarAndAdd=zi,w.exactEquals=Ci,w.equals=Fi,w.sub=w.mul=void 0;var B=si(W);function pe(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,t=new WeakMap;return (pe=function(i){return i?t:e})(r)}function si(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||pr(r)!=="object"&&typeof r!="function")return {default:r};var t=pe(e);if(t&&t.has(r))return t.get(r);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=r[a];}return n.default=r,t&&t.set(r,n),n}function hi(){var r=new B.ARRAY_TYPE(9);return B.ARRAY_TYPE!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[5]=0,r[6]=0,r[7]=0),r[0]=1,r[4]=1,r[8]=1,r}function ci(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[4],r[4]=e[5],r[5]=e[6],r[6]=e[8],r[7]=e[9],r[8]=e[10],r}function li(r){var e=new B.ARRAY_TYPE(9);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e}function fi(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r}function oi(r,e,t,n,i,a,s,h,c){var l=new B.ARRAY_TYPE(9);return l[0]=r,l[1]=e,l[2]=t,l[3]=n,l[4]=i,l[5]=a,l[6]=s,l[7]=h,l[8]=c,l}function vi(r,e,t,n,i,a,s,h,c,l){return r[0]=e,r[1]=t,r[2]=n,r[3]=i,r[4]=a,r[5]=s,r[6]=h,r[7]=c,r[8]=l,r}function Mi(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=1,r[5]=0,r[6]=0,r[7]=0,r[8]=1,r}function pi(r,e){if(r===e){var t=e[1],n=e[2],i=e[5];r[1]=e[3],r[2]=e[6],r[3]=t,r[5]=e[7],r[6]=n,r[7]=i;}else r[0]=e[0],r[1]=e[3],r[2]=e[6],r[3]=e[1],r[4]=e[4],r[5]=e[7],r[6]=e[2],r[7]=e[5],r[8]=e[8];return r}function yi(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],v=f*s-h*l,o=-f*a+h*c,M=l*a-s*c,p=t*v+n*o+i*M;return p?(p=1/p,r[0]=v*p,r[1]=(-f*n+i*l)*p,r[2]=(h*n-i*s)*p,r[3]=o*p,r[4]=(f*t-i*c)*p,r[5]=(-h*t+i*a)*p,r[6]=M*p,r[7]=(-l*t+n*c)*p,r[8]=(s*t-n*a)*p,r):null}function xi(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8];return r[0]=s*f-h*l,r[1]=i*l-n*f,r[2]=n*h-i*s,r[3]=h*c-a*f,r[4]=t*f-i*c,r[5]=i*a-t*h,r[6]=a*l-s*c,r[7]=n*c-t*l,r[8]=t*s-n*a,r}function mi(r){var e=r[0],t=r[1],n=r[2],i=r[3],a=r[4],s=r[5],h=r[6],c=r[7],l=r[8];return e*(l*a-s*c)+t*(-l*i+s*h)+n*(c*i-a*h)}function ye(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],v=e[8],o=t[0],M=t[1],p=t[2],x=t[3],y=t[4],d=t[5],R=t[6],m=t[7],g=t[8];return r[0]=o*n+M*s+p*l,r[1]=o*i+M*h+p*f,r[2]=o*a+M*c+p*v,r[3]=x*n+y*s+d*l,r[4]=x*i+y*h+d*f,r[5]=x*a+y*c+d*v,r[6]=R*n+m*s+g*l,r[7]=R*i+m*h+g*f,r[8]=R*a+m*c+g*v,r}function di(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],v=e[8],o=t[0],M=t[1];return r[0]=n,r[1]=i,r[2]=a,r[3]=s,r[4]=h,r[5]=c,r[6]=o*n+M*s+l,r[7]=o*i+M*h+f,r[8]=o*a+M*c+v,r}function gi(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],v=e[8],o=Math.sin(t),M=Math.cos(t);return r[0]=M*n+o*s,r[1]=M*i+o*h,r[2]=M*a+o*c,r[3]=M*s-o*n,r[4]=M*h-o*i,r[5]=M*c-o*a,r[6]=l,r[7]=f,r[8]=v,r}function ui(r,e,t){var n=t[0],i=t[1];return r[0]=n*e[0],r[1]=n*e[1],r[2]=n*e[2],r[3]=i*e[3],r[4]=i*e[4],r[5]=i*e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r}function Ti(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=1,r[5]=0,r[6]=e[0],r[7]=e[1],r[8]=1,r}function Ei(r,e){var t=Math.sin(e),n=Math.cos(e);return r[0]=n,r[1]=t,r[2]=0,r[3]=-t,r[4]=n,r[5]=0,r[6]=0,r[7]=0,r[8]=1,r}function _i(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=e[1],r[5]=0,r[6]=0,r[7]=0,r[8]=1,r}function Ri(r,e){return r[0]=e[0],r[1]=e[1],r[2]=0,r[3]=e[2],r[4]=e[3],r[5]=0,r[6]=e[4],r[7]=e[5],r[8]=1,r}function Oi(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t+t,h=n+n,c=i+i,l=t*s,f=n*s,v=n*h,o=i*s,M=i*h,p=i*c,x=a*s,y=a*h,d=a*c;return r[0]=1-v-p,r[3]=f-d,r[6]=o+y,r[1]=f+d,r[4]=1-l-p,r[7]=M-x,r[2]=o-y,r[5]=M+x,r[8]=1-l-v,r}function Ai(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],v=e[9],o=e[10],M=e[11],p=e[12],x=e[13],y=e[14],d=e[15],R=t*h-n*s,m=t*c-i*s,g=t*l-a*s,P=n*c-i*h,A=n*l-a*h,N=i*l-a*c,z=f*x-v*p,C=f*y-o*p,$=f*d-M*p,b=v*y-o*x,F=v*d-M*x,q=o*d-M*y,L=R*q-m*F+g*b+P*$-A*C+N*z;return L?(L=1/L,r[0]=(h*q-c*F+l*b)*L,r[1]=(c*$-s*q-l*C)*L,r[2]=(s*F-h*$+l*z)*L,r[3]=(i*F-n*q-a*b)*L,r[4]=(t*q-i*$+a*C)*L,r[5]=(n*$-t*F-a*z)*L,r[6]=(x*N-y*A+d*P)*L,r[7]=(y*g-p*N-d*m)*L,r[8]=(p*A-x*g+d*R)*L,r):null}function Pi(r,e,t){return r[0]=2/e,r[1]=0,r[2]=0,r[3]=0,r[4]=-2/t,r[5]=0,r[6]=-1,r[7]=1,r[8]=1,r}function Li(r){return "mat3("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+", "+r[4]+", "+r[5]+", "+r[6]+", "+r[7]+", "+r[8]+")"}function wi(r){return Math.hypot(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8])}function $i(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r[3]=e[3]+t[3],r[4]=e[4]+t[4],r[5]=e[5]+t[5],r[6]=e[6]+t[6],r[7]=e[7]+t[7],r[8]=e[8]+t[8],r}function xe(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r[3]=e[3]-t[3],r[4]=e[4]-t[4],r[5]=e[5]-t[5],r[6]=e[6]-t[6],r[7]=e[7]-t[7],r[8]=e[8]-t[8],r}function Si(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r[3]=e[3]*t,r[4]=e[4]*t,r[5]=e[5]*t,r[6]=e[6]*t,r[7]=e[7]*t,r[8]=e[8]*t,r}function zi(r,e,t,n){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r[3]=e[3]+t[3]*n,r[4]=e[4]+t[4]*n,r[5]=e[5]+t[5]*n,r[6]=e[6]+t[6]*n,r[7]=e[7]+t[7]*n,r[8]=e[8]+t[8]*n,r}function Ci(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&r[5]===e[5]&&r[6]===e[6]&&r[7]===e[7]&&r[8]===e[8]}function Fi(r,e){var t=r[0],n=r[1],i=r[2],a=r[3],s=r[4],h=r[5],c=r[6],l=r[7],f=r[8],v=e[0],o=e[1],M=e[2],p=e[3],x=e[4],y=e[5],d=e[6],R=e[7],m=e[8];return Math.abs(t-v)<=B.EPSILON*Math.max(1,Math.abs(t),Math.abs(v))&&Math.abs(n-o)<=B.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(i-M)<=B.EPSILON*Math.max(1,Math.abs(i),Math.abs(M))&&Math.abs(a-p)<=B.EPSILON*Math.max(1,Math.abs(a),Math.abs(p))&&Math.abs(s-x)<=B.EPSILON*Math.max(1,Math.abs(s),Math.abs(x))&&Math.abs(h-y)<=B.EPSILON*Math.max(1,Math.abs(h),Math.abs(y))&&Math.abs(c-d)<=B.EPSILON*Math.max(1,Math.abs(c),Math.abs(d))&&Math.abs(l-R)<=B.EPSILON*Math.max(1,Math.abs(l),Math.abs(R))&&Math.abs(f-m)<=B.EPSILON*Math.max(1,Math.abs(f),Math.abs(m))}var Ni=ye;w.mul=Ni;var bi=xe;w.sub=bi;var me;((function(r){r[r.COL0ROW0=0]="COL0ROW0",r[r.COL0ROW1=1]="COL0ROW1",r[r.COL0ROW2=2]="COL0ROW2",r[r.COL1ROW0=3]="COL1ROW0",r[r.COL1ROW1=4]="COL1ROW1",r[r.COL1ROW2=5]="COL1ROW2",r[r.COL2ROW0=6]="COL2ROW0",r[r.COL2ROW1=7]="COL2ROW1",r[r.COL2ROW2=8]="COL2ROW2";}))(me||(me={}));var E={};function yr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?yr=function(t){return typeof t}:yr=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},yr(r)}Object.defineProperty(E,"__esModule",{value:!0}),E.create=Hi,E.clone=Qi,E.copy=Ji,E.fromValues=ji,E.set=r1,E.identity=ue;var qi=E.transpose=e1,Yi=E.invert=t1;E.adjoint=n1;var ki=E.determinant=i1,de=E.multiply=Te,Wi=E.translate=a1,Bi=E.scale=s1,Zi=E.rotate=h1,Di=E.rotateX=c1,Vi=E.rotateY=l1,Ui=E.rotateZ=f1;E.fromTranslation=o1,E.fromScaling=v1,E.fromRotation=M1,E.fromXRotation=p1,E.fromYRotation=y1,E.fromZRotation=x1,E.fromRotationTranslation=Ee,E.fromQuat2=m1,E.getTranslation=d1,E.getScaling=_e,E.getRotation=g1,E.fromRotationTranslationScale=u1,E.fromRotationTranslationScaleOrigin=T1;var Xi=E.fromQuat=E1,Ii=E.frustum=_1;E.perspectiveNO=Re,E.perspectiveZO=O1,E.perspectiveFromFieldOfView=A1,E.orthoNO=Ae,E.orthoZO=L1;var Ki=E.lookAt=w1;E.targetTo=$1,E.str=S1,E.frob=z1,E.add=C1,E.subtract=Le,E.multiplyScalar=F1,E.multiplyScalarAndAdd=N1,E.exactEquals=b1,E.equals=q1,E.sub=E.mul=Pe=E.ortho=Oe=E.perspective=void 0;var S=Gi(W);function ge(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,t=new WeakMap;return (ge=function(i){return i?t:e})(r)}function Gi(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||yr(r)!=="object"&&typeof r!="function")return {default:r};var t=ge(e);if(t&&t.has(r))return t.get(r);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=r[a];}return n.default=r,t&&t.set(r,n),n}function Hi(){var r=new S.ARRAY_TYPE(16);return S.ARRAY_TYPE!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=0,r[12]=0,r[13]=0,r[14]=0),r[0]=1,r[5]=1,r[10]=1,r[15]=1,r}function Qi(r){var e=new S.ARRAY_TYPE(16);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],e}function Ji(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function ji(r,e,t,n,i,a,s,h,c,l,f,v,o,M,p,x){var y=new S.ARRAY_TYPE(16);return y[0]=r,y[1]=e,y[2]=t,y[3]=n,y[4]=i,y[5]=a,y[6]=s,y[7]=h,y[8]=c,y[9]=l,y[10]=f,y[11]=v,y[12]=o,y[13]=M,y[14]=p,y[15]=x,y}function r1(r,e,t,n,i,a,s,h,c,l,f,v,o,M,p,x,y){return r[0]=e,r[1]=t,r[2]=n,r[3]=i,r[4]=a,r[5]=s,r[6]=h,r[7]=c,r[8]=l,r[9]=f,r[10]=v,r[11]=o,r[12]=M,r[13]=p,r[14]=x,r[15]=y,r}function ue(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function e1(r,e){if(r===e){var t=e[1],n=e[2],i=e[3],a=e[6],s=e[7],h=e[11];r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=t,r[6]=e[9],r[7]=e[13],r[8]=n,r[9]=a,r[11]=e[14],r[12]=i,r[13]=s,r[14]=h;}else r[0]=e[0],r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=e[1],r[5]=e[5],r[6]=e[9],r[7]=e[13],r[8]=e[2],r[9]=e[6],r[10]=e[10],r[11]=e[14],r[12]=e[3],r[13]=e[7],r[14]=e[11],r[15]=e[15];return r}function t1(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],v=e[9],o=e[10],M=e[11],p=e[12],x=e[13],y=e[14],d=e[15],R=t*h-n*s,m=t*c-i*s,g=t*l-a*s,P=n*c-i*h,A=n*l-a*h,N=i*l-a*c,z=f*x-v*p,C=f*y-o*p,$=f*d-M*p,b=v*y-o*x,F=v*d-M*x,q=o*d-M*y,L=R*q-m*F+g*b+P*$-A*C+N*z;return L?(L=1/L,r[0]=(h*q-c*F+l*b)*L,r[1]=(i*F-n*q-a*b)*L,r[2]=(x*N-y*A+d*P)*L,r[3]=(o*A-v*N-M*P)*L,r[4]=(c*$-s*q-l*C)*L,r[5]=(t*q-i*$+a*C)*L,r[6]=(y*g-p*N-d*m)*L,r[7]=(f*N-o*g+M*m)*L,r[8]=(s*F-h*$+l*z)*L,r[9]=(n*$-t*F-a*z)*L,r[10]=(p*A-x*g+d*R)*L,r[11]=(v*g-f*A-M*R)*L,r[12]=(h*C-s*b-c*z)*L,r[13]=(t*b-n*C+i*z)*L,r[14]=(x*m-p*P-y*R)*L,r[15]=(f*P-v*m+o*R)*L,r):null}function n1(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],v=e[9],o=e[10],M=e[11],p=e[12],x=e[13],y=e[14],d=e[15];return r[0]=h*(o*d-M*y)-v*(c*d-l*y)+x*(c*M-l*o),r[1]=-(n*(o*d-M*y)-v*(i*d-a*y)+x*(i*M-a*o)),r[2]=n*(c*d-l*y)-h*(i*d-a*y)+x*(i*l-a*c),r[3]=-(n*(c*M-l*o)-h*(i*M-a*o)+v*(i*l-a*c)),r[4]=-(s*(o*d-M*y)-f*(c*d-l*y)+p*(c*M-l*o)),r[5]=t*(o*d-M*y)-f*(i*d-a*y)+p*(i*M-a*o),r[6]=-(t*(c*d-l*y)-s*(i*d-a*y)+p*(i*l-a*c)),r[7]=t*(c*M-l*o)-s*(i*M-a*o)+f*(i*l-a*c),r[8]=s*(v*d-M*x)-f*(h*d-l*x)+p*(h*M-l*v),r[9]=-(t*(v*d-M*x)-f*(n*d-a*x)+p*(n*M-a*v)),r[10]=t*(h*d-l*x)-s*(n*d-a*x)+p*(n*l-a*h),r[11]=-(t*(h*M-l*v)-s*(n*M-a*v)+f*(n*l-a*h)),r[12]=-(s*(v*y-o*x)-f*(h*y-c*x)+p*(h*o-c*v)),r[13]=t*(v*y-o*x)-f*(n*y-i*x)+p*(n*o-i*v),r[14]=-(t*(h*y-c*x)-s*(n*y-i*x)+p*(n*c-i*h)),r[15]=t*(h*o-c*v)-s*(n*o-i*v)+f*(n*c-i*h),r}function i1(r){var e=r[0],t=r[1],n=r[2],i=r[3],a=r[4],s=r[5],h=r[6],c=r[7],l=r[8],f=r[9],v=r[10],o=r[11],M=r[12],p=r[13],x=r[14],y=r[15],d=e*s-t*a,R=e*h-n*a,m=e*c-i*a,g=t*h-n*s,P=t*c-i*s,A=n*c-i*h,N=l*p-f*M,z=l*x-v*M,C=l*y-o*M,$=f*x-v*p,b=f*y-o*p,F=v*y-o*x;return d*F-R*b+m*$+g*C-P*z+A*N}function Te(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],v=e[8],o=e[9],M=e[10],p=e[11],x=e[12],y=e[13],d=e[14],R=e[15],m=t[0],g=t[1],P=t[2],A=t[3];return r[0]=m*n+g*h+P*v+A*x,r[1]=m*i+g*c+P*o+A*y,r[2]=m*a+g*l+P*M+A*d,r[3]=m*s+g*f+P*p+A*R,m=t[4],g=t[5],P=t[6],A=t[7],r[4]=m*n+g*h+P*v+A*x,r[5]=m*i+g*c+P*o+A*y,r[6]=m*a+g*l+P*M+A*d,r[7]=m*s+g*f+P*p+A*R,m=t[8],g=t[9],P=t[10],A=t[11],r[8]=m*n+g*h+P*v+A*x,r[9]=m*i+g*c+P*o+A*y,r[10]=m*a+g*l+P*M+A*d,r[11]=m*s+g*f+P*p+A*R,m=t[12],g=t[13],P=t[14],A=t[15],r[12]=m*n+g*h+P*v+A*x,r[13]=m*i+g*c+P*o+A*y,r[14]=m*a+g*l+P*M+A*d,r[15]=m*s+g*f+P*p+A*R,r}function a1(r,e,t){var n=t[0],i=t[1],a=t[2],s,h,c,l,f,v,o,M,p,x,y,d;return e===r?(r[12]=e[0]*n+e[4]*i+e[8]*a+e[12],r[13]=e[1]*n+e[5]*i+e[9]*a+e[13],r[14]=e[2]*n+e[6]*i+e[10]*a+e[14],r[15]=e[3]*n+e[7]*i+e[11]*a+e[15]):(s=e[0],h=e[1],c=e[2],l=e[3],f=e[4],v=e[5],o=e[6],M=e[7],p=e[8],x=e[9],y=e[10],d=e[11],r[0]=s,r[1]=h,r[2]=c,r[3]=l,r[4]=f,r[5]=v,r[6]=o,r[7]=M,r[8]=p,r[9]=x,r[10]=y,r[11]=d,r[12]=s*n+f*i+p*a+e[12],r[13]=h*n+v*i+x*a+e[13],r[14]=c*n+o*i+y*a+e[14],r[15]=l*n+M*i+d*a+e[15]),r}function s1(r,e,t){var n=t[0],i=t[1],a=t[2];return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*i,r[5]=e[5]*i,r[6]=e[6]*i,r[7]=e[7]*i,r[8]=e[8]*a,r[9]=e[9]*a,r[10]=e[10]*a,r[11]=e[11]*a,r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function h1(r,e,t,n){var i=n[0],a=n[1],s=n[2],h=Math.hypot(i,a,s),c,l,f,v,o,M,p,x,y,d,R,m,g,P,A,N,z,C,$,b,F,q,L,U;return h<S.EPSILON?null:(h=1/h,i*=h,a*=h,s*=h,c=Math.sin(t),l=Math.cos(t),f=1-l,v=e[0],o=e[1],M=e[2],p=e[3],x=e[4],y=e[5],d=e[6],R=e[7],m=e[8],g=e[9],P=e[10],A=e[11],N=i*i*f+l,z=a*i*f+s*c,C=s*i*f-a*c,$=i*a*f-s*c,b=a*a*f+l,F=s*a*f+i*c,q=i*s*f+a*c,L=a*s*f-i*c,U=s*s*f+l,r[0]=v*N+x*z+m*C,r[1]=o*N+y*z+g*C,r[2]=M*N+d*z+P*C,r[3]=p*N+R*z+A*C,r[4]=v*$+x*b+m*F,r[5]=o*$+y*b+g*F,r[6]=M*$+d*b+P*F,r[7]=p*$+R*b+A*F,r[8]=v*q+x*L+m*U,r[9]=o*q+y*L+g*U,r[10]=M*q+d*L+P*U,r[11]=p*q+R*L+A*U,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r)}function c1(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[4],s=e[5],h=e[6],c=e[7],l=e[8],f=e[9],v=e[10],o=e[11];return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[4]=a*i+l*n,r[5]=s*i+f*n,r[6]=h*i+v*n,r[7]=c*i+o*n,r[8]=l*i-a*n,r[9]=f*i-s*n,r[10]=v*i-h*n,r[11]=o*i-c*n,r}function l1(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[0],s=e[1],h=e[2],c=e[3],l=e[8],f=e[9],v=e[10],o=e[11];return e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i-l*n,r[1]=s*i-f*n,r[2]=h*i-v*n,r[3]=c*i-o*n,r[8]=a*n+l*i,r[9]=s*n+f*i,r[10]=h*n+v*i,r[11]=c*n+o*i,r}function f1(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[0],s=e[1],h=e[2],c=e[3],l=e[4],f=e[5],v=e[6],o=e[7];return e!==r&&(r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i+l*n,r[1]=s*i+f*n,r[2]=h*i+v*n,r[3]=c*i+o*n,r[4]=l*i-a*n,r[5]=f*i-s*n,r[6]=v*i-h*n,r[7]=o*i-c*n,r}function o1(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r}function v1(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e[1],r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=e[2],r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function M1(r,e,t){var n=t[0],i=t[1],a=t[2],s=Math.hypot(n,i,a),h,c,l;return s<S.EPSILON?null:(s=1/s,n*=s,i*=s,a*=s,h=Math.sin(e),c=Math.cos(e),l=1-c,r[0]=n*n*l+c,r[1]=i*n*l+a*h,r[2]=a*n*l-i*h,r[3]=0,r[4]=n*i*l-a*h,r[5]=i*i*l+c,r[6]=a*i*l+n*h,r[7]=0,r[8]=n*a*l+i*h,r[9]=i*a*l-n*h,r[10]=a*a*l+c,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r)}function p1(r,e){var t=Math.sin(e),n=Math.cos(e);return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=n,r[6]=t,r[7]=0,r[8]=0,r[9]=-t,r[10]=n,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function y1(r,e){var t=Math.sin(e),n=Math.cos(e);return r[0]=n,r[1]=0,r[2]=-t,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=t,r[9]=0,r[10]=n,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function x1(r,e){var t=Math.sin(e),n=Math.cos(e);return r[0]=n,r[1]=t,r[2]=0,r[3]=0,r[4]=-t,r[5]=n,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function Ee(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],h=n+n,c=i+i,l=a+a,f=n*h,v=n*c,o=n*l,M=i*c,p=i*l,x=a*l,y=s*h,d=s*c,R=s*l;return r[0]=1-(M+x),r[1]=v+R,r[2]=o-d,r[3]=0,r[4]=v-R,r[5]=1-(f+x),r[6]=p+y,r[7]=0,r[8]=o+d,r[9]=p-y,r[10]=1-(f+M),r[11]=0,r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r}function m1(r,e){var t=new S.ARRAY_TYPE(3),n=-e[0],i=-e[1],a=-e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],v=n*n+i*i+a*a+s*s;return v>0?(t[0]=(h*s+f*n+c*a-l*i)*2/v,t[1]=(c*s+f*i+l*n-h*a)*2/v,t[2]=(l*s+f*a+h*i-c*n)*2/v):(t[0]=(h*s+f*n+c*a-l*i)*2,t[1]=(c*s+f*i+l*n-h*a)*2,t[2]=(l*s+f*a+h*i-c*n)*2),Ee(r,e,t),r}function d1(r,e){return r[0]=e[12],r[1]=e[13],r[2]=e[14],r}function _e(r,e){var t=e[0],n=e[1],i=e[2],a=e[4],s=e[5],h=e[6],c=e[8],l=e[9],f=e[10];return r[0]=Math.hypot(t,n,i),r[1]=Math.hypot(a,s,h),r[2]=Math.hypot(c,l,f),r}function g1(r,e){var t=new S.ARRAY_TYPE(3);_e(t,e);var n=1/t[0],i=1/t[1],a=1/t[2],s=e[0]*n,h=e[1]*i,c=e[2]*a,l=e[4]*n,f=e[5]*i,v=e[6]*a,o=e[8]*n,M=e[9]*i,p=e[10]*a,x=s+f+p,y=0;return x>0?(y=Math.sqrt(x+1)*2,r[3]=.25*y,r[0]=(v-M)/y,r[1]=(o-c)/y,r[2]=(h-l)/y):s>f&&s>p?(y=Math.sqrt(1+s-f-p)*2,r[3]=(v-M)/y,r[0]=.25*y,r[1]=(h+l)/y,r[2]=(o+c)/y):f>p?(y=Math.sqrt(1+f-s-p)*2,r[3]=(o-c)/y,r[0]=(h+l)/y,r[1]=.25*y,r[2]=(v+M)/y):(y=Math.sqrt(1+p-s-f)*2,r[3]=(h-l)/y,r[0]=(o+c)/y,r[1]=(v+M)/y,r[2]=.25*y),r}function u1(r,e,t,n){var i=e[0],a=e[1],s=e[2],h=e[3],c=i+i,l=a+a,f=s+s,v=i*c,o=i*l,M=i*f,p=a*l,x=a*f,y=s*f,d=h*c,R=h*l,m=h*f,g=n[0],P=n[1],A=n[2];return r[0]=(1-(p+y))*g,r[1]=(o+m)*g,r[2]=(M-R)*g,r[3]=0,r[4]=(o-m)*P,r[5]=(1-(v+y))*P,r[6]=(x+d)*P,r[7]=0,r[8]=(M+R)*A,r[9]=(x-d)*A,r[10]=(1-(v+p))*A,r[11]=0,r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r}function T1(r,e,t,n,i){var a=e[0],s=e[1],h=e[2],c=e[3],l=a+a,f=s+s,v=h+h,o=a*l,M=a*f,p=a*v,x=s*f,y=s*v,d=h*v,R=c*l,m=c*f,g=c*v,P=n[0],A=n[1],N=n[2],z=i[0],C=i[1],$=i[2],b=(1-(x+d))*P,F=(M+g)*P,q=(p-m)*P,L=(M-g)*A,U=(1-(o+d))*A,rr=(y+R)*A,er=(p+m)*N,Wr=(y-R)*N,Br=(1-(o+x))*N;return r[0]=b,r[1]=F,r[2]=q,r[3]=0,r[4]=L,r[5]=U,r[6]=rr,r[7]=0,r[8]=er,r[9]=Wr,r[10]=Br,r[11]=0,r[12]=t[0]+z-(b*z+L*C+er*$),r[13]=t[1]+C-(F*z+U*C+Wr*$),r[14]=t[2]+$-(q*z+rr*C+Br*$),r[15]=1,r}function E1(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t+t,h=n+n,c=i+i,l=t*s,f=n*s,v=n*h,o=i*s,M=i*h,p=i*c,x=a*s,y=a*h,d=a*c;return r[0]=1-v-p,r[1]=f+d,r[2]=o-y,r[3]=0,r[4]=f-d,r[5]=1-l-p,r[6]=M+x,r[7]=0,r[8]=o+y,r[9]=M-x,r[10]=1-l-v,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function _1(r,e,t,n,i,a,s){var h=1/(t-e),c=1/(i-n),l=1/(a-s);return r[0]=a*2*h,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a*2*c,r[6]=0,r[7]=0,r[8]=(t+e)*h,r[9]=(i+n)*c,r[10]=(s+a)*l,r[11]=-1,r[12]=0,r[13]=0,r[14]=s*a*2*l,r[15]=0,r}function Re(r,e,t,n,i){var a=1/Math.tan(e/2),s;return r[0]=a/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i!=null&&i!==1/0?(s=1/(n-i),r[10]=(i+n)*s,r[14]=2*i*n*s):(r[10]=-1,r[14]=-2*n),r}var R1=Re,Oe=E.perspective=R1;function O1(r,e,t,n,i){var a=1/Math.tan(e/2),s;return r[0]=a/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i!=null&&i!==1/0?(s=1/(n-i),r[10]=i*s,r[14]=i*n*s):(r[10]=-1,r[14]=-n),r}function A1(r,e,t,n){var i=Math.tan(e.upDegrees*Math.PI/180),a=Math.tan(e.downDegrees*Math.PI/180),s=Math.tan(e.leftDegrees*Math.PI/180),h=Math.tan(e.rightDegrees*Math.PI/180),c=2/(s+h),l=2/(i+a);return r[0]=c,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=l,r[6]=0,r[7]=0,r[8]=-((s-h)*c*.5),r[9]=(i-a)*l*.5,r[10]=n/(t-n),r[11]=-1,r[12]=0,r[13]=0,r[14]=n*t/(t-n),r[15]=0,r}function Ae(r,e,t,n,i,a,s){var h=1/(e-t),c=1/(n-i),l=1/(a-s);return r[0]=-2*h,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*c,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=2*l,r[11]=0,r[12]=(e+t)*h,r[13]=(i+n)*c,r[14]=(s+a)*l,r[15]=1,r}var P1=Ae,Pe=E.ortho=P1;function L1(r,e,t,n,i,a,s){var h=1/(e-t),c=1/(n-i),l=1/(a-s);return r[0]=-2*h,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*c,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=l,r[11]=0,r[12]=(e+t)*h,r[13]=(i+n)*c,r[14]=a*l,r[15]=1,r}function w1(r,e,t,n){var i,a,s,h,c,l,f,v,o,M,p=e[0],x=e[1],y=e[2],d=n[0],R=n[1],m=n[2],g=t[0],P=t[1],A=t[2];return Math.abs(p-g)<S.EPSILON&&Math.abs(x-P)<S.EPSILON&&Math.abs(y-A)<S.EPSILON?ue(r):(f=p-g,v=x-P,o=y-A,M=1/Math.hypot(f,v,o),f*=M,v*=M,o*=M,i=R*o-m*v,a=m*f-d*o,s=d*v-R*f,M=Math.hypot(i,a,s),M?(M=1/M,i*=M,a*=M,s*=M):(i=0,a=0,s=0),h=v*s-o*a,c=o*i-f*s,l=f*a-v*i,M=Math.hypot(h,c,l),M?(M=1/M,h*=M,c*=M,l*=M):(h=0,c=0,l=0),r[0]=i,r[1]=h,r[2]=f,r[3]=0,r[4]=a,r[5]=c,r[6]=v,r[7]=0,r[8]=s,r[9]=l,r[10]=o,r[11]=0,r[12]=-(i*p+a*x+s*y),r[13]=-(h*p+c*x+l*y),r[14]=-(f*p+v*x+o*y),r[15]=1,r)}function $1(r,e,t,n){var i=e[0],a=e[1],s=e[2],h=n[0],c=n[1],l=n[2],f=i-t[0],v=a-t[1],o=s-t[2],M=f*f+v*v+o*o;M>0&&(M=1/Math.sqrt(M),f*=M,v*=M,o*=M);var p=c*o-l*v,x=l*f-h*o,y=h*v-c*f;return M=p*p+x*x+y*y,M>0&&(M=1/Math.sqrt(M),p*=M,x*=M,y*=M),r[0]=p,r[1]=x,r[2]=y,r[3]=0,r[4]=v*y-o*x,r[5]=o*p-f*y,r[6]=f*x-v*p,r[7]=0,r[8]=f,r[9]=v,r[10]=o,r[11]=0,r[12]=i,r[13]=a,r[14]=s,r[15]=1,r}function S1(r){return "mat4("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+", "+r[4]+", "+r[5]+", "+r[6]+", "+r[7]+", "+r[8]+", "+r[9]+", "+r[10]+", "+r[11]+", "+r[12]+", "+r[13]+", "+r[14]+", "+r[15]+")"}function z1(r){return Math.hypot(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15])}function C1(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r[3]=e[3]+t[3],r[4]=e[4]+t[4],r[5]=e[5]+t[5],r[6]=e[6]+t[6],r[7]=e[7]+t[7],r[8]=e[8]+t[8],r[9]=e[9]+t[9],r[10]=e[10]+t[10],r[11]=e[11]+t[11],r[12]=e[12]+t[12],r[13]=e[13]+t[13],r[14]=e[14]+t[14],r[15]=e[15]+t[15],r}function Le(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r[3]=e[3]-t[3],r[4]=e[4]-t[4],r[5]=e[5]-t[5],r[6]=e[6]-t[6],r[7]=e[7]-t[7],r[8]=e[8]-t[8],r[9]=e[9]-t[9],r[10]=e[10]-t[10],r[11]=e[11]-t[11],r[12]=e[12]-t[12],r[13]=e[13]-t[13],r[14]=e[14]-t[14],r[15]=e[15]-t[15],r}function F1(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r[3]=e[3]*t,r[4]=e[4]*t,r[5]=e[5]*t,r[6]=e[6]*t,r[7]=e[7]*t,r[8]=e[8]*t,r[9]=e[9]*t,r[10]=e[10]*t,r[11]=e[11]*t,r[12]=e[12]*t,r[13]=e[13]*t,r[14]=e[14]*t,r[15]=e[15]*t,r}function N1(r,e,t,n){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r[3]=e[3]+t[3]*n,r[4]=e[4]+t[4]*n,r[5]=e[5]+t[5]*n,r[6]=e[6]+t[6]*n,r[7]=e[7]+t[7]*n,r[8]=e[8]+t[8]*n,r[9]=e[9]+t[9]*n,r[10]=e[10]+t[10]*n,r[11]=e[11]+t[11]*n,r[12]=e[12]+t[12]*n,r[13]=e[13]+t[13]*n,r[14]=e[14]+t[14]*n,r[15]=e[15]+t[15]*n,r}function b1(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&r[5]===e[5]&&r[6]===e[6]&&r[7]===e[7]&&r[8]===e[8]&&r[9]===e[9]&&r[10]===e[10]&&r[11]===e[11]&&r[12]===e[12]&&r[13]===e[13]&&r[14]===e[14]&&r[15]===e[15]}function q1(r,e){var t=r[0],n=r[1],i=r[2],a=r[3],s=r[4],h=r[5],c=r[6],l=r[7],f=r[8],v=r[9],o=r[10],M=r[11],p=r[12],x=r[13],y=r[14],d=r[15],R=e[0],m=e[1],g=e[2],P=e[3],A=e[4],N=e[5],z=e[6],C=e[7],$=e[8],b=e[9],F=e[10],q=e[11],L=e[12],U=e[13],rr=e[14],er=e[15];return Math.abs(t-R)<=S.EPSILON*Math.max(1,Math.abs(t),Math.abs(R))&&Math.abs(n-m)<=S.EPSILON*Math.max(1,Math.abs(n),Math.abs(m))&&Math.abs(i-g)<=S.EPSILON*Math.max(1,Math.abs(i),Math.abs(g))&&Math.abs(a-P)<=S.EPSILON*Math.max(1,Math.abs(a),Math.abs(P))&&Math.abs(s-A)<=S.EPSILON*Math.max(1,Math.abs(s),Math.abs(A))&&Math.abs(h-N)<=S.EPSILON*Math.max(1,Math.abs(h),Math.abs(N))&&Math.abs(c-z)<=S.EPSILON*Math.max(1,Math.abs(c),Math.abs(z))&&Math.abs(l-C)<=S.EPSILON*Math.max(1,Math.abs(l),Math.abs(C))&&Math.abs(f-$)<=S.EPSILON*Math.max(1,Math.abs(f),Math.abs($))&&Math.abs(v-b)<=S.EPSILON*Math.max(1,Math.abs(v),Math.abs(b))&&Math.abs(o-F)<=S.EPSILON*Math.max(1,Math.abs(o),Math.abs(F))&&Math.abs(M-q)<=S.EPSILON*Math.max(1,Math.abs(M),Math.abs(q))&&Math.abs(p-L)<=S.EPSILON*Math.max(1,Math.abs(p),Math.abs(L))&&Math.abs(x-U)<=S.EPSILON*Math.max(1,Math.abs(x),Math.abs(U))&&Math.abs(y-rr)<=S.EPSILON*Math.max(1,Math.abs(y),Math.abs(rr))&&Math.abs(d-er)<=S.EPSILON*Math.max(1,Math.abs(d),Math.abs(er))}var Y1=Te;E.mul=Y1;var k1=Le;E.sub=k1;var O={};function xr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?xr=function(t){return typeof t}:xr=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},xr(r)}Object.defineProperty(O,"__esModule",{value:!0}),O.create=$e,O.clone=Z1,O.fromValues=D1,O.copy=V1,O.set=U1,O.add=X1,O.subtract=Se,O.multiply=ze,O.divide=Ce,O.ceil=I1,O.floor=K1,O.min=G1,O.max=H1,O.round=Q1,O.scale=J1,O.scaleAndAdd=j1,O.distance=Fe,O.squaredDistance=Ne,O.length=be,O.squaredLength=qe,O.negate=ra,O.inverse=ea,O.normalize=ta,O.dot=na,O.cross=ia,O.lerp=sa,O.random=ha;var W1=O.transformMat4=ca;O.transformQuat=la,O.zero=fa,O.str=oa,O.exactEquals=va,O.equals=Ma,O.forEach=O.sqrLen=O.len=O.sqrDist=O.dist=O.div=O.mul=O.sub=void 0;var D=B1(W);function we(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,t=new WeakMap;return (we=function(i){return i?t:e})(r)}function B1(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||xr(r)!=="object"&&typeof r!="function")return {default:r};var t=we(e);if(t&&t.has(r))return t.get(r);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=r[a];}return n.default=r,t&&t.set(r,n),n}function $e(){var r=new D.ARRAY_TYPE(4);return D.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function Z1(r){var e=new D.ARRAY_TYPE(4);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e}function D1(r,e,t,n){var i=new D.ARRAY_TYPE(4);return i[0]=r,i[1]=e,i[2]=t,i[3]=n,i}function V1(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r}function U1(r,e,t,n,i){return r[0]=e,r[1]=t,r[2]=n,r[3]=i,r}function X1(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r[3]=e[3]+t[3],r}function Se(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r[3]=e[3]-t[3],r}function ze(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r[3]=e[3]*t[3],r}function Ce(r,e,t){return r[0]=e[0]/t[0],r[1]=e[1]/t[1],r[2]=e[2]/t[2],r[3]=e[3]/t[3],r}function I1(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r[2]=Math.ceil(e[2]),r[3]=Math.ceil(e[3]),r}function K1(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r[2]=Math.floor(e[2]),r[3]=Math.floor(e[3]),r}function G1(r,e,t){return r[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r[2]=Math.min(e[2],t[2]),r[3]=Math.min(e[3],t[3]),r}function H1(r,e,t){return r[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r[2]=Math.max(e[2],t[2]),r[3]=Math.max(e[3],t[3]),r}function Q1(r,e){return r[0]=Math.round(e[0]),r[1]=Math.round(e[1]),r[2]=Math.round(e[2]),r[3]=Math.round(e[3]),r}function J1(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r[3]=e[3]*t,r}function j1(r,e,t,n){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r[3]=e[3]+t[3]*n,r}function Fe(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2],a=e[3]-r[3];return Math.hypot(t,n,i,a)}function Ne(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2],a=e[3]-r[3];return t*t+n*n+i*i+a*a}function be(r){var e=r[0],t=r[1],n=r[2],i=r[3];return Math.hypot(e,t,n,i)}function qe(r){var e=r[0],t=r[1],n=r[2],i=r[3];return e*e+t*t+n*n+i*i}function ra(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=-e[3],r}function ea(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r[3]=1/e[3],r}function ta(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t*t+n*n+i*i+a*a;return s>0&&(s=1/Math.sqrt(s)),r[0]=t*s,r[1]=n*s,r[2]=i*s,r[3]=a*s,r}function na(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]+r[3]*e[3]}function ia(r,e,t,n){var i=t[0]*n[1]-t[1]*n[0],a=t[0]*n[2]-t[2]*n[0],s=t[0]*n[3]-t[3]*n[0],h=t[1]*n[2]-t[2]*n[1],c=t[1]*n[3]-t[3]*n[1],l=t[2]*n[3]-t[3]*n[2],f=e[0],v=e[1],o=e[2],M=e[3];return r[0]=v*l-o*c+M*h,r[1]=-(f*l)+o*s-M*a,r[2]=f*c-v*s+M*i,r[3]=-(f*h)+v*a-o*i,r}function sa(r,e,t,n){var i=e[0],a=e[1],s=e[2],h=e[3];return r[0]=i+n*(t[0]-i),r[1]=a+n*(t[1]-a),r[2]=s+n*(t[2]-s),r[3]=h+n*(t[3]-h),r}function ha(r,e){e=e||1;var t,n,i,a,s,h;do t=D.RANDOM()*2-1,n=D.RANDOM()*2-1,s=t*t+n*n;while(s>=1);do i=D.RANDOM()*2-1,a=D.RANDOM()*2-1,h=i*i+a*a;while(h>=1);var c=Math.sqrt((1-s)/h);return r[0]=e*t,r[1]=e*n,r[2]=e*i*c,r[3]=e*a*c,r}function ca(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3];return r[0]=t[0]*n+t[4]*i+t[8]*a+t[12]*s,r[1]=t[1]*n+t[5]*i+t[9]*a+t[13]*s,r[2]=t[2]*n+t[6]*i+t[10]*a+t[14]*s,r[3]=t[3]*n+t[7]*i+t[11]*a+t[15]*s,r}function la(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[0],h=t[1],c=t[2],l=t[3],f=l*n+h*a-c*i,v=l*i+c*n-s*a,o=l*a+s*i-h*n,M=-s*n-h*i-c*a;return r[0]=f*l+M*-s+v*-c-o*-h,r[1]=v*l+M*-h+o*-s-f*-c,r[2]=o*l+M*-c+f*-h-v*-s,r[3]=e[3],r}function fa(r){return r[0]=0,r[1]=0,r[2]=0,r[3]=0,r}function oa(r){return "vec4("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+")"}function va(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]}function Ma(r,e){var t=r[0],n=r[1],i=r[2],a=r[3],s=e[0],h=e[1],c=e[2],l=e[3];return Math.abs(t-s)<=D.EPSILON*Math.max(1,Math.abs(t),Math.abs(s))&&Math.abs(n-h)<=D.EPSILON*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(i-c)<=D.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))&&Math.abs(a-l)<=D.EPSILON*Math.max(1,Math.abs(a),Math.abs(l))}var pa=Se;O.sub=pa;var ya=ze;O.mul=ya;var xa=Ce;O.div=xa;var ma=Fe;O.dist=ma;var da=Ne;O.sqrDist=da;var ga=be;O.len=ga;var ua=qe;O.sqrLen=ua;var Ta=function(){var r=$e();return function(e,t,n,i,a,s){var h,c;for(t||(t=4),n||(n=0),i?c=Math.min(i*t+n,e.length):c=e.length,h=n;h<c;h+=t)r[0]=e[h],r[1]=e[h+1],r[2]=e[h+2],r[3]=e[h+3],a(r,r,s),e[h]=r[0],e[h+1]=r[1],e[h+2]=r[2],e[h+3]=r[3];return e}}();O.forEach=Ta;var zr;(function(r){r[r.COL0ROW0=0]="COL0ROW0",r[r.COL0ROW1=1]="COL0ROW1",r[r.COL0ROW2=2]="COL0ROW2",r[r.COL0ROW3=3]="COL0ROW3",r[r.COL1ROW0=4]="COL1ROW0",r[r.COL1ROW1=5]="COL1ROW1",r[r.COL1ROW2=6]="COL1ROW2",r[r.COL1ROW3=7]="COL1ROW3",r[r.COL2ROW0=8]="COL2ROW0",r[r.COL2ROW1=9]="COL2ROW1",r[r.COL2ROW2=10]="COL2ROW2",r[r.COL2ROW3=11]="COL2ROW3",r[r.COL3ROW0=12]="COL3ROW0",r[r.COL3ROW1=13]="COL3ROW1",r[r.COL3ROW2=14]="COL3ROW2",r[r.COL3ROW3=15]="COL3ROW3";})(zr||(zr={}));const Ea=45*Math.PI/180,_a=1,Cr=.1,Fr=500,Ra=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);class ar extends ai{static get IDENTITY(){return Aa()}static get ZERO(){return Oa()}get ELEMENTS(){return 16}get RANK(){return 4}get INDICES(){return zr}constructor(e){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(e)?this.copy(e):this.identity();}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this[4]=e[4],this[5]=e[5],this[6]=e[6],this[7]=e[7],this[8]=e[8],this[9]=e[9],this[10]=e[10],this[11]=e[11],this[12]=e[12],this[13]=e[13],this[14]=e[14],this[15]=e[15],this.check()}set(e,t,n,i,a,s,h,c,l,f,v,o,M,p,x,y){return this[0]=e,this[1]=t,this[2]=n,this[3]=i,this[4]=a,this[5]=s,this[6]=h,this[7]=c,this[8]=l,this[9]=f,this[10]=v,this[11]=o,this[12]=M,this[13]=p,this[14]=x,this[15]=y,this.check()}setRowMajor(e,t,n,i,a,s,h,c,l,f,v,o,M,p,x,y){return this[0]=e,this[1]=a,this[2]=l,this[3]=M,this[4]=t,this[5]=s,this[6]=f,this[7]=p,this[8]=n,this[9]=h,this[10]=v,this[11]=x,this[12]=i,this[13]=c,this[14]=o,this[15]=y,this.check()}toRowMajor(e){return e[0]=this[0],e[1]=this[4],e[2]=this[8],e[3]=this[12],e[4]=this[1],e[5]=this[5],e[6]=this[9],e[7]=this[13],e[8]=this[2],e[9]=this[6],e[10]=this[10],e[11]=this[14],e[12]=this[3],e[13]=this[7],e[14]=this[11],e[15]=this[15],e}identity(){return this.copy(Ra)}fromObject(e){return this.check()}fromQuaternion(e){return Xi(this,e),this.check()}frustum(e){const{left:t,right:n,bottom:i,top:a,near:s=Cr,far:h=Fr}=e;return h===1/0?Pa(this,t,n,i,a,s):Ii(this,t,n,i,a,s,h),this.check()}lookAt(e){const{eye:t,center:n=[0,0,0],up:i=[0,1,0]}=e;return Ki(this,t,n,i),this.check()}ortho(e){const{left:t,right:n,bottom:i,top:a,near:s=Cr,far:h=Fr}=e;return Pe(this,t,n,i,a,s,h),this.check()}orthographic(e){const{fovy:t=Ea,aspect:n=_a,focalDistance:i=1,near:a=Cr,far:s=Fr}=e;Ye(t);const h=t/2,c=i*Math.tan(h),l=c*n;return this.ortho({left:-l,right:l,bottom:-c,top:c,near:a,far:s})}perspective(e){const{fovy:t=45*Math.PI/180,aspect:n=1,near:i=.1,far:a=500}=e;return Ye(t),Oe(this,t,n,i,a),this.check()}determinant(){return ki(this)}getScale(e=[-0,-0,-0]){return e[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),e[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),e[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),e}getTranslation(e=[-0,-0,-0]){return e[0]=this[12],e[1]=this[13],e[2]=this[14],e}getRotation(e,t){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],t=t||[-0,-0,-0];const n=this.getScale(t),i=1/n[0],a=1/n[1],s=1/n[2];return e[0]=this[0]*i,e[1]=this[1]*a,e[2]=this[2]*s,e[3]=0,e[4]=this[4]*i,e[5]=this[5]*a,e[6]=this[6]*s,e[7]=0,e[8]=this[8]*i,e[9]=this[9]*a,e[10]=this[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}getRotationMatrix3(e,t){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0],t=t||[-0,-0,-0];const n=this.getScale(t),i=1/n[0],a=1/n[1],s=1/n[2];return e[0]=this[0]*i,e[1]=this[1]*a,e[2]=this[2]*s,e[3]=this[4]*i,e[4]=this[5]*a,e[5]=this[6]*s,e[6]=this[8]*i,e[7]=this[9]*a,e[8]=this[10]*s,e}transpose(){return qi(this,this),this.check()}invert(){return Yi(this,this),this.check()}multiplyLeft(e){return de(this,e,this),this.check()}multiplyRight(e){return de(this,this,e),this.check()}rotateX(e){return Di(this,this,e),this.check()}rotateY(e){return Vi(this,this,e),this.check()}rotateZ(e){return Ui(this,this,e),this.check()}rotateXYZ(e){return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2])}rotateAxis(e,t){return Zi(this,this,e,t),this.check()}scale(e){return Bi(this,this,Array.isArray(e)?e:[e,e,e]),this.check()}translate(e){return Wi(this,this,e),this.check()}transform(e,t){return e.length===4?(t=W1(t||[-0,-0,-0,-0],e,this),Sr(t,4),t):this.transformAsPoint(e,t)}transformAsPoint(e,t){const{length:n}=e;let i;switch(n){case 2:i=$t(t||[-0,-0],e,this);break;case 3:i=dn(t||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return Sr(i,e.length),i}transformAsVector(e,t){let n;switch(e.length){case 2:n=xn(t||[-0,-0],e,this);break;case 3:n=mn(t||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return Sr(n,e.length),n}transformPoint(e,t){return this.transformAsPoint(e,t)}transformVector(e,t){return this.transformAsPoint(e,t)}transformDirection(e,t){return this.transformAsVector(e,t)}makeRotationX(e){return this.identity().rotateX(e)}makeTranslation(e,t,n){return this.identity().translate([e,t,n])}}let mr,dr;function Oa(){return mr||(mr=new ar([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Object.freeze(mr)),mr}function Aa(){return dr||(dr=new ar,Object.freeze(dr)),dr}function Ye(r){if(r>Math.PI*2)throw Error("expected radians")}function Pa(r,e,t,n,i,a){const s=2*a/(t-e),h=2*a/(i-n),c=(t+e)/(t-e),l=(i+n)/(i-n),f=-1,v=-1,o=-2*a;return r[0]=s,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=h,r[6]=0,r[7]=0,r[8]=c,r[9]=l,r[10]=f,r[11]=v,r[12]=0,r[13]=0,r[14]=o,r[15]=0,r}var u={};function gr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?gr=function(t){return typeof t}:gr=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},gr(r)}Object.defineProperty(u,"__esModule",{value:!0}),u.create=Nr,u.identity=wa,u.setAxisAngle=We,u.getAxisAngle=$a,u.getAngle=Sa,u.multiply=Be,u.rotateX=za,u.rotateY=Ca,u.rotateZ=Fa,u.calculateW=Na,u.exp=Ze,u.ln=De,u.pow=ba,u.slerp=Tr,u.random=qa,u.invert=Ya,u.conjugate=ka,u.fromMat3=Ve,u.fromEuler=Wa,u.str=Ba,u.setAxes=u.sqlerp=u.rotationTo=u.equals=u.exactEquals=u.normalize=u.sqrLen=u.squaredLength=u.len=u.length=u.lerp=u.dot=u.scale=u.mul=u.add=u.set=u.copy=u.fromValues=u.clone=void 0;var J=ur(W),La=ur(w),K=ur(T),Z=ur(O);function ke(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,t=new WeakMap;return (ke=function(i){return i?t:e})(r)}function ur(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||gr(r)!=="object"&&typeof r!="function")return {default:r};var t=ke(e);if(t&&t.has(r))return t.get(r);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=r[a];}return n.default=r,t&&t.set(r,n),n}function Nr(){var r=new J.ARRAY_TYPE(4);return J.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r[3]=1,r}function wa(r){return r[0]=0,r[1]=0,r[2]=0,r[3]=1,r}function We(r,e,t){t=t*.5;var n=Math.sin(t);return r[0]=n*e[0],r[1]=n*e[1],r[2]=n*e[2],r[3]=Math.cos(t),r}function $a(r,e){var t=Math.acos(e[3])*2,n=Math.sin(t/2);return n>J.EPSILON?(r[0]=e[0]/n,r[1]=e[1]/n,r[2]=e[2]/n):(r[0]=1,r[1]=0,r[2]=0),t}function Sa(r,e){var t=Xe(r,e);return Math.acos(2*t*t-1)}function Be(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],h=t[0],c=t[1],l=t[2],f=t[3];return r[0]=n*f+s*h+i*l-a*c,r[1]=i*f+s*c+a*h-n*l,r[2]=a*f+s*l+n*c-i*h,r[3]=s*f-n*h-i*c-a*l,r}function za(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],h=Math.sin(t),c=Math.cos(t);return r[0]=n*c+s*h,r[1]=i*c+a*h,r[2]=a*c-i*h,r[3]=s*c-n*h,r}function Ca(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],h=Math.sin(t),c=Math.cos(t);return r[0]=n*c-a*h,r[1]=i*c+s*h,r[2]=a*c+n*h,r[3]=s*c-i*h,r}function Fa(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],h=Math.sin(t),c=Math.cos(t);return r[0]=n*c+i*h,r[1]=i*c-n*h,r[2]=a*c+s*h,r[3]=s*c-a*h,r}function Na(r,e){var t=e[0],n=e[1],i=e[2];return r[0]=t,r[1]=n,r[2]=i,r[3]=Math.sqrt(Math.abs(1-t*t-n*n-i*i)),r}function Ze(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=Math.sqrt(t*t+n*n+i*i),h=Math.exp(a),c=s>0?h*Math.sin(s)/s:0;return r[0]=t*c,r[1]=n*c,r[2]=i*c,r[3]=h*Math.cos(s),r}function De(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=Math.sqrt(t*t+n*n+i*i),h=s>0?Math.atan2(s,a)/s:0;return r[0]=t*h,r[1]=n*h,r[2]=i*h,r[3]=.5*Math.log(t*t+n*n+i*i+a*a),r}function ba(r,e,t){return De(r,e),Ue(r,r,t),Ze(r,r),r}function Tr(r,e,t,n){var i=e[0],a=e[1],s=e[2],h=e[3],c=t[0],l=t[1],f=t[2],v=t[3],o,M,p,x,y;return M=i*c+a*l+s*f+h*v,M<0&&(M=-M,c=-c,l=-l,f=-f,v=-v),1-M>J.EPSILON?(o=Math.acos(M),p=Math.sin(o),x=Math.sin((1-n)*o)/p,y=Math.sin(n*o)/p):(x=1-n,y=n),r[0]=x*i+y*c,r[1]=x*a+y*l,r[2]=x*s+y*f,r[3]=x*h+y*v,r}function qa(r){var e=J.RANDOM(),t=J.RANDOM(),n=J.RANDOM(),i=Math.sqrt(1-e),a=Math.sqrt(e);return r[0]=i*Math.sin(2*Math.PI*t),r[1]=i*Math.cos(2*Math.PI*t),r[2]=a*Math.sin(2*Math.PI*n),r[3]=a*Math.cos(2*Math.PI*n),r}function Ya(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t*t+n*n+i*i+a*a,h=s?1/s:0;return r[0]=-t*h,r[1]=-n*h,r[2]=-i*h,r[3]=a*h,r}function ka(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=e[3],r}function Ve(r,e){var t=e[0]+e[4]+e[8],n;if(t>0)n=Math.sqrt(t+1),r[3]=.5*n,n=.5/n,r[0]=(e[5]-e[7])*n,r[1]=(e[6]-e[2])*n,r[2]=(e[1]-e[3])*n;else {var i=0;e[4]>e[0]&&(i=1),e[8]>e[i*3+i]&&(i=2);var a=(i+1)%3,s=(i+2)%3;n=Math.sqrt(e[i*3+i]-e[a*3+a]-e[s*3+s]+1),r[i]=.5*n,n=.5/n,r[3]=(e[a*3+s]-e[s*3+a])*n,r[a]=(e[a*3+i]+e[i*3+a])*n,r[s]=(e[s*3+i]+e[i*3+s])*n;}return r}function Wa(r,e,t,n){var i=.5*Math.PI/180;e*=i,t*=i,n*=i;var a=Math.sin(e),s=Math.cos(e),h=Math.sin(t),c=Math.cos(t),l=Math.sin(n),f=Math.cos(n);return r[0]=a*c*f-s*h*l,r[1]=s*h*f+a*c*l,r[2]=s*c*l-a*h*f,r[3]=s*c*f+a*h*l,r}function Ba(r){return "quat("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+")"}var Za=Z.clone;u.clone=Za;var Da=Z.fromValues;u.fromValues=Da;var Va=Z.copy;u.copy=Va;var Ua=Z.set;u.set=Ua;var Xa=Z.add;u.add=Xa;var Ia=Be;u.mul=Ia;var Ue=Z.scale;u.scale=Ue;var Xe=Z.dot;u.dot=Xe;var Ka=Z.lerp;u.lerp=Ka;var Ie=Z.length;u.length=Ie;var Ga=Ie;u.len=Ga;var Ke=Z.squaredLength;u.squaredLength=Ke;var Ha=Ke;u.sqrLen=Ha;var br=Z.normalize;u.normalize=br;var Qa=Z.exactEquals;u.exactEquals=Qa;var Ja=Z.equals;u.equals=Ja;var ja=function(){var r=K.create(),e=K.fromValues(1,0,0),t=K.fromValues(0,1,0);return function(n,i,a){var s=K.dot(i,a);return s<-.999999?(K.cross(r,e,i),K.len(r)<1e-6&&K.cross(r,t,i),K.normalize(r,r),We(n,r,Math.PI),n):s>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(K.cross(r,i,a),n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=1+s,br(n,n))}}();u.rotationTo=ja;var r0=function(){var r=Nr(),e=Nr();return function(t,n,i,a,s,h){return Tr(r,n,s,h),Tr(e,i,a,h),Tr(t,r,e,2*h*(1-h)),t}}();u.sqlerp=r0;var e0=function(){var r=La.create();return function(e,t,n,i){return r[0]=n[0],r[3]=n[1],r[6]=n[2],r[1]=i[0],r[4]=i[1],r[7]=i[2],r[2]=-t[0],r[5]=-t[1],r[8]=-t[2],br(e,Ve(e,r))}}();u.setAxes=e0;var Ge;(function(r){r[r.ZYX=0]="ZYX",r[r.YXZ=1]="YXZ",r[r.XZY=2]="XZY",r[r.ZXY=3]="ZXY",r[r.YZX=4]="YZX",r[r.XYZ=5]="XYZ";})(Ge||(Ge={}));const k=3.141592653589793,Er=6378245,_r=.006693421622965943,Rr=k*3e3/180;function sr(r,e,t){const n=k/180*e,i=Math.pow(2,t),a=Math.floor((r+180)/360*i),s=Math.floor((1-Math.asinh(Math.tan(n))/k)/2*i);return [a,s]}function He(r,e,t){const n=Math.pow(2,t),i=r/n*360-180,a=Math.atan(Math.sinh(k*(1-2*e/n)))*180/k;return [i,a]}function t0(r,e){let t=je(r-105,e-35),n=rt(r-105,e-35);const i=e/180*k;let a=Math.sin(i);a=1-_r*a*a;const s=Math.sqrt(a);t=t*180/(Er*(1-_r)/(a*s)*k),n=n*180/(Er/s*Math.cos(i)*k);const h=e+t;return {lng:r+n,lat:h}}function Qe(r,e){const t=i0(r,e),n=r*2-t.lng,i=e*2-t.lat;return {lng:n,lat:i}}function Je(r,e){const t=Math.sqrt(r*r+e*e)+2e-5*Math.sin(e*Rr),n=Math.atan2(e,r)+3e-6*Math.cos(r*Rr),i=t*Math.cos(n)+.0065,a=t*Math.sin(n)+.006;return {lng:i,lat:a}}function n0(r,e){const t=r-.0065,n=e-.006,i=Math.sqrt(t*t+n*n)-2e-5*Math.sin(n*Rr),a=Math.atan2(n,t)-3e-6*Math.cos(t*Rr),s=i*Math.cos(a),h=i*Math.sin(a);return {lng:s,lat:h}}function i0(r,e){let t=je(r-105,e-35),n=rt(r-105,e-35);const i=e/180*k;let a=Math.sin(i);a=1-_r*a*a;const s=Math.sqrt(a);t=t*180/(Er*(1-_r)/(a*s)*k),n=n*180/(Er/s*Math.cos(i)*k);const h=e+t;return {lng:r+n,lat:h}}function je(r,e){let t=-100+2*r+3*e+.2*e*e+.1*r*e+.2*Math.sqrt(Math.abs(r));return t+=(20*Math.sin(6*r*k)+20*Math.sin(2*r*k))*2/3,t+=(20*Math.sin(e*k)+40*Math.sin(e/3*k))*2/3,t+=(160*Math.sin(e/12*k)+320*Math.sin(e*k/30))*2/3,t}function rt(r,e){let t=300+r+2*e+.1*r*r+.1*r*e+.1*Math.sqrt(Math.abs(r));return t+=(20*Math.sin(6*r*k)+20*Math.sin(2*r*k))*2/3,t+=(20*Math.sin(r*k)+40*Math.sin(r/3*k))*2/3,t+=(150*Math.sin(r/12*k)+300*Math.sin(r/30*k))*2/3,t}function et(r,e){for(var t in e)e.hasOwnProperty(t)&&(r[t]=e[t]);return r}function a0(r,e){for(var t in e)r[t]=e[t];}function tt(r){return typeof r=="string"}var nt=void 0,Or=null;function V(r,e){isNaN(r)&&(r=Ib(r),r=isNaN(r)?0:r),tt(r)&&(r=parseFloat(r)),isNaN(e)&&(e=Ib(e),e=isNaN(e)?0:e),tt(e)&&(e=parseFloat(e)),this.lng=r,this.lat=e;}V.TL=function(r){return r&&180>=r.lng&&-180<=r.lng&&74>=r.lat&&-74<=r.lat},V.prototype.lb=function(r){return r&&this.lat==r.lat&&this.lng==r.lng};function Ar(r,e){this.x=r||0,this.y=e||0,this.x=this.x,this.y=this.y;}Ar.prototype.lb=function(r){return r&&r.x==this.x&&r.y==this.y};function qr(){}qr.prototype.nh=function(){aa("lngLatToPoint\u65B9\u6CD5\u672A\u5B9E\u73B0");},qr.prototype.wi=function(){aa("pointToLngLat\u65B9\u6CD5\u672A\u5B9E\u73B0");};function G(){}G.prototype=new qr,et(G,{$O:637099681e-2,lG:[1289059486e-2,836237787e-2,5591021,348198983e-2,167804312e-2,0],Au:[75,60,45,30,15,0],fP:[[1410526172116255e-23,898305509648872e-20,-1.9939833816331,200.9824383106796,-187.2403703815547,91.6087516669843,-23.38765649603339,2.57121317296198,-.03801003308653,173379812e-1],[-7435856389565537e-24,8983055097726239e-21,-.78625201886289,96.32687599759846,-1.85204757529826,-59.36935905485877,47.40033549296737,-16.50741931063887,2.28786674699375,1026014486e-2],[-3030883460898826e-23,898305509983578e-20,.30071316287616,59.74293618442277,7.357984074871,-25.38371002664745,13.45380521110908,-3.29883767235584,.32710905363475,685681737e-2],[-1981981304930552e-23,8983055099779535e-21,.03278182852591,40.31678527705744,.65659298677277,-4.44255534477492,.85341911805263,.12923347998204,-.04625736007561,448277706e-2],[309191371068437e-23,8983055096812155e-21,6995724062e-14,23.10934304144901,-.00023663490511,-.6321817810242,-.00663494467273,.03430082397953,-.00466043876332,25551644e-1],[2890871144776878e-24,8983055095805407e-21,-3068298e-14,7.47137025468032,-353937994e-14,-.02145144861037,-1234426596e-14,.00010322952773,-323890364e-14,826088.5]],iG:[[-.0015702102444,111320.7020616939,0x60e374c3105a3,-0x24bb4115e2e164,0x5cc55543bb0ae8,-0x7ce070193f3784,0x5e7ca61ddf8150,-0x261a578d8b24d0,0x665d60f3742ca,82.5],[.0008277824516172526,111320.7020463578,6477955746671607e-7,-4082003173641316e-6,1077490566351142e-5,-1517187553151559e-5,1205306533862167e-5,-5124939663577472e-6,9133119359512032e-7,67.5],[.00337398766765,111320.7020202162,4481351045890365e-9,-2339375119931662e-8,7968221547186455e-8,-1159649932797253e-7,9723671115602145e-8,-4366194633752821e-8,8477230501135234e-9,52.5],[.00220636496208,111320.7020209128,51751.86112841131,3796837749470245e-9,992013.7397791013,-122195221711287e-8,1340652697009075e-9,-620943.6990984312,144416.9293806241,37.5],[-.0003441963504368392,111320.7020576856,278.2353980772752,2485758690035394e-9,6070.750963243378,54821.18345352118,9540.606633304236,-2710.55326746645,1405.483844121726,22.5],[-.0003218135878613132,111320.7020701615,.00369383431289,823725.6402795718,.46104986909093,2351.343141331292,1.58060784298199,8.77738589078284,.37238884252424,7.45]],Z1:function(i,e){if(!i||!e)return 0;var t,n,i=this.Fb(i);return i?(t=this.Tk(i.lng),n=this.Tk(i.lat),e=this.Fb(e),e?this.Pe(t,this.Tk(e.lng),n,this.Tk(e.lat)):0):0},Vo:function(r,e){return !r||!e?0:(r.lng=this.JD(r.lng,-180,180),r.lat=this.ND(r.lat,-74,74),e.lng=this.JD(e.lng,-180,180),e.lat=this.ND(e.lat,-74,74),this.Pe(this.Tk(r.lng),this.Tk(e.lng),this.Tk(r.lat),this.Tk(e.lat)))},Fb:function(r){if(r===Or||r===nt)return new V(0,0);var e,t;e=new V(Math.abs(r.lng),Math.abs(r.lat));for(var n=0;n<this.lG.length;n++)if(e.lat>=this.lG[n]){t=this.fP[n];break}return r=this.gK(r,t),r=new V(r.lng.toFixed(6),r.lat.toFixed(6))},Eb:function(r){if(r===Or||r===nt||180<r.lng||-180>r.lng||90<r.lat||-90>r.lat)return new V(0,0);var e,t;r.lng=this.JD(r.lng,-180,180),r.lat=this.ND(r.lat,-74,74),e=new V(r.lng,r.lat);for(var n=0;n<this.Au.length;n++)if(e.lat>=this.Au[n]){t=this.iG[n];break}if(!t){for(n=0;n<this.Au.length;n++)if(e.lat<=-this.Au[n]){t=this.iG[n];break}}return r=this.gK(r,t),r=new V(r.lng.toFixed(2),r.lat.toFixed(2))},gK:function(r,e){if(r&&e){var t=e[0]+e[1]*Math.abs(r.lng),n=Math.abs(r.lat)/e[9],n=e[2]+e[3]*n+e[4]*n*n+e[5]*n*n*n+e[6]*n*n*n*n+e[7]*n*n*n*n*n+e[8]*n*n*n*n*n*n,t=t*(0>r.lng?-1:1),n=n*(0>r.lat?-1:1);return new V(t,n)}},Pe:function(r,e,t,n){return this.$O*Math.acos(Math.sin(t)*Math.sin(n)+Math.cos(t)*Math.cos(n)*Math.cos(e-r))},Tk:function(r){return Math.PI*r/180},Z3:function(r){return 180*r/Math.PI},ND:function(r,e,t){return e!=Or&&(r=Math.max(r,e)),t!=Or&&(r=Math.min(r,t)),r},JD:function(r,e,t){for(;r>t;)r-=t-e;for(;r<e;)r+=t-e;return r}}),et(G.prototype,{Jm:function(r){return G.Eb(r)},nh:function(r){return r=G.Eb(r),new Ar(r.lng,r.lat)},qh:function(r){return G.Fb(r)},wi:function(r){return r=new V(r.x,r.y),G.Fb(r)},fc:function(r,e,t,n,i){if(r)return r=this.Jm(r,i),e=this.Lc(e),new Ar(Math.round((r.lng-t.lng)/e+n.width/2),Math.round((t.lat-r.lat)/e+n.height/2))},zb:function(r,e,t,n,i){if(r)return e=this.Lc(e),this.qh(new V(t.lng+e*(r.x-n.width/2),t.lat-e*(r.y-n.height/2)),i)},Lc:function(r){return Math.pow(2,18-r)}});var Yr=G.prototype;a0(Yr,{lngLatToPoint:Yr.nh,pointToLngLat:Yr.wi});let kr={Point:V,Pixel:Ar,MercatorProjection:G};class s0{constructor(e,t){this.projection=new kr.MercatorProjection,this.levelMax=e,this.levelMin=t;}_getRetain(e){return Math.pow(2,e-18)}getResolution(e,t){return Math.pow(2,18-t)*Math.cos(e)}lnglatToPoint(e,t){let n=new kr.Point(e,t),i=this.projection.lngLatToPoint(n);return {pointX:i.x,pointY:i.y}}pointToLnglat(e,t){let n=new kr.Pixel(e,t),i=this.projection.pointToLngLat(n);return {lng:i.lng,lat:i.lat}}_lngToTileX(e,t){let n=this.lnglatToPoint(e,0);return Math.floor(n.pointX*this._getRetain(t)/256)}_latToTileY(e,t){let n=this.lnglatToPoint(0,e);return Math.floor(n.pointY*this._getRetain(t)/256)}lnglatToTile(e,t,n){let i=this._lngToTileX(e,n),a=this._latToTileY(t,n);return [i,a]}_lngToPixelX(e,t){let n=this._lngToTileX(e,t),i=this.lnglatToPoint(e,0);return Math.floor(i.pointX*this._getRetain(t)-n*256)}_latToPixelY(e,t){let n=this._latToTileY(e,t),i=this.lnglatToPoint(0,e);return Math.floor(i.pointY*this._getRetain(t)-n*256)}lnglatToPixel(e,t,n){let i=this._lngToPixelX(e,n),a=this._latToPixelY(t,n);return {pixelX:i,pixelY:a}}_pixelXToLng(e,t,n){let i=(t*256+e)/this._getRetain(n);return this.pointToLnglat(i,0).lng}_pixelYToLat(e,t,n){let i=(t*256+e)/this._getRetain(n);return this.pointToLnglat(0,i).lat}pixelToLnglat(e,t,n,i,a){let s=(n*256+e)/this._getRetain(a),h=(i*256+t)/this._getRetain(a),c=this.pointToLnglat(s,h);return [c.lng,c.lat]}}Object.freeze=function(r){return r};var h0=/\{ *([\w_-]+) *\}/g;function c0(r,e){return r.replace(h0,function(t,n){let i=e[n];if(i===void 0)throw new Error(`No value provided for variable ${t}`);return typeof i=="function"&&(i=i(e)),i})}class l0{constructor(e,t){if(this.program=null,this.showTiles=[],this.isReadRender=!1,this.isLayerShow=!1,this.tileCache=[],this.gridCache={},this.transformBaidu=new s0,this.maskCache=[],this._projectionMatrix=new ar,this._viewMatrix4=new ar,this._mvpMatrix4=new ar,this.isOrtho=!1,!e)throw new Error("\u8BF7\u4F20\u5165\u5730\u56FE\u5B9E\u4F8B");this.validate(t),this.map=e,this.center=e.getCenter().toArray(),this.options=Object.assign(this.getDefaultGlLayerOptions(),t),this.customCoords=e.customCoords,this.customCoords.lngLatsToCoords([this.center]),this.layer=new AMap.GLCustomLayer({zooms:this.options.zooms,opacity:this.options.opacity,visible:this.options.visible,zIndex:this.options.zIndex,init:n=>{this.gl=n;const i=`
                    uniform mat4 u_ProjectionMatrix;
                    uniform mat4 u_ViewMatrix4;
                    uniform mat4 u_MvpMatrix4;
                    uniform bool u_isOrtho;
                    attribute vec2 a_pos;
                    attribute vec2 a_TextCoord;
                    varying vec2 v_TextCoord;
                    void main() {
                       if(u_isOrtho){
                         gl_Position = u_MvpMatrix4 * vec4(a_pos,0.0, 1.0);
                       }else{
                         gl_Position = u_ProjectionMatrix * u_ViewMatrix4 * vec4(a_pos,0.0, 1.0);
                       }
                       v_TextCoord = a_TextCoord;
                    }`,a=`
                    precision mediump float;
                    uniform sampler2D u_Sampler;
                    uniform bool u_isFirst;
                    varying vec2 v_TextCoord;
                    void main() {
                       if(u_isFirst){
                         gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);
                       }else{
                         gl_FragColor = texture2D(u_Sampler, v_TextCoord);
                       }
                    }`,s=n.createShader(n.VERTEX_SHADER);n.shaderSource(s,i),n.compileShader(s);const h=n.createShader(n.FRAGMENT_SHADER);n.shaderSource(h,a),n.compileShader(h),this.program=n.createProgram(),n.attachShader(this.program,s),n.attachShader(this.program,h),n.linkProgram(this.program),this.a_Pos=n.getAttribLocation(this.program,"a_pos"),this.a_TextCoord=n.getAttribLocation(this.program,"a_TextCoord");const c="uniform mat4 u_ProjectionMatrix;uniform mat4 u_ViewMatrix4;uniform mat4 u_MvpMatrix4;uniform bool u_isOrtho;attribute vec2 a_pos;void main() {   if(u_isOrtho){     gl_Position = u_MvpMatrix4 * vec4(a_pos,0.0, 1.0);   }else{     gl_Position = u_ProjectionMatrix * u_ViewMatrix4 * vec4(a_pos,0.0, 1.0);   }}",l="void main() {    gl_FragColor = vec4(0.0, 1.0, 0.0, 0.0);}",f=n.createShader(n.VERTEX_SHADER);n.shaderSource(f,c),n.compileShader(f);const v=n.createShader(n.FRAGMENT_SHADER);n.shaderSource(v,l),n.compileShader(v),this.maskProgram=n.createProgram(),n.attachShader(this.maskProgram,f),n.attachShader(this.maskProgram,v),n.linkProgram(this.maskProgram),this.mask_Pos=n.getAttribLocation(this.maskProgram,"a_pos"),this.options.visible&&(this.isLayerShow=!0),this.mapCallback=()=>{this.isLayerShow&&this.update();},e.on("dragging",this.mapCallback),e.on("moveend",this.mapCallback),e.on("zoomchange",this.mapCallback),e.on("rotatechange",this.mapCallback),this._createMask(this.options.mask),this.update();},render:n=>{if(!this.isReadRender)return;const i=this.options.zooms;if(!(this.map.getZoom()<i[0]||this.map.getZoom()>i[1])){if(this.customCoords.setCenter(this.center),e.getView().type==="3D"){this.isOrtho=!1;const{near:a,far:s,fov:h,up:c,lookAt:l,position:f}=this.customCoords.getCameraParams();this._viewMatrix4.lookAt({eye:f,center:l,up:c}).translate([0,0,this.options.altitude]),this._projectionMatrix.perspective({fovy:h*Math.PI/180,far:s,near:a,aspect:n.drawingBufferWidth/n.drawingBufferHeight});}else {this.isOrtho=!0;const a=this.customCoords.getMVPMatrix();this._mvpMatrix4.copy(a);}this.reset(n),this.maskCache.length>0?(n.clearStencil(0),n.clear(n.STENCIL_BUFFER_BIT),n.enable(n.STENCIL_TEST),n.stencilFunc(n.ALWAYS,1,255),n.stencilOp(n.KEEP,n.KEEP,n.REPLACE),this._renderMask(n),n.stencilFunc(n.EQUAL,1,255),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.disable(n.DEPTH_TEST),this._renderTile(n),n.enable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST)):this._renderTile(n),this.reset(n);}}}),e.add(this.layer);}_renderMask(e){if(this.maskCache.length){this.customCoords.setCenter(this.center),e.useProgram(this.maskProgram),this.setVertex(e,this.maskProgram);for(const t of this.maskCache)e.bindBuffer(e.ARRAY_BUFFER,t.vertexBuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.indexBuffer),e.vertexAttribPointer(this.mask_Pos,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(this.mask_Pos),e.drawElements(e.TRIANGLES,t.deviationLength,e.UNSIGNED_INT,0);}}_renderTile(e){var t,n,i,a,s,h;this.customCoords.setCenter(this.center),e.useProgram(this.program),this.setVertex(e,this.program);let c=0;for(const l of this.showTiles){if(!l.isLoad||l.imageError)continue;e.bindTexture(e.TEXTURE_2D,l.texture),e.activeTexture(e.TEXTURE0),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT);const f=e.getUniformLocation(this.program,"u_Sampler");e.uniform1i(f,0),e.uniform1f(e.getUniformLocation(this.program,"u_isFirst"),c===0),e.bindBuffer(e.ARRAY_BUFFER,l.buffer),e.vertexAttribPointer(this.a_Pos,(t=l.PosParam)===null||t===void 0?void 0:t.size,e.FLOAT,!1,(n=l.PosParam)===null||n===void 0?void 0:n.stride,(i=l.PosParam)===null||i===void 0?void 0:i.offset),e.vertexAttribPointer(this.a_TextCoord,(a=l.TextCoordParam)===null||a===void 0?void 0:a.size,e.FLOAT,!1,(s=l.TextCoordParam)===null||s===void 0?void 0:s.stride,(h=l.TextCoordParam)===null||h===void 0?void 0:h.offset),e.enableVertexAttribArray(this.a_Pos),e.enableVertexAttribArray(this.a_TextCoord),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.drawArrays(e.TRIANGLE_STRIP,0,4),c++;}}reset(e){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height);}validate(e){if(!e.url)throw new Error("\u8BF7\u4F20\u5165url");if(e.url.includes("{s}")&&(!e.subdomains||e.subdomains.length===0))throw new Error("\u8BF7\u4F20\u5165subdomains")}getDefaultGlLayerOptions(){return {url:"",zooms:[2,18],opacity:1,visible:!0,zIndex:120,proj:"gcj02",tileType:"xyz",debug:!1,cacheSize:512,tileMaxZoom:18,altitude:0}}_createMask(e){if(!e||e.length===0){this.maskCache=[];return}const t=this.getMaskDeep(e);if(t<2||t>4){console.warn("mask\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");return}t===2?e=[[e]]:t===3&&(e=[e]);for(let n of e){n=this._convertMaskLnglatToCoords(n);const i=hr.exports.flatten(n),a=hr.exports(i.vertices,i.holes,i.dimensions),s=this.gl,h=new Float32Array(i.vertices),c=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,c),s.bufferData(s.ARRAY_BUFFER,h,s.STATIC_DRAW),s.bindBuffer(s.ARRAY_BUFFER,null);const l=s.createBuffer();s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,l),s.bufferData(s.ELEMENT_ARRAY_BUFFER,new Uint32Array(a),s.STATIC_DRAW),s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,null),this.maskCache.push({FSIZE:h.BYTES_PER_ELEMENT,vertexBuffer:c,indexBuffer:l,deviationLength:a.length});}}getMaskDeep(e,t=1){return e.length?typeof e[0]=="number"?t:this.getMaskDeep(e[0],t+1):-1}_convertMaskLnglatToCoords(e){return !e||e.length===0?e:typeof e[0]=="number"?this._convertLnglatToCoords([e[0],e[1]]):e.map(t=>this._convertMaskLnglatToCoords(t))}_convertLnglatToCoords(e){return this.customCoords.setCenter(this.center),this.customCoords.lngLatsToCoords([e])[0]}update(){if(!this.gl)return;this.isReadRender=!1;const e=this.gl,t=this.map,n=t.getCenter();let i=Math.ceil(t.getZoom());i>this.options.tileMaxZoom&&(i=this.options.tileMaxZoom);const a=t.getBounds();let s,h,c,l;if(this.options.tileType==="xyz"?(c=a.getNorthWest().toArray(),l=a.getSouthEast().toArray()):(c=a.getSouthWest().toArray(),l=a.getNorthEast().toArray()),this.options.proj==="wgs84"){const o=Qe(...c),M=Qe(...l);s=sr(o.lng,o.lat,i),h=sr(M.lng,M.lat,i);}else if(this.options.proj==="bd09"){const o=Je(...c),M=Je(...l);s=this.transformBaidu.lnglatToTile(o.lng,o.lat,i),h=this.transformBaidu.lnglatToTile(M.lng,M.lat,i);}else s=sr(c[0],c[1],i),h=sr(l[0],l[1],i);const f=[];for(let o=s[0];o<=h[0];o++)for(let M=s[1];M<=h[1];M++){const p={x:o,y:M,z:i};f.push(p),this.addGridCache(p,0,0),o===h[0]&&this.addGridCache(p,1,0),M===h[1]&&this.addGridCache(p,0,1),o===h[0]&&M===h[1]&&this.addGridCache(p,1,1);}let v;this.options.tileType==="xyz"?v=sr(n.getLng(),n.getLat(),i):v=this.transformBaidu.lnglatToTile(n.getLng(),n.getLat(),i),f.sort((o,M)=>this.tileDistance(o,v)-this.tileDistance(M,v)),this._cancelOutViewImage(f),this._clearShowTile();for(const o of f){const M=this.createTileKey(o),p=this.getTileCache(M);if(p){if(p.imageError)continue;!p.isLoad&&p.image&&p.imageCanceled&&(p.image.src=p.url,p.imageCanceled=!1),this.showTiles.push(p);}else {const x=this.createTile(e,o);this.showTiles.push(x),this.pushTileCache(x);}}this.showTiles.length>0&&this.showTiles.unshift(this.showTiles[0]),this.isReadRender=!0;}_cancelOutViewImage(e){this.tileCache.forEach(t=>{e.findIndex(n=>this.createTileKey(n)===t.xyzKey)===-1&&!t.isLoad&&t.image&&(t.image.src="",t.imageCanceled=!0);});}getTileCache(e){return this.tileCache.find(t=>t.xyzKey===e)}pushTileCache(e){const t=this.options.cacheSize;t>0&&this.tileCache.length>=t&&(this.showTiles.findIndex(n=>n.xyzKey===this.tileCache[0].xyzKey)<0&&this._destroyTile(this.tileCache[0]),this.tileCache.splice(0,1)),this.tileCache.push(e);}addGridCache(e,t,n){const i=this.createTileKey(e.x+t,e.y+n,e.z);if(!this.gridCache[i])if(this.options.proj==="wgs84"){const a=t0(...He(e.x+t,e.y+n,e.z)),s=this._convertLnglatToCoords([a.lng,a.lat]);this.gridCache[i]={lng:s[0],lat:s[1]};}else if(this.options.tileType==="bd09"){const a=n0(...this.transformBaidu.pixelToLnglat(0,0,e.x+t,e.y+n,e.z)),s=this._convertLnglatToCoords([a.lng,a.lat]);this.gridCache[i]={lng:s[0],lat:s[1]};}else {const a=this._convertLnglatToCoords(He(e.x+t,e.y+n,e.z));this.gridCache[i]={lng:a[0],lat:a[1]};}}tileDistance(e,t){return Math.sqrt(Math.pow(e.x-t[0],2)+Math.pow(e.y-t[1],2))}createTileKey(e,t,n){return e instanceof Object?`${e.z}/${e.x}/${e.y}`:`${n}/${e}/${t}`}deepFormatTileNumber(e,t){return e>=0&&e<t?e:(e>0&&e>=t?e=e-t:e<0&&(e=e+t),this.deepFormatTileNumber(e,t))}createTile(e,t){let n=Math.ceil(this.map.getZoom());n>this.options.tileMaxZoom&&(n=this.options.tileMaxZoom);const i=Math.pow(2,n);let a=t.x,s=t.y;a=this.deepFormatTileNumber(a,i),s=this.deepFormatTileNumber(s,i);const h={x:a,y:s,z:t.z};this.options.subdomains&&(h.s=this.options.subdomains[Math.abs(t.x+t.y)%this.options.subdomains.length]);const c=c0(this.options.url,h),l={xyz:t,xyzKey:this.createTileKey(t),isLoad:!1,url:c,imageCanceled:!1};let f,v,o,M;this.options.tileType==="xyz"?(f=this.gridCache[this.createTileKey(t)],v=this.gridCache[this.createTileKey(t.x+1,t.y,t.z)],o=this.gridCache[this.createTileKey(t.x,t.y+1,t.z)],M=this.gridCache[this.createTileKey(t.x+1,t.y+1,t.z)]):(f=this.gridCache[this.createTileKey(t.x,t.y+1,t.z)],v=this.gridCache[this.createTileKey(t.x+1,t.y+1,t.z)],o=this.gridCache[this.createTileKey(t)],M=this.gridCache[this.createTileKey(t.x+1,t.y,t.z)]);const p=new Float32Array([f.lng,f.lat,0,1,o.lng,o.lat,0,0,v.lng,v.lat,1,1,M.lng,M.lat,1,0]),x=p.BYTES_PER_ELEMENT,y=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,y),e.bufferData(e.ARRAY_BUFFER,p,e.STATIC_DRAW),l.buffer=y,l.PosParam={size:2,stride:x*4,offset:0},l.TextCoordParam={size:2,stride:x*4,offset:x*2};const d=new Image(256,256);return d.onload=()=>{if(l.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,l.texture),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,1),this.options.debug){const R=document.createElement("canvas");R.width=256,R.height=256;const m=R.getContext("2d");m.drawImage(d,0,0),m.font="25px Verdana",m.fillStyle="#ff0000",m.strokeStyle="#FF0000",m.strokeRect(0,0,256,256),m.fillText(`(${[t.x,t.y,t.z].join(",")})`,10,30),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,R);}else e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,d);l.isLoad=!0,this.showTiles.findIndex(R=>R===l)>=0&&this.requestRender();},d.onerror=()=>{l.imageCanceled||(l.imageError=!0);},d.crossOrigin="anonymous",d.src=c,l.image=d,l}setVertex(e,t){e.uniformMatrix4fv(e.getUniformLocation(t,"u_ProjectionMatrix"),!1,this._projectionMatrix.toArray()),e.uniformMatrix4fv(e.getUniformLocation(t,"u_ViewMatrix4"),!1,this._viewMatrix4.toArray()),e.uniformMatrix4fv(e.getUniformLocation(t,"u_MvpMatrix4"),!1,this._mvpMatrix4.toArray()),e.uniform1f(e.getUniformLocation(t,"u_isOrtho"),this.isOrtho);}requestRender(){this.map&&(this.map.getContext().setDirty(),this.map.setNeedUpdate(!0));}show(){this.isLayerShow=!0,this.update(),this.layer.show();}hide(){this.isLayerShow=!1,this.layer.hide();}getzIndex(){return this.layer.getzIndex()}setzIndex(e){this.options.zIndex=e,this.layer.setzIndex(e);}getOpacity(){return this.layer.getOpacity()}setOpacity(e){this.options.opacity=e,this.layer.setOpacity(e);}getZooms(){return this.layer.getZooms()}setZooms(e){this.options.zooms=e,this.layer.setZooms(e);}setMask(e){this._destroyMaskCache(),this._createMask(e),this.options.mask=e,this.requestRender();}getMask(){return this.options.mask}getMap(){return this.map}_destroyMaskCache(){this.maskCache.forEach(e=>{this.gl.deleteBuffer(e.vertexBuffer),this.gl.deleteBuffer(e.indexBuffer);}),this.maskCache=[];}_destroyTile(e){e.buffer&&this.gl.deleteBuffer(e.buffer),e.texture&&this.gl.deleteTexture(e.texture);}_clearAllCacheTile(){this.tileCache.forEach(e=>{this._destroyTile(e);}),this.tileCache=[];}_clearShowTile(){this.showTiles.forEach(e=>{this.tileCache.findIndex(t=>t.xyzKey===e.xyzKey)<0&&this._destroyTile(e);}),this.showTiles=[];}destroy(){this.isLayerShow=!1,this.map.remove(this.layer),this.map.off("dragging",this.mapCallback),this.map.off("moveend",this.mapCallback),this.map.off("zoomchange",this.mapCallback),this.map.off("rotatechange",this.mapCallback),this._destroyMaskCache(),this._clearShowTile(),this._clearAllCacheTile(),this.gridCache={},this.transformBaidu=null,this.mapCallback=null,this.gl.deleteProgram(this.program),this.gl.deleteProgram(this.maskProgram),this.program=null,this.maskProgram=null,this.options=void 0,this.customCoords=void 0,this.center=void 0,this.layer=null,this.gl=null,this.map=null;}}

const propsTypes = buildProps({
  url: {
    required: true,
    type: String
  },
  // 瓦片地址，支持 {s} {x} {y} {z}，示例：http://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}
  subdomains: {
    type: Array
  },
  // 子域名数组，当url中设置{s}后，该属性必填
  tileType: {
    type: String,
    default: "xyz",
    validator: (value) => {
      return ["xyz", "bd09"].indexOf(value) !== -1;
    }
  },
  // 瓦片分割类型，默认是xyz，xyz代表瓦片是编号是从左上角开始，百度瓦片是由中间开始，所以需要区分普通瓦片还是百度
  proj: {
    type: String,
    default: "gcj02",
    validator: (value) => {
      return ["wgs84", "gcj02", "bd09"].indexOf(value) !== -1;
    }
  },
  // 瓦片使用的坐标系，默认是gcj02
  zooms: {
    type: Object
  },
  // 图层缩放等级范围，默认 [2, 18]
  opacity: {
    type: Number
  },
  // 图层透明度，默认为 1
  zIndex: {
    type: Number,
    default: 120
  },
  mask: {
    type: Array
  },
  cacheSize: {
    type: Number,
    default: 512
  },
  debug: {
    type: Boolean,
    default: false
  },
  tileMaxZoom: {
    type: Number
  },
  altitude: {
    type: Number
  }
});

var script = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElAmapLayerCustomXyz",
    inheritAttrs: false
  },
  __name: "CustomXyz",
  props: propsTypes,
  emits: ["init"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    let $amapComponent;
    const { $$getInstance } = useRegister((options, parentComponent) => {
      return new Promise((resolve) => {
        $amapComponent = new l0(parentComponent, options);
        resolve($amapComponent);
      });
    }, {
      emits,
      destroyComponent() {
        if ($amapComponent) {
          $amapComponent.destroy();
          $amapComponent = null;
        }
      }
    });
    __expose({
      $$getInstance
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});

script.__file = "src/vue-amap/packages/layer/data/CustomXyz/CustomXyz.vue";

script.install = (app) => {
  app.component(script.name, script);
  return app;
};
const ElAmapLayerCustomXyz = script;

var Components = [
  ElAmap,
  ElAmapControlControlBar,
  ElAmapControlHawkEye,
  ElAmapControlMapType,
  ElAmapControlScale,
  ElAmapControlToolBar,
  ElAmapSearchBox,
  ElAmapInfoWindow,
  ElAmapLayerCanvas,
  ElAmapLayerCustom,
  ElAmapLayerFlexible,
  ElAmapLayerGlCustom,
  ElAmapLayerHeatMap,
  ElAmapLayerImage,
  ElAmapLayerLabels,
  ElAmapLayerVector,
  ElAmapLayerBuildings,
  ElAmapLayerDefault,
  ElAmapLayerDistrict,
  ElAmapLayerIndoorMap,
  ElAmapLayerRoadNet,
  ElAmapLayerSatellite,
  ElAmapLayerTile,
  ElAmapLayerTraffic,
  ElAmapLayerMapboxVectorTile,
  ElAmapLayerWms,
  ElAmapLayerWmts,
  ElAmapElasticMarker,
  ElAmapLabelMarker,
  ElAmapMarker,
  ElAmapMarkerCluster,
  ElAmapMassMarks,
  ElAmapText,
  ElAmapBezierCurve,
  ElAmapCircle,
  ElAmapEllipse,
  ElAmapGeojson,
  ElAmapPolygon,
  ElAmapPolyline,
  ElAmapRectangle,
  ElAmapLayerTiles3d,
  ElAmapControlGeolocation,
  ElAmapCircleMarker,
  ElAmapLayerVideo,
  ElAmapMouseTool,
  ElAmapLayerDistrictCluster,
  ElAmapLayerCustomXyz
];

var installer = makeInstaller([...Components]);

function useCitySearch() {
  return new Promise((resolve) => {
    AMap.plugin("AMap.CitySearch", function() {
      const citySearch = new AMap.CitySearch();
      const getLocalCity = () => {
        return new Promise((resolve2, reject) => {
          citySearch.getLocalCity(function(status, result) {
            if (status === "complete" && result.info === "OK") {
              resolve2(result);
            } else {
              reject({
                status,
                result
              });
            }
          });
        });
      };
      resolve({
        getLocalCity
      });
    });
  });
}

function useWeather() {
  return new Promise((resolve) => {
    AMap.plugin("AMap.Weather", function() {
      const weather = new AMap.Weather();
      const getLive = (city) => {
        return new Promise((resolve2, reject) => {
          weather.getLive(city, function(err, result) {
            if (!err && result.info === "OK") {
              resolve2(result);
            } else {
              reject({
                result
              });
            }
          });
        });
      };
      const getForecast = (city) => {
        return new Promise((resolve2, reject) => {
          weather.getForecast(city, function(err, result) {
            if (!err && result.info === "OK") {
              resolve2(result);
            } else {
              reject({
                result
              });
            }
          });
        });
      };
      resolve({
        getLive,
        getForecast
      });
    });
  });
}

function useGeolocation(options) {
  return new Promise((resolve) => {
    AMap.plugin("AMap.Geolocation", function() {
      const geolocation = new AMap.Geolocation(options);
      const getCurrentPosition = () => {
        return new Promise((resolve2, reject) => {
          geolocation.getCurrentPosition(function(status, result) {
            if (status === "complete" && result.info === "SUCCESS") {
              resolve2(result);
            } else {
              reject({
                status,
                result
              });
            }
          });
        });
      };
      const getCityInfo = () => {
        return new Promise((resolve2, reject) => {
          geolocation.getCityInfo(function(status, result) {
            if (status === "complete" && result.info === "SUCCESS") {
              resolve2(result);
            } else {
              reject({
                status,
                result
              });
            }
          });
        });
      };
      resolve({
        getCurrentPosition,
        getCityInfo
      });
    });
  });
}

const install = installer.install;

export { ElAmap, ElAmapBezierCurve, ElAmapCircle, ElAmapCircleMarker, ElAmapControlControlBar, ElAmapControlGeolocation, ElAmapControlHawkEye, ElAmapControlMapType, ElAmapControlScale, ElAmapControlToolBar, ElAmapElasticMarker, ElAmapEllipse, ElAmapGeojson, ElAmapInfoWindow, ElAmapLabelMarker, ElAmapLayerBuildings, ElAmapLayerCanvas, ElAmapLayerCustom, ElAmapLayerCustomXyz, ElAmapLayerDefault, ElAmapLayerDistrict, ElAmapLayerDistrictCluster, ElAmapLayerFlexible, ElAmapLayerGlCustom, ElAmapLayerHeatMap, ElAmapLayerImage, ElAmapLayerIndoorMap, ElAmapLayerLabels, ElAmapLayerMapboxVectorTile, ElAmapLayerRoadNet, ElAmapLayerSatellite, ElAmapLayerTile, ElAmapLayerTiles3d, ElAmapLayerTraffic, ElAmapLayerVector, ElAmapLayerVideo, ElAmapLayerWms, ElAmapLayerWmts, ElAmapMarker, ElAmapMarkerCluster, ElAmapMassMarks, ElAmapMouseTool, ElAmapPolygon, ElAmapPolyline, ElAmapRectangle, ElAmapSearchBox, ElAmapText, bd09_To_gcj02, bd09_To_gps84, bindInstanceEvent, buildProps, commonProps, convertEventToLowerCase, convertLnglat, installer as default, eventReg, gcj02_To_bd09, gcj02_To_gps84, gps84_To_bd09, gps84_To_gcj02, guid, initAMapApiLoader, install, isIndoorMapInstance, isLabelsLayerInstance, isMapInstance, isOverlayGroupInstance, isVectorLayerInstance, lazyAMapApiLoaderInstance, lngLatTo, loadScript, lonLatToTileNumbers, makeInstaller, pixelTo, provideKey, registerComponent as registerMixin, removeInstanceEvent, resetJsApi, tileNumbersToLonLat, toBounds, toLngLat, toPixel, toSize, upperCamelCase, useCitySearch, useGeolocation, useRegister, useWeather };
